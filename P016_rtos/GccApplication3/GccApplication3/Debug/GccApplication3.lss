
GccApplication3.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000006  00800100  00000cce  00000d62  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000cce  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000646  00800106  00800106  00000d68  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000d68  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000d98  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000218  00000000  00000000  00000dd8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002a9d  00000000  00000000  00000ff0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000d0d  00000000  00000000  00003a8d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000168d  00000000  00000000  0000479a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000005f0  00000000  00000000  00005e28  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001013  00000000  00000000  00006418  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000021a7  00000000  00000000  0000742b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000240  00000000  00000000  000095d2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 62 06 	jmp	0xcc4	; 0xcc4 <__vector_11>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	ee ec       	ldi	r30, 0xCE	; 206
  7c:	fc e0       	ldi	r31, 0x0C	; 12
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	a6 30       	cpi	r26, 0x06	; 6
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	27 e0       	ldi	r18, 0x07	; 7
  8c:	a6 e0       	ldi	r26, 0x06	; 6
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	ac 34       	cpi	r26, 0x4C	; 76
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 81 00 	call	0x102	; 0x102 <main>
  9e:	0c 94 65 06 	jmp	0xcca	; 0xcca <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <_Z7Blink10Pv>:
void Blink10(void *){
	
	const int delayTime = 1000 / portTICK_PERIOD_MS;
	
	while(1){
		vTaskSuspendAll();
  a6:	0e 94 4e 02 	call	0x49c	; 0x49c <vTaskSuspendAll>
		set_port(PIN_PORT_2,PIN_MASK_2,0xFF);
  aa:	8b b1       	in	r24, 0x0b	; 11
  ac:	84 60       	ori	r24, 0x04	; 4
  ae:	8b b9       	out	0x0b, r24	; 11
		xTaskResumeAll();
  b0:	0e 94 0f 03 	call	0x61e	; 0x61e <xTaskResumeAll>
		
		vTaskDelay(delayTime);
  b4:	88 ee       	ldi	r24, 0xE8	; 232
  b6:	93 e0       	ldi	r25, 0x03	; 3
  b8:	0e 94 8e 03 	call	0x71c	; 0x71c <vTaskDelay>
		
		vTaskSuspendAll();
  bc:	0e 94 4e 02 	call	0x49c	; 0x49c <vTaskSuspendAll>
		set_port(PIN_PORT_2,PIN_MASK_2,0x00);
  c0:	8b b1       	in	r24, 0x0b	; 11
  c2:	8b 7f       	andi	r24, 0xFB	; 251
  c4:	8b b9       	out	0x0b, r24	; 11
		xTaskResumeAll();
  c6:	0e 94 0f 03 	call	0x61e	; 0x61e <xTaskResumeAll>
		
		vTaskDelay(delayTime);
  ca:	88 ee       	ldi	r24, 0xE8	; 232
  cc:	93 e0       	ldi	r25, 0x03	; 3
  ce:	0e 94 8e 03 	call	0x71c	; 0x71c <vTaskDelay>
  d2:	e9 cf       	rjmp	.-46     	; 0xa6 <_Z7Blink10Pv>

000000d4 <_Z7Blink11Pv>:
void Blink11(void *){
	
	const int delayTime = 500 / portTICK_PERIOD_MS;
	
	while(1){
		vTaskSuspendAll();
  d4:	0e 94 4e 02 	call	0x49c	; 0x49c <vTaskSuspendAll>
		set_port(PIN_PORT_3,PIN_MASK_3,0xFF);
  d8:	8b b1       	in	r24, 0x0b	; 11
  da:	88 60       	ori	r24, 0x08	; 8
  dc:	8b b9       	out	0x0b, r24	; 11
		xTaskResumeAll();
  de:	0e 94 0f 03 	call	0x61e	; 0x61e <xTaskResumeAll>
	
		vTaskDelay(delayTime);
  e2:	84 ef       	ldi	r24, 0xF4	; 244
  e4:	91 e0       	ldi	r25, 0x01	; 1
  e6:	0e 94 8e 03 	call	0x71c	; 0x71c <vTaskDelay>
	
		vTaskSuspendAll();
  ea:	0e 94 4e 02 	call	0x49c	; 0x49c <vTaskSuspendAll>
		set_port(PIN_PORT_3,PIN_MASK_3,0x00);
  ee:	8b b1       	in	r24, 0x0b	; 11
  f0:	87 7f       	andi	r24, 0xF7	; 247
  f2:	8b b9       	out	0x0b, r24	; 11
		xTaskResumeAll();
  f4:	0e 94 0f 03 	call	0x61e	; 0x61e <xTaskResumeAll>
	
		vTaskDelay(delayTime);
  f8:	84 ef       	ldi	r24, 0xF4	; 244
  fa:	91 e0       	ldi	r25, 0x01	; 1
  fc:	0e 94 8e 03 	call	0x71c	; 0x71c <vTaskDelay>
 100:	e9 cf       	rjmp	.-46     	; 0xd4 <_Z7Blink11Pv>

00000102 <main>:
void Blink10(void *);
void Blink11(void *);
int main(void)
{
	//DDRD = 0x00;
	DDRD |= (PIN_MASK_2 | PIN_MASK_3);
 102:	8a b1       	in	r24, 0x0a	; 10
 104:	8c 60       	ori	r24, 0x0C	; 12
 106:	8a b9       	out	0x0a, r24	; 10
	PORTD = 0xFF;
 108:	8f ef       	ldi	r24, 0xFF	; 255
 10a:	8b b9       	out	0x0b, r24	; 11
	
	xTaskCreate(Blink10,NULL,128,NULL,2,NULL);
 10c:	e1 2c       	mov	r14, r1
 10e:	f1 2c       	mov	r15, r1
 110:	02 e0       	ldi	r16, 0x02	; 2
 112:	20 e0       	ldi	r18, 0x00	; 0
 114:	30 e0       	ldi	r19, 0x00	; 0
 116:	40 e8       	ldi	r20, 0x80	; 128
 118:	50 e0       	ldi	r21, 0x00	; 0
 11a:	60 e0       	ldi	r22, 0x00	; 0
 11c:	70 e0       	ldi	r23, 0x00	; 0
 11e:	83 e5       	ldi	r24, 0x53	; 83
 120:	90 e0       	ldi	r25, 0x00	; 0
 122:	0e 94 17 01 	call	0x22e	; 0x22e <xTaskCreate>
	xTaskCreate(Blink11,NULL,128,NULL,2,NULL);
 126:	20 e0       	ldi	r18, 0x00	; 0
 128:	30 e0       	ldi	r19, 0x00	; 0
 12a:	40 e8       	ldi	r20, 0x80	; 128
 12c:	50 e0       	ldi	r21, 0x00	; 0
 12e:	60 e0       	ldi	r22, 0x00	; 0
 130:	70 e0       	ldi	r23, 0x00	; 0
 132:	8a e6       	ldi	r24, 0x6A	; 106
 134:	90 e0       	ldi	r25, 0x00	; 0
 136:	0e 94 17 01 	call	0x22e	; 0x22e <xTaskCreate>
	vTaskStartScheduler();
 13a:	0e 94 24 02 	call	0x448	; 0x448 <vTaskStartScheduler>
 13e:	ff cf       	rjmp	.-2      	; 0x13e <main+0x3c>

00000140 <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 140:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxDelayedTaskList>
 144:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxDelayedTaskList+0x1>
 148:	80 81       	ld	r24, Z
 14a:	81 11       	cpse	r24, r1
 14c:	07 c0       	rjmp	.+14     	; 0x15c <prvResetNextTaskUnblockTime+0x1c>
 14e:	8f ef       	ldi	r24, 0xFF	; 255
 150:	9f ef       	ldi	r25, 0xFF	; 255
 152:	90 93 0a 01 	sts	0x010A, r25	; 0x80010a <xNextTaskUnblockTime+0x1>
 156:	80 93 09 01 	sts	0x0109, r24	; 0x800109 <xNextTaskUnblockTime>
 15a:	08 95       	ret
 15c:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxDelayedTaskList>
 160:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxDelayedTaskList+0x1>
 164:	05 80       	ldd	r0, Z+5	; 0x05
 166:	f6 81       	ldd	r31, Z+6	; 0x06
 168:	e0 2d       	mov	r30, r0
 16a:	06 80       	ldd	r0, Z+6	; 0x06
 16c:	f7 81       	ldd	r31, Z+7	; 0x07
 16e:	e0 2d       	mov	r30, r0
 170:	82 81       	ldd	r24, Z+2	; 0x02
 172:	93 81       	ldd	r25, Z+3	; 0x03
 174:	90 93 0a 01 	sts	0x010A, r25	; 0x80010a <xNextTaskUnblockTime+0x1>
 178:	80 93 09 01 	sts	0x0109, r24	; 0x800109 <xNextTaskUnblockTime>
 17c:	08 95       	ret

0000017e <prvAddCurrentTaskToDelayedList>:
 17e:	ff 92       	push	r15
 180:	0f 93       	push	r16
 182:	1f 93       	push	r17
 184:	cf 93       	push	r28
 186:	df 93       	push	r29
 188:	ec 01       	movw	r28, r24
 18a:	f6 2e       	mov	r15, r22
 18c:	00 91 11 01 	lds	r16, 0x0111	; 0x800111 <xTickCount>
 190:	10 91 12 01 	lds	r17, 0x0112	; 0x800112 <xTickCount+0x1>
 194:	80 91 6a 01 	lds	r24, 0x016A	; 0x80016a <pxCurrentTCB>
 198:	90 91 6b 01 	lds	r25, 0x016B	; 0x80016b <pxCurrentTCB+0x1>
 19c:	02 96       	adiw	r24, 0x02	; 2
 19e:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
 1a2:	cf 3f       	cpi	r28, 0xFF	; 255
 1a4:	8f ef       	ldi	r24, 0xFF	; 255
 1a6:	d8 07       	cpc	r29, r24
 1a8:	69 f4       	brne	.+26     	; 0x1c4 <prvAddCurrentTaskToDelayedList+0x46>
 1aa:	ff 20       	and	r15, r15
 1ac:	59 f0       	breq	.+22     	; 0x1c4 <prvAddCurrentTaskToDelayedList+0x46>
 1ae:	60 91 6a 01 	lds	r22, 0x016A	; 0x80016a <pxCurrentTCB>
 1b2:	70 91 6b 01 	lds	r23, 0x016B	; 0x80016b <pxCurrentTCB+0x1>
 1b6:	6e 5f       	subi	r22, 0xFE	; 254
 1b8:	7f 4f       	sbci	r23, 0xFF	; 255
 1ba:	84 e1       	ldi	r24, 0x14	; 20
 1bc:	91 e0       	ldi	r25, 0x01	; 1
 1be:	0e 94 8d 04 	call	0x91a	; 0x91a <vListInsertEnd>
 1c2:	2f c0       	rjmp	.+94     	; 0x222 <prvAddCurrentTaskToDelayedList+0xa4>
 1c4:	c0 0f       	add	r28, r16
 1c6:	d1 1f       	adc	r29, r17
 1c8:	e0 91 6a 01 	lds	r30, 0x016A	; 0x80016a <pxCurrentTCB>
 1cc:	f0 91 6b 01 	lds	r31, 0x016B	; 0x80016b <pxCurrentTCB+0x1>
 1d0:	d3 83       	std	Z+3, r29	; 0x03
 1d2:	c2 83       	std	Z+2, r28	; 0x02
 1d4:	c0 17       	cp	r28, r16
 1d6:	d1 07       	cpc	r29, r17
 1d8:	68 f4       	brcc	.+26     	; 0x1f4 <prvAddCurrentTaskToDelayedList+0x76>
 1da:	60 91 6a 01 	lds	r22, 0x016A	; 0x80016a <pxCurrentTCB>
 1de:	70 91 6b 01 	lds	r23, 0x016B	; 0x80016b <pxCurrentTCB+0x1>
 1e2:	80 91 30 01 	lds	r24, 0x0130	; 0x800130 <pxOverflowDelayedTaskList>
 1e6:	90 91 31 01 	lds	r25, 0x0131	; 0x800131 <pxOverflowDelayedTaskList+0x1>
 1ea:	6e 5f       	subi	r22, 0xFE	; 254
 1ec:	7f 4f       	sbci	r23, 0xFF	; 255
 1ee:	0e 94 ae 04 	call	0x95c	; 0x95c <vListInsert>
 1f2:	17 c0       	rjmp	.+46     	; 0x222 <prvAddCurrentTaskToDelayedList+0xa4>
 1f4:	60 91 6a 01 	lds	r22, 0x016A	; 0x80016a <pxCurrentTCB>
 1f8:	70 91 6b 01 	lds	r23, 0x016B	; 0x80016b <pxCurrentTCB+0x1>
 1fc:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <pxDelayedTaskList>
 200:	90 91 33 01 	lds	r25, 0x0133	; 0x800133 <pxDelayedTaskList+0x1>
 204:	6e 5f       	subi	r22, 0xFE	; 254
 206:	7f 4f       	sbci	r23, 0xFF	; 255
 208:	0e 94 ae 04 	call	0x95c	; 0x95c <vListInsert>
 20c:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <xNextTaskUnblockTime>
 210:	90 91 0a 01 	lds	r25, 0x010A	; 0x80010a <xNextTaskUnblockTime+0x1>
 214:	c8 17       	cp	r28, r24
 216:	d9 07       	cpc	r29, r25
 218:	20 f4       	brcc	.+8      	; 0x222 <prvAddCurrentTaskToDelayedList+0xa4>
 21a:	d0 93 0a 01 	sts	0x010A, r29	; 0x80010a <xNextTaskUnblockTime+0x1>
 21e:	c0 93 09 01 	sts	0x0109, r28	; 0x800109 <xNextTaskUnblockTime>
 222:	df 91       	pop	r29
 224:	cf 91       	pop	r28
 226:	1f 91       	pop	r17
 228:	0f 91       	pop	r16
 22a:	ff 90       	pop	r15
 22c:	08 95       	ret

0000022e <xTaskCreate>:
 22e:	4f 92       	push	r4
 230:	5f 92       	push	r5
 232:	6f 92       	push	r6
 234:	7f 92       	push	r7
 236:	8f 92       	push	r8
 238:	9f 92       	push	r9
 23a:	af 92       	push	r10
 23c:	bf 92       	push	r11
 23e:	cf 92       	push	r12
 240:	df 92       	push	r13
 242:	ef 92       	push	r14
 244:	ff 92       	push	r15
 246:	0f 93       	push	r16
 248:	cf 93       	push	r28
 24a:	df 93       	push	r29
 24c:	4c 01       	movw	r8, r24
 24e:	6b 01       	movw	r12, r22
 250:	5a 01       	movw	r10, r20
 252:	29 01       	movw	r4, r18
 254:	ca 01       	movw	r24, r20
 256:	0e 94 45 04 	call	0x88a	; 0x88a <pvPortMalloc>
 25a:	3c 01       	movw	r6, r24
 25c:	89 2b       	or	r24, r25
 25e:	09 f4       	brne	.+2      	; 0x262 <xTaskCreate+0x34>
 260:	e2 c0       	rjmp	.+452    	; 0x426 <__EEPROM_REGION_LENGTH__+0x26>
 262:	86 e2       	ldi	r24, 0x26	; 38
 264:	90 e0       	ldi	r25, 0x00	; 0
 266:	0e 94 45 04 	call	0x88a	; 0x88a <pvPortMalloc>
 26a:	ec 01       	movw	r28, r24
 26c:	89 2b       	or	r24, r25
 26e:	71 f0       	breq	.+28     	; 0x28c <xTaskCreate+0x5e>
 270:	78 8e       	std	Y+24, r7	; 0x18
 272:	6f 8a       	std	Y+23, r6	; 0x17
 274:	81 e0       	ldi	r24, 0x01	; 1
 276:	a8 1a       	sub	r10, r24
 278:	b1 08       	sbc	r11, r1
 27a:	a6 0c       	add	r10, r6
 27c:	b7 1c       	adc	r11, r7
 27e:	d6 01       	movw	r26, r12
 280:	8c 91       	ld	r24, X
 282:	89 8f       	std	Y+25, r24	; 0x19
 284:	8c 91       	ld	r24, X
 286:	81 11       	cpse	r24, r1
 288:	05 c0       	rjmp	.+10     	; 0x294 <xTaskCreate+0x66>
 28a:	18 c0       	rjmp	.+48     	; 0x2bc <xTaskCreate+0x8e>
 28c:	c3 01       	movw	r24, r6
 28e:	0e 94 7a 04 	call	0x8f4	; 0x8f4 <vPortFree>
 292:	c9 c0       	rjmp	.+402    	; 0x426 <__EEPROM_REGION_LENGTH__+0x26>
 294:	ae 01       	movw	r20, r28
 296:	46 5e       	subi	r20, 0xE6	; 230
 298:	5f 4f       	sbci	r21, 0xFF	; 255
 29a:	f6 01       	movw	r30, r12
 29c:	31 96       	adiw	r30, 0x01	; 1
 29e:	b8 e0       	ldi	r27, 0x08	; 8
 2a0:	cb 0e       	add	r12, r27
 2a2:	d1 1c       	adc	r13, r1
 2a4:	cf 01       	movw	r24, r30
 2a6:	21 91       	ld	r18, Z+
 2a8:	da 01       	movw	r26, r20
 2aa:	2d 93       	st	X+, r18
 2ac:	ad 01       	movw	r20, r26
 2ae:	dc 01       	movw	r26, r24
 2b0:	8c 91       	ld	r24, X
 2b2:	88 23       	and	r24, r24
 2b4:	19 f0       	breq	.+6      	; 0x2bc <xTaskCreate+0x8e>
 2b6:	ec 15       	cp	r30, r12
 2b8:	fd 05       	cpc	r31, r13
 2ba:	a1 f7       	brne	.-24     	; 0x2a4 <xTaskCreate+0x76>
 2bc:	18 a2       	std	Y+32, r1	; 0x20
 2be:	04 30       	cpi	r16, 0x04	; 4
 2c0:	08 f0       	brcs	.+2      	; 0x2c4 <xTaskCreate+0x96>
 2c2:	03 e0       	ldi	r16, 0x03	; 3
 2c4:	0e 8b       	std	Y+22, r16	; 0x16
 2c6:	6e 01       	movw	r12, r28
 2c8:	b2 e0       	ldi	r27, 0x02	; 2
 2ca:	cb 0e       	add	r12, r27
 2cc:	d1 1c       	adc	r13, r1
 2ce:	c6 01       	movw	r24, r12
 2d0:	0e 94 89 04 	call	0x912	; 0x912 <vListInitialiseItem>
 2d4:	ce 01       	movw	r24, r28
 2d6:	0c 96       	adiw	r24, 0x0c	; 12
 2d8:	0e 94 89 04 	call	0x912	; 0x912 <vListInitialiseItem>
 2dc:	d9 87       	std	Y+9, r29	; 0x09
 2de:	c8 87       	std	Y+8, r28	; 0x08
 2e0:	84 e0       	ldi	r24, 0x04	; 4
 2e2:	90 e0       	ldi	r25, 0x00	; 0
 2e4:	80 1b       	sub	r24, r16
 2e6:	91 09       	sbc	r25, r1
 2e8:	9d 87       	std	Y+13, r25	; 0x0d
 2ea:	8c 87       	std	Y+12, r24	; 0x0c
 2ec:	db 8b       	std	Y+19, r29	; 0x13
 2ee:	ca 8b       	std	Y+18, r28	; 0x12
 2f0:	19 a2       	std	Y+33, r1	; 0x21
 2f2:	1a a2       	std	Y+34, r1	; 0x22
 2f4:	1b a2       	std	Y+35, r1	; 0x23
 2f6:	1c a2       	std	Y+36, r1	; 0x24
 2f8:	1d a2       	std	Y+37, r1	; 0x25
 2fa:	a2 01       	movw	r20, r4
 2fc:	b4 01       	movw	r22, r8
 2fe:	c5 01       	movw	r24, r10
 300:	0e 94 05 05 	call	0xa0a	; 0xa0a <pxPortInitialiseStack>
 304:	99 83       	std	Y+1, r25	; 0x01
 306:	88 83       	st	Y, r24
 308:	e1 14       	cp	r14, r1
 30a:	f1 04       	cpc	r15, r1
 30c:	19 f0       	breq	.+6      	; 0x314 <xTaskCreate+0xe6>
 30e:	f7 01       	movw	r30, r14
 310:	d1 83       	std	Z+1, r29	; 0x01
 312:	c0 83       	st	Z, r28
 314:	0f b6       	in	r0, 0x3f	; 63
 316:	f8 94       	cli
 318:	0f 92       	push	r0
 31a:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <uxCurrentNumberOfTasks>
 31e:	8f 5f       	subi	r24, 0xFF	; 255
 320:	80 93 13 01 	sts	0x0113, r24	; 0x800113 <uxCurrentNumberOfTasks>
 324:	80 91 6a 01 	lds	r24, 0x016A	; 0x80016a <pxCurrentTCB>
 328:	90 91 6b 01 	lds	r25, 0x016B	; 0x80016b <pxCurrentTCB+0x1>
 32c:	89 2b       	or	r24, r25
 32e:	d1 f5       	brne	.+116    	; 0x3a4 <xTaskCreate+0x176>
 330:	d0 93 6b 01 	sts	0x016B, r29	; 0x80016b <pxCurrentTCB+0x1>
 334:	c0 93 6a 01 	sts	0x016A, r28	; 0x80016a <pxCurrentTCB>
 338:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <uxCurrentNumberOfTasks>
 33c:	81 30       	cpi	r24, 0x01	; 1
 33e:	09 f0       	breq	.+2      	; 0x342 <xTaskCreate+0x114>
 340:	41 c0       	rjmp	.+130    	; 0x3c4 <xTaskCreate+0x196>
 342:	86 e4       	ldi	r24, 0x46	; 70
 344:	91 e0       	ldi	r25, 0x01	; 1
 346:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <vListInitialise>
 34a:	8f e4       	ldi	r24, 0x4F	; 79
 34c:	91 e0       	ldi	r25, 0x01	; 1
 34e:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <vListInitialise>
 352:	88 e5       	ldi	r24, 0x58	; 88
 354:	91 e0       	ldi	r25, 0x01	; 1
 356:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <vListInitialise>
 35a:	81 e6       	ldi	r24, 0x61	; 97
 35c:	91 e0       	ldi	r25, 0x01	; 1
 35e:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <vListInitialise>
 362:	8d e3       	ldi	r24, 0x3D	; 61
 364:	91 e0       	ldi	r25, 0x01	; 1
 366:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <vListInitialise>
 36a:	84 e3       	ldi	r24, 0x34	; 52
 36c:	91 e0       	ldi	r25, 0x01	; 1
 36e:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <vListInitialise>
 372:	87 e2       	ldi	r24, 0x27	; 39
 374:	91 e0       	ldi	r25, 0x01	; 1
 376:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <vListInitialise>
 37a:	8e e1       	ldi	r24, 0x1E	; 30
 37c:	91 e0       	ldi	r25, 0x01	; 1
 37e:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <vListInitialise>
 382:	84 e1       	ldi	r24, 0x14	; 20
 384:	91 e0       	ldi	r25, 0x01	; 1
 386:	0e 94 7b 04 	call	0x8f6	; 0x8f6 <vListInitialise>
 38a:	8d e3       	ldi	r24, 0x3D	; 61
 38c:	91 e0       	ldi	r25, 0x01	; 1
 38e:	90 93 33 01 	sts	0x0133, r25	; 0x800133 <pxDelayedTaskList+0x1>
 392:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <pxDelayedTaskList>
 396:	84 e3       	ldi	r24, 0x34	; 52
 398:	91 e0       	ldi	r25, 0x01	; 1
 39a:	90 93 31 01 	sts	0x0131, r25	; 0x800131 <pxOverflowDelayedTaskList+0x1>
 39e:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <pxOverflowDelayedTaskList>
 3a2:	10 c0       	rjmp	.+32     	; 0x3c4 <xTaskCreate+0x196>
 3a4:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <xSchedulerRunning>
 3a8:	81 11       	cpse	r24, r1
 3aa:	0c c0       	rjmp	.+24     	; 0x3c4 <xTaskCreate+0x196>
 3ac:	e0 91 6a 01 	lds	r30, 0x016A	; 0x80016a <pxCurrentTCB>
 3b0:	f0 91 6b 01 	lds	r31, 0x016B	; 0x80016b <pxCurrentTCB+0x1>
 3b4:	96 89       	ldd	r25, Z+22	; 0x16
 3b6:	8e 89       	ldd	r24, Y+22	; 0x16
 3b8:	89 17       	cp	r24, r25
 3ba:	20 f0       	brcs	.+8      	; 0x3c4 <xTaskCreate+0x196>
 3bc:	d0 93 6b 01 	sts	0x016B, r29	; 0x80016b <pxCurrentTCB+0x1>
 3c0:	c0 93 6a 01 	sts	0x016A, r28	; 0x80016a <pxCurrentTCB>
 3c4:	80 91 0b 01 	lds	r24, 0x010B	; 0x80010b <uxTaskNumber>
 3c8:	8f 5f       	subi	r24, 0xFF	; 255
 3ca:	80 93 0b 01 	sts	0x010B, r24	; 0x80010b <uxTaskNumber>
 3ce:	8e 89       	ldd	r24, Y+22	; 0x16
 3d0:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <uxTopReadyPriority>
 3d4:	98 17       	cp	r25, r24
 3d6:	10 f4       	brcc	.+4      	; 0x3dc <xTaskCreate+0x1ae>
 3d8:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <uxTopReadyPriority>
 3dc:	90 e0       	ldi	r25, 0x00	; 0
 3de:	9c 01       	movw	r18, r24
 3e0:	22 0f       	add	r18, r18
 3e2:	33 1f       	adc	r19, r19
 3e4:	22 0f       	add	r18, r18
 3e6:	33 1f       	adc	r19, r19
 3e8:	22 0f       	add	r18, r18
 3ea:	33 1f       	adc	r19, r19
 3ec:	82 0f       	add	r24, r18
 3ee:	93 1f       	adc	r25, r19
 3f0:	b6 01       	movw	r22, r12
 3f2:	8a 5b       	subi	r24, 0xBA	; 186
 3f4:	9e 4f       	sbci	r25, 0xFE	; 254
 3f6:	0e 94 8d 04 	call	0x91a	; 0x91a <vListInsertEnd>
 3fa:	0f 90       	pop	r0
 3fc:	0f be       	out	0x3f, r0	; 63
 3fe:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <xSchedulerRunning>
 402:	88 23       	and	r24, r24
 404:	61 f0       	breq	.+24     	; 0x41e <__EEPROM_REGION_LENGTH__+0x1e>
 406:	e0 91 6a 01 	lds	r30, 0x016A	; 0x80016a <pxCurrentTCB>
 40a:	f0 91 6b 01 	lds	r31, 0x016B	; 0x80016b <pxCurrentTCB+0x1>
 40e:	96 89       	ldd	r25, Z+22	; 0x16
 410:	8e 89       	ldd	r24, Y+22	; 0x16
 412:	98 17       	cp	r25, r24
 414:	30 f4       	brcc	.+12     	; 0x422 <__EEPROM_REGION_LENGTH__+0x22>
 416:	0e 94 ad 05 	call	0xb5a	; 0xb5a <vPortYield>
 41a:	81 e0       	ldi	r24, 0x01	; 1
 41c:	05 c0       	rjmp	.+10     	; 0x428 <__EEPROM_REGION_LENGTH__+0x28>
 41e:	81 e0       	ldi	r24, 0x01	; 1
 420:	03 c0       	rjmp	.+6      	; 0x428 <__EEPROM_REGION_LENGTH__+0x28>
 422:	81 e0       	ldi	r24, 0x01	; 1
 424:	01 c0       	rjmp	.+2      	; 0x428 <__EEPROM_REGION_LENGTH__+0x28>
 426:	8f ef       	ldi	r24, 0xFF	; 255
 428:	df 91       	pop	r29
 42a:	cf 91       	pop	r28
 42c:	0f 91       	pop	r16
 42e:	ff 90       	pop	r15
 430:	ef 90       	pop	r14
 432:	df 90       	pop	r13
 434:	cf 90       	pop	r12
 436:	bf 90       	pop	r11
 438:	af 90       	pop	r10
 43a:	9f 90       	pop	r9
 43c:	8f 90       	pop	r8
 43e:	7f 90       	pop	r7
 440:	6f 90       	pop	r6
 442:	5f 90       	pop	r5
 444:	4f 90       	pop	r4
 446:	08 95       	ret

00000448 <vTaskStartScheduler>:
 448:	ef 92       	push	r14
 44a:	ff 92       	push	r15
 44c:	0f 93       	push	r16
 44e:	0f 2e       	mov	r0, r31
 450:	f7 e0       	ldi	r31, 0x07	; 7
 452:	ef 2e       	mov	r14, r31
 454:	f1 e0       	ldi	r31, 0x01	; 1
 456:	ff 2e       	mov	r15, r31
 458:	f0 2d       	mov	r31, r0
 45a:	00 e0       	ldi	r16, 0x00	; 0
 45c:	20 e0       	ldi	r18, 0x00	; 0
 45e:	30 e0       	ldi	r19, 0x00	; 0
 460:	45 e5       	ldi	r20, 0x55	; 85
 462:	50 e0       	ldi	r21, 0x00	; 0
 464:	60 e0       	ldi	r22, 0x00	; 0
 466:	71 e0       	ldi	r23, 0x01	; 1
 468:	82 ea       	ldi	r24, 0xA2	; 162
 46a:	93 e0       	ldi	r25, 0x03	; 3
 46c:	0e 94 17 01 	call	0x22e	; 0x22e <xTaskCreate>
 470:	81 30       	cpi	r24, 0x01	; 1
 472:	81 f4       	brne	.+32     	; 0x494 <vTaskStartScheduler+0x4c>
 474:	f8 94       	cli
 476:	8f ef       	ldi	r24, 0xFF	; 255
 478:	9f ef       	ldi	r25, 0xFF	; 255
 47a:	90 93 0a 01 	sts	0x010A, r25	; 0x80010a <xNextTaskUnblockTime+0x1>
 47e:	80 93 09 01 	sts	0x0109, r24	; 0x800109 <xNextTaskUnblockTime>
 482:	81 e0       	ldi	r24, 0x01	; 1
 484:	80 93 0f 01 	sts	0x010F, r24	; 0x80010f <xSchedulerRunning>
 488:	10 92 12 01 	sts	0x0112, r1	; 0x800112 <xTickCount+0x1>
 48c:	10 92 11 01 	sts	0x0111, r1	; 0x800111 <xTickCount>
 490:	0e 94 71 05 	call	0xae2	; 0xae2 <xPortStartScheduler>
 494:	0f 91       	pop	r16
 496:	ff 90       	pop	r15
 498:	ef 90       	pop	r14
 49a:	08 95       	ret

0000049c <vTaskSuspendAll>:
 49c:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <__data_end>
 4a0:	8f 5f       	subi	r24, 0xFF	; 255
 4a2:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <__data_end>
 4a6:	08 95       	ret

000004a8 <xTaskIncrementTick>:
 4a8:	cf 92       	push	r12
 4aa:	df 92       	push	r13
 4ac:	ef 92       	push	r14
 4ae:	ff 92       	push	r15
 4b0:	0f 93       	push	r16
 4b2:	1f 93       	push	r17
 4b4:	cf 93       	push	r28
 4b6:	df 93       	push	r29
 4b8:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <__data_end>
 4bc:	81 11       	cpse	r24, r1
 4be:	99 c0       	rjmp	.+306    	; 0x5f2 <xTaskIncrementTick+0x14a>
 4c0:	e0 90 11 01 	lds	r14, 0x0111	; 0x800111 <xTickCount>
 4c4:	f0 90 12 01 	lds	r15, 0x0112	; 0x800112 <xTickCount+0x1>
 4c8:	8f ef       	ldi	r24, 0xFF	; 255
 4ca:	e8 1a       	sub	r14, r24
 4cc:	f8 0a       	sbc	r15, r24
 4ce:	f0 92 12 01 	sts	0x0112, r15	; 0x800112 <xTickCount+0x1>
 4d2:	e0 92 11 01 	sts	0x0111, r14	; 0x800111 <xTickCount>
 4d6:	e1 14       	cp	r14, r1
 4d8:	f1 04       	cpc	r15, r1
 4da:	b9 f4       	brne	.+46     	; 0x50a <xTaskIncrementTick+0x62>
 4dc:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <pxDelayedTaskList>
 4e0:	90 91 33 01 	lds	r25, 0x0133	; 0x800133 <pxDelayedTaskList+0x1>
 4e4:	20 91 30 01 	lds	r18, 0x0130	; 0x800130 <pxOverflowDelayedTaskList>
 4e8:	30 91 31 01 	lds	r19, 0x0131	; 0x800131 <pxOverflowDelayedTaskList+0x1>
 4ec:	30 93 33 01 	sts	0x0133, r19	; 0x800133 <pxDelayedTaskList+0x1>
 4f0:	20 93 32 01 	sts	0x0132, r18	; 0x800132 <pxDelayedTaskList>
 4f4:	90 93 31 01 	sts	0x0131, r25	; 0x800131 <pxOverflowDelayedTaskList+0x1>
 4f8:	80 93 30 01 	sts	0x0130, r24	; 0x800130 <pxOverflowDelayedTaskList>
 4fc:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <xNumOfOverflows>
 500:	8f 5f       	subi	r24, 0xFF	; 255
 502:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <xNumOfOverflows>
 506:	0e 94 a0 00 	call	0x140	; 0x140 <prvResetNextTaskUnblockTime>
 50a:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <xNextTaskUnblockTime>
 50e:	90 91 0a 01 	lds	r25, 0x010A	; 0x80010a <xNextTaskUnblockTime+0x1>
 512:	e8 16       	cp	r14, r24
 514:	f9 06       	cpc	r15, r25
 516:	10 f4       	brcc	.+4      	; 0x51c <xTaskIncrementTick+0x74>
 518:	d1 2c       	mov	r13, r1
 51a:	53 c0       	rjmp	.+166    	; 0x5c2 <xTaskIncrementTick+0x11a>
 51c:	d1 2c       	mov	r13, r1
 51e:	cc 24       	eor	r12, r12
 520:	c3 94       	inc	r12
 522:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxDelayedTaskList>
 526:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxDelayedTaskList+0x1>
 52a:	80 81       	ld	r24, Z
 52c:	81 11       	cpse	r24, r1
 52e:	07 c0       	rjmp	.+14     	; 0x53e <xTaskIncrementTick+0x96>
 530:	8f ef       	ldi	r24, 0xFF	; 255
 532:	9f ef       	ldi	r25, 0xFF	; 255
 534:	90 93 0a 01 	sts	0x010A, r25	; 0x80010a <xNextTaskUnblockTime+0x1>
 538:	80 93 09 01 	sts	0x0109, r24	; 0x800109 <xNextTaskUnblockTime>
 53c:	42 c0       	rjmp	.+132    	; 0x5c2 <xTaskIncrementTick+0x11a>
 53e:	e0 91 32 01 	lds	r30, 0x0132	; 0x800132 <pxDelayedTaskList>
 542:	f0 91 33 01 	lds	r31, 0x0133	; 0x800133 <pxDelayedTaskList+0x1>
 546:	05 80       	ldd	r0, Z+5	; 0x05
 548:	f6 81       	ldd	r31, Z+6	; 0x06
 54a:	e0 2d       	mov	r30, r0
 54c:	c6 81       	ldd	r28, Z+6	; 0x06
 54e:	d7 81       	ldd	r29, Z+7	; 0x07
 550:	8a 81       	ldd	r24, Y+2	; 0x02
 552:	9b 81       	ldd	r25, Y+3	; 0x03
 554:	e8 16       	cp	r14, r24
 556:	f9 06       	cpc	r15, r25
 558:	28 f4       	brcc	.+10     	; 0x564 <xTaskIncrementTick+0xbc>
 55a:	90 93 0a 01 	sts	0x010A, r25	; 0x80010a <xNextTaskUnblockTime+0x1>
 55e:	80 93 09 01 	sts	0x0109, r24	; 0x800109 <xNextTaskUnblockTime>
 562:	2f c0       	rjmp	.+94     	; 0x5c2 <xTaskIncrementTick+0x11a>
 564:	8e 01       	movw	r16, r28
 566:	0e 5f       	subi	r16, 0xFE	; 254
 568:	1f 4f       	sbci	r17, 0xFF	; 255
 56a:	c8 01       	movw	r24, r16
 56c:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
 570:	8c 89       	ldd	r24, Y+20	; 0x14
 572:	9d 89       	ldd	r25, Y+21	; 0x15
 574:	89 2b       	or	r24, r25
 576:	21 f0       	breq	.+8      	; 0x580 <xTaskIncrementTick+0xd8>
 578:	ce 01       	movw	r24, r28
 57a:	0c 96       	adiw	r24, 0x0c	; 12
 57c:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
 580:	8e 89       	ldd	r24, Y+22	; 0x16
 582:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <uxTopReadyPriority>
 586:	98 17       	cp	r25, r24
 588:	10 f4       	brcc	.+4      	; 0x58e <xTaskIncrementTick+0xe6>
 58a:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <uxTopReadyPriority>
 58e:	90 e0       	ldi	r25, 0x00	; 0
 590:	9c 01       	movw	r18, r24
 592:	22 0f       	add	r18, r18
 594:	33 1f       	adc	r19, r19
 596:	22 0f       	add	r18, r18
 598:	33 1f       	adc	r19, r19
 59a:	22 0f       	add	r18, r18
 59c:	33 1f       	adc	r19, r19
 59e:	82 0f       	add	r24, r18
 5a0:	93 1f       	adc	r25, r19
 5a2:	b8 01       	movw	r22, r16
 5a4:	8a 5b       	subi	r24, 0xBA	; 186
 5a6:	9e 4f       	sbci	r25, 0xFE	; 254
 5a8:	0e 94 8d 04 	call	0x91a	; 0x91a <vListInsertEnd>
 5ac:	e0 91 6a 01 	lds	r30, 0x016A	; 0x80016a <pxCurrentTCB>
 5b0:	f0 91 6b 01 	lds	r31, 0x016B	; 0x80016b <pxCurrentTCB+0x1>
 5b4:	9e 89       	ldd	r25, Y+22	; 0x16
 5b6:	86 89       	ldd	r24, Z+22	; 0x16
 5b8:	98 17       	cp	r25, r24
 5ba:	08 f4       	brcc	.+2      	; 0x5be <xTaskIncrementTick+0x116>
 5bc:	b2 cf       	rjmp	.-156    	; 0x522 <xTaskIncrementTick+0x7a>
 5be:	dc 2c       	mov	r13, r12
 5c0:	b0 cf       	rjmp	.-160    	; 0x522 <xTaskIncrementTick+0x7a>
 5c2:	e0 91 6a 01 	lds	r30, 0x016A	; 0x80016a <pxCurrentTCB>
 5c6:	f0 91 6b 01 	lds	r31, 0x016B	; 0x80016b <pxCurrentTCB+0x1>
 5ca:	86 89       	ldd	r24, Z+22	; 0x16
 5cc:	90 e0       	ldi	r25, 0x00	; 0
 5ce:	fc 01       	movw	r30, r24
 5d0:	ee 0f       	add	r30, r30
 5d2:	ff 1f       	adc	r31, r31
 5d4:	ee 0f       	add	r30, r30
 5d6:	ff 1f       	adc	r31, r31
 5d8:	ee 0f       	add	r30, r30
 5da:	ff 1f       	adc	r31, r31
 5dc:	8e 0f       	add	r24, r30
 5de:	9f 1f       	adc	r25, r31
 5e0:	fc 01       	movw	r30, r24
 5e2:	ea 5b       	subi	r30, 0xBA	; 186
 5e4:	fe 4f       	sbci	r31, 0xFE	; 254
 5e6:	80 81       	ld	r24, Z
 5e8:	82 30       	cpi	r24, 0x02	; 2
 5ea:	48 f0       	brcs	.+18     	; 0x5fe <xTaskIncrementTick+0x156>
 5ec:	dd 24       	eor	r13, r13
 5ee:	d3 94       	inc	r13
 5f0:	06 c0       	rjmp	.+12     	; 0x5fe <xTaskIncrementTick+0x156>
 5f2:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <uxPendedTicks>
 5f6:	8f 5f       	subi	r24, 0xFF	; 255
 5f8:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <uxPendedTicks>
 5fc:	d1 2c       	mov	r13, r1
 5fe:	80 91 0d 01 	lds	r24, 0x010D	; 0x80010d <xYieldPending>
 602:	88 23       	and	r24, r24
 604:	11 f0       	breq	.+4      	; 0x60a <xTaskIncrementTick+0x162>
 606:	dd 24       	eor	r13, r13
 608:	d3 94       	inc	r13
 60a:	8d 2d       	mov	r24, r13
 60c:	df 91       	pop	r29
 60e:	cf 91       	pop	r28
 610:	1f 91       	pop	r17
 612:	0f 91       	pop	r16
 614:	ff 90       	pop	r15
 616:	ef 90       	pop	r14
 618:	df 90       	pop	r13
 61a:	cf 90       	pop	r12
 61c:	08 95       	ret

0000061e <xTaskResumeAll>:
 61e:	df 92       	push	r13
 620:	ef 92       	push	r14
 622:	ff 92       	push	r15
 624:	0f 93       	push	r16
 626:	1f 93       	push	r17
 628:	cf 93       	push	r28
 62a:	df 93       	push	r29
 62c:	0f b6       	in	r0, 0x3f	; 63
 62e:	f8 94       	cli
 630:	0f 92       	push	r0
 632:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <__data_end>
 636:	81 50       	subi	r24, 0x01	; 1
 638:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <__data_end>
 63c:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <__data_end>
 640:	81 11       	cpse	r24, r1
 642:	5f c0       	rjmp	.+190    	; 0x702 <xTaskResumeAll+0xe4>
 644:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <uxCurrentNumberOfTasks>
 648:	81 11       	cpse	r24, r1
 64a:	33 c0       	rjmp	.+102    	; 0x6b2 <xTaskResumeAll+0x94>
 64c:	5d c0       	rjmp	.+186    	; 0x708 <xTaskResumeAll+0xea>
 64e:	d7 01       	movw	r26, r14
 650:	15 96       	adiw	r26, 0x05	; 5
 652:	ed 91       	ld	r30, X+
 654:	fc 91       	ld	r31, X
 656:	16 97       	sbiw	r26, 0x06	; 6
 658:	c6 81       	ldd	r28, Z+6	; 0x06
 65a:	d7 81       	ldd	r29, Z+7	; 0x07
 65c:	ce 01       	movw	r24, r28
 65e:	0c 96       	adiw	r24, 0x0c	; 12
 660:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
 664:	8e 01       	movw	r16, r28
 666:	0e 5f       	subi	r16, 0xFE	; 254
 668:	1f 4f       	sbci	r17, 0xFF	; 255
 66a:	c8 01       	movw	r24, r16
 66c:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
 670:	8e 89       	ldd	r24, Y+22	; 0x16
 672:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <uxTopReadyPriority>
 676:	98 17       	cp	r25, r24
 678:	10 f4       	brcc	.+4      	; 0x67e <xTaskResumeAll+0x60>
 67a:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <uxTopReadyPriority>
 67e:	90 e0       	ldi	r25, 0x00	; 0
 680:	9c 01       	movw	r18, r24
 682:	22 0f       	add	r18, r18
 684:	33 1f       	adc	r19, r19
 686:	22 0f       	add	r18, r18
 688:	33 1f       	adc	r19, r19
 68a:	22 0f       	add	r18, r18
 68c:	33 1f       	adc	r19, r19
 68e:	82 0f       	add	r24, r18
 690:	93 1f       	adc	r25, r19
 692:	b8 01       	movw	r22, r16
 694:	8a 5b       	subi	r24, 0xBA	; 186
 696:	9e 4f       	sbci	r25, 0xFE	; 254
 698:	0e 94 8d 04 	call	0x91a	; 0x91a <vListInsertEnd>
 69c:	e0 91 6a 01 	lds	r30, 0x016A	; 0x80016a <pxCurrentTCB>
 6a0:	f0 91 6b 01 	lds	r31, 0x016B	; 0x80016b <pxCurrentTCB+0x1>
 6a4:	9e 89       	ldd	r25, Y+22	; 0x16
 6a6:	86 89       	ldd	r24, Z+22	; 0x16
 6a8:	98 17       	cp	r25, r24
 6aa:	68 f0       	brcs	.+26     	; 0x6c6 <xTaskResumeAll+0xa8>
 6ac:	d0 92 0d 01 	sts	0x010D, r13	; 0x80010d <xYieldPending>
 6b0:	0a c0       	rjmp	.+20     	; 0x6c6 <xTaskResumeAll+0xa8>
 6b2:	c0 e0       	ldi	r28, 0x00	; 0
 6b4:	d0 e0       	ldi	r29, 0x00	; 0
 6b6:	0f 2e       	mov	r0, r31
 6b8:	f7 e2       	ldi	r31, 0x27	; 39
 6ba:	ef 2e       	mov	r14, r31
 6bc:	f1 e0       	ldi	r31, 0x01	; 1
 6be:	ff 2e       	mov	r15, r31
 6c0:	f0 2d       	mov	r31, r0
 6c2:	dd 24       	eor	r13, r13
 6c4:	d3 94       	inc	r13
 6c6:	f7 01       	movw	r30, r14
 6c8:	80 81       	ld	r24, Z
 6ca:	81 11       	cpse	r24, r1
 6cc:	c0 cf       	rjmp	.-128    	; 0x64e <xTaskResumeAll+0x30>
 6ce:	cd 2b       	or	r28, r29
 6d0:	11 f0       	breq	.+4      	; 0x6d6 <xTaskResumeAll+0xb8>
 6d2:	0e 94 a0 00 	call	0x140	; 0x140 <prvResetNextTaskUnblockTime>
 6d6:	c0 91 0e 01 	lds	r28, 0x010E	; 0x80010e <uxPendedTicks>
 6da:	cc 23       	and	r28, r28
 6dc:	51 f0       	breq	.+20     	; 0x6f2 <xTaskResumeAll+0xd4>
 6de:	d1 e0       	ldi	r29, 0x01	; 1
 6e0:	0e 94 54 02 	call	0x4a8	; 0x4a8 <xTaskIncrementTick>
 6e4:	81 11       	cpse	r24, r1
 6e6:	d0 93 0d 01 	sts	0x010D, r29	; 0x80010d <xYieldPending>
 6ea:	c1 50       	subi	r28, 0x01	; 1
 6ec:	c9 f7       	brne	.-14     	; 0x6e0 <xTaskResumeAll+0xc2>
 6ee:	10 92 0e 01 	sts	0x010E, r1	; 0x80010e <uxPendedTicks>
 6f2:	80 91 0d 01 	lds	r24, 0x010D	; 0x80010d <xYieldPending>
 6f6:	88 23       	and	r24, r24
 6f8:	31 f0       	breq	.+12     	; 0x706 <xTaskResumeAll+0xe8>
 6fa:	0e 94 ad 05 	call	0xb5a	; 0xb5a <vPortYield>
 6fe:	81 e0       	ldi	r24, 0x01	; 1
 700:	03 c0       	rjmp	.+6      	; 0x708 <xTaskResumeAll+0xea>
 702:	80 e0       	ldi	r24, 0x00	; 0
 704:	01 c0       	rjmp	.+2      	; 0x708 <xTaskResumeAll+0xea>
 706:	80 e0       	ldi	r24, 0x00	; 0
 708:	0f 90       	pop	r0
 70a:	0f be       	out	0x3f, r0	; 63
 70c:	df 91       	pop	r29
 70e:	cf 91       	pop	r28
 710:	1f 91       	pop	r17
 712:	0f 91       	pop	r16
 714:	ff 90       	pop	r15
 716:	ef 90       	pop	r14
 718:	df 90       	pop	r13
 71a:	08 95       	ret

0000071c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 71c:	cf 93       	push	r28
 71e:	df 93       	push	r29
 720:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 722:	89 2b       	or	r24, r25
 724:	51 f0       	breq	.+20     	; 0x73a <vTaskDelay+0x1e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
 726:	0e 94 4e 02 	call	0x49c	; 0x49c <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 72a:	60 e0       	ldi	r22, 0x00	; 0
 72c:	ce 01       	movw	r24, r28
 72e:	0e 94 bf 00 	call	0x17e	; 0x17e <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 732:	0e 94 0f 03 	call	0x61e	; 0x61e <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 736:	81 11       	cpse	r24, r1
 738:	02 c0       	rjmp	.+4      	; 0x73e <vTaskDelay+0x22>
		{
			portYIELD_WITHIN_API();
 73a:	0e 94 ad 05 	call	0xb5a	; 0xb5a <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 73e:	df 91       	pop	r29
 740:	cf 91       	pop	r28
 742:	08 95       	ret

00000744 <prvIdleTask>:
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 744:	0e e1       	ldi	r16, 0x1E	; 30
 746:	11 e0       	ldi	r17, 0x01	; 1

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 748:	0f 2e       	mov	r0, r31
 74a:	f6 e4       	ldi	r31, 0x46	; 70
 74c:	ef 2e       	mov	r14, r31
 74e:	f1 e0       	ldi	r31, 0x01	; 1
 750:	ff 2e       	mov	r15, r31
 752:	f0 2d       	mov	r31, r0
 754:	29 c0       	rjmp	.+82     	; 0x7a8 <prvIdleTask+0x64>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
 756:	0e 94 4e 02 	call	0x49c	; 0x49c <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 75a:	d8 01       	movw	r26, r16
 75c:	cc 91       	ld	r28, X
			}
			( void ) xTaskResumeAll();
 75e:	0e 94 0f 03 	call	0x61e	; 0x61e <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 762:	cc 23       	and	r28, r28
 764:	09 f1       	breq	.+66     	; 0x7a8 <prvIdleTask+0x64>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
 766:	0f b6       	in	r0, 0x3f	; 63
 768:	f8 94       	cli
 76a:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 76c:	d8 01       	movw	r26, r16
 76e:	15 96       	adiw	r26, 0x05	; 5
 770:	ed 91       	ld	r30, X+
 772:	fc 91       	ld	r31, X
 774:	16 97       	sbiw	r26, 0x06	; 6
 776:	c6 81       	ldd	r28, Z+6	; 0x06
 778:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 77a:	ce 01       	movw	r24, r28
 77c:	02 96       	adiw	r24, 0x02	; 2
 77e:	0e 94 df 04 	call	0x9be	; 0x9be <uxListRemove>
					--uxCurrentNumberOfTasks;
 782:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <uxCurrentNumberOfTasks>
 786:	81 50       	subi	r24, 0x01	; 1
 788:	80 93 13 01 	sts	0x0113, r24	; 0x800113 <uxCurrentNumberOfTasks>
					--uxDeletedTasksWaitingCleanUp;
 78c:	80 91 1d 01 	lds	r24, 0x011D	; 0x80011d <uxDeletedTasksWaitingCleanUp>
 790:	81 50       	subi	r24, 0x01	; 1
 792:	80 93 1d 01 	sts	0x011D, r24	; 0x80011d <uxDeletedTasksWaitingCleanUp>
				}
				taskEXIT_CRITICAL();
 796:	0f 90       	pop	r0
 798:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
 79a:	8f 89       	ldd	r24, Y+23	; 0x17
 79c:	98 8d       	ldd	r25, Y+24	; 0x18
 79e:	0e 94 7a 04 	call	0x8f4	; 0x8f4 <vPortFree>
			vPortFree( pxTCB );
 7a2:	ce 01       	movw	r24, r28
 7a4:	0e 94 7a 04 	call	0x8f4	; 0x8f4 <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 7a8:	80 91 1d 01 	lds	r24, 0x011D	; 0x80011d <uxDeletedTasksWaitingCleanUp>
 7ac:	81 11       	cpse	r24, r1
 7ae:	d3 cf       	rjmp	.-90     	; 0x756 <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 7b0:	f7 01       	movw	r30, r14
 7b2:	80 81       	ld	r24, Z
 7b4:	82 30       	cpi	r24, 0x02	; 2
 7b6:	c0 f3       	brcs	.-16     	; 0x7a8 <prvIdleTask+0x64>
			{
				taskYIELD();
 7b8:	0e 94 ad 05 	call	0xb5a	; 0xb5a <vPortYield>
 7bc:	f5 cf       	rjmp	.-22     	; 0x7a8 <prvIdleTask+0x64>

000007be <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 7be:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <__data_end>
 7c2:	88 23       	and	r24, r24
 7c4:	21 f0       	breq	.+8      	; 0x7ce <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 7c6:	81 e0       	ldi	r24, 0x01	; 1
 7c8:	80 93 0d 01 	sts	0x010D, r24	; 0x80010d <xYieldPending>
 7cc:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 7ce:	10 92 0d 01 	sts	0x010D, r1	; 0x80010d <xYieldPending>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 7d2:	20 91 10 01 	lds	r18, 0x0110	; 0x800110 <uxTopReadyPriority>
 7d6:	82 2f       	mov	r24, r18
 7d8:	90 e0       	ldi	r25, 0x00	; 0
 7da:	fc 01       	movw	r30, r24
 7dc:	ee 0f       	add	r30, r30
 7de:	ff 1f       	adc	r31, r31
 7e0:	ee 0f       	add	r30, r30
 7e2:	ff 1f       	adc	r31, r31
 7e4:	ee 0f       	add	r30, r30
 7e6:	ff 1f       	adc	r31, r31
 7e8:	e8 0f       	add	r30, r24
 7ea:	f9 1f       	adc	r31, r25
 7ec:	ea 5b       	subi	r30, 0xBA	; 186
 7ee:	fe 4f       	sbci	r31, 0xFE	; 254
 7f0:	30 81       	ld	r19, Z
 7f2:	31 11       	cpse	r19, r1
 7f4:	11 c0       	rjmp	.+34     	; 0x818 <__DATA_REGION_LENGTH__+0x18>
 7f6:	21 50       	subi	r18, 0x01	; 1
 7f8:	82 2f       	mov	r24, r18
 7fa:	90 e0       	ldi	r25, 0x00	; 0
 7fc:	fc 01       	movw	r30, r24
 7fe:	ee 0f       	add	r30, r30
 800:	ff 1f       	adc	r31, r31
 802:	ee 0f       	add	r30, r30
 804:	ff 1f       	adc	r31, r31
 806:	ee 0f       	add	r30, r30
 808:	ff 1f       	adc	r31, r31
 80a:	e8 0f       	add	r30, r24
 80c:	f9 1f       	adc	r31, r25
 80e:	ea 5b       	subi	r30, 0xBA	; 186
 810:	fe 4f       	sbci	r31, 0xFE	; 254
 812:	30 81       	ld	r19, Z
 814:	33 23       	and	r19, r19
 816:	79 f3       	breq	.-34     	; 0x7f6 <vTaskSwitchContext+0x38>
 818:	ac 01       	movw	r20, r24
 81a:	44 0f       	add	r20, r20
 81c:	55 1f       	adc	r21, r21
 81e:	44 0f       	add	r20, r20
 820:	55 1f       	adc	r21, r21
 822:	44 0f       	add	r20, r20
 824:	55 1f       	adc	r21, r21
 826:	48 0f       	add	r20, r24
 828:	59 1f       	adc	r21, r25
 82a:	da 01       	movw	r26, r20
 82c:	aa 5b       	subi	r26, 0xBA	; 186
 82e:	be 4f       	sbci	r27, 0xFE	; 254
 830:	11 96       	adiw	r26, 0x01	; 1
 832:	ed 91       	ld	r30, X+
 834:	fc 91       	ld	r31, X
 836:	12 97       	sbiw	r26, 0x02	; 2
 838:	02 80       	ldd	r0, Z+2	; 0x02
 83a:	f3 81       	ldd	r31, Z+3	; 0x03
 83c:	e0 2d       	mov	r30, r0
 83e:	12 96       	adiw	r26, 0x02	; 2
 840:	fc 93       	st	X, r31
 842:	ee 93       	st	-X, r30
 844:	11 97       	sbiw	r26, 0x01	; 1
 846:	47 5b       	subi	r20, 0xB7	; 183
 848:	5e 4f       	sbci	r21, 0xFE	; 254
 84a:	e4 17       	cp	r30, r20
 84c:	f5 07       	cpc	r31, r21
 84e:	29 f4       	brne	.+10     	; 0x85a <__DATA_REGION_LENGTH__+0x5a>
 850:	42 81       	ldd	r20, Z+2	; 0x02
 852:	53 81       	ldd	r21, Z+3	; 0x03
 854:	fd 01       	movw	r30, r26
 856:	52 83       	std	Z+2, r21	; 0x02
 858:	41 83       	std	Z+1, r20	; 0x01
 85a:	fc 01       	movw	r30, r24
 85c:	ee 0f       	add	r30, r30
 85e:	ff 1f       	adc	r31, r31
 860:	ee 0f       	add	r30, r30
 862:	ff 1f       	adc	r31, r31
 864:	ee 0f       	add	r30, r30
 866:	ff 1f       	adc	r31, r31
 868:	8e 0f       	add	r24, r30
 86a:	9f 1f       	adc	r25, r31
 86c:	fc 01       	movw	r30, r24
 86e:	ea 5b       	subi	r30, 0xBA	; 186
 870:	fe 4f       	sbci	r31, 0xFE	; 254
 872:	01 80       	ldd	r0, Z+1	; 0x01
 874:	f2 81       	ldd	r31, Z+2	; 0x02
 876:	e0 2d       	mov	r30, r0
 878:	86 81       	ldd	r24, Z+6	; 0x06
 87a:	97 81       	ldd	r25, Z+7	; 0x07
 87c:	90 93 6b 01 	sts	0x016B, r25	; 0x80016b <pxCurrentTCB+0x1>
 880:	80 93 6a 01 	sts	0x016A, r24	; 0x80016a <pxCurrentTCB>
 884:	20 93 10 01 	sts	0x0110, r18	; 0x800110 <uxTopReadyPriority>
 888:	08 95       	ret

0000088a <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 88a:	cf 93       	push	r28
 88c:	df 93       	push	r29
 88e:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
 890:	0e 94 4e 02 	call	0x49c	; 0x49c <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
 894:	80 91 6c 01 	lds	r24, 0x016C	; 0x80016c <pucAlignedHeap.2068>
 898:	90 91 6d 01 	lds	r25, 0x016D	; 0x80016d <pucAlignedHeap.2068+0x1>
 89c:	89 2b       	or	r24, r25
 89e:	31 f4       	brne	.+12     	; 0x8ac <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
 8a0:	81 e7       	ldi	r24, 0x71	; 113
 8a2:	91 e0       	ldi	r25, 0x01	; 1
 8a4:	90 93 6d 01 	sts	0x016D, r25	; 0x80016d <pucAlignedHeap.2068+0x1>
 8a8:	80 93 6c 01 	sts	0x016C, r24	; 0x80016c <pucAlignedHeap.2068>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
 8ac:	20 91 6e 01 	lds	r18, 0x016E	; 0x80016e <xNextFreeByte>
 8b0:	30 91 6f 01 	lds	r19, 0x016F	; 0x80016f <xNextFreeByte+0x1>
 8b4:	c9 01       	movw	r24, r18
 8b6:	8c 0f       	add	r24, r28
 8b8:	9d 1f       	adc	r25, r29
 8ba:	8b 3d       	cpi	r24, 0xDB	; 219
 8bc:	45 e0       	ldi	r20, 0x05	; 5
 8be:	94 07       	cpc	r25, r20
 8c0:	70 f4       	brcc	.+28     	; 0x8de <pvPortMalloc+0x54>
 8c2:	28 17       	cp	r18, r24
 8c4:	39 07       	cpc	r19, r25
 8c6:	70 f4       	brcc	.+28     	; 0x8e4 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
 8c8:	c0 91 6c 01 	lds	r28, 0x016C	; 0x80016c <pucAlignedHeap.2068>
 8cc:	d0 91 6d 01 	lds	r29, 0x016D	; 0x80016d <pucAlignedHeap.2068+0x1>
 8d0:	c2 0f       	add	r28, r18
 8d2:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
 8d4:	90 93 6f 01 	sts	0x016F, r25	; 0x80016f <xNextFreeByte+0x1>
 8d8:	80 93 6e 01 	sts	0x016E, r24	; 0x80016e <xNextFreeByte>
 8dc:	05 c0       	rjmp	.+10     	; 0x8e8 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
 8de:	c0 e0       	ldi	r28, 0x00	; 0
 8e0:	d0 e0       	ldi	r29, 0x00	; 0
 8e2:	02 c0       	rjmp	.+4      	; 0x8e8 <pvPortMalloc+0x5e>
 8e4:	c0 e0       	ldi	r28, 0x00	; 0
 8e6:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 8e8:	0e 94 0f 03 	call	0x61e	; 0x61e <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 8ec:	ce 01       	movw	r24, r28
 8ee:	df 91       	pop	r29
 8f0:	cf 91       	pop	r28
 8f2:	08 95       	ret

000008f4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 8f4:	08 95       	ret

000008f6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 8f6:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8f8:	03 96       	adiw	r24, 0x03	; 3
 8fa:	92 83       	std	Z+2, r25	; 0x02
 8fc:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 8fe:	2f ef       	ldi	r18, 0xFF	; 255
 900:	3f ef       	ldi	r19, 0xFF	; 255
 902:	34 83       	std	Z+4, r19	; 0x04
 904:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 906:	96 83       	std	Z+6, r25	; 0x06
 908:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 90a:	90 87       	std	Z+8, r25	; 0x08
 90c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 90e:	10 82       	st	Z, r1
 910:	08 95       	ret

00000912 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 912:	fc 01       	movw	r30, r24
 914:	11 86       	std	Z+9, r1	; 0x09
 916:	10 86       	std	Z+8, r1	; 0x08
 918:	08 95       	ret

0000091a <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 91a:	cf 93       	push	r28
 91c:	df 93       	push	r29
 91e:	9c 01       	movw	r18, r24
 920:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 922:	dc 01       	movw	r26, r24
 924:	11 96       	adiw	r26, 0x01	; 1
 926:	cd 91       	ld	r28, X+
 928:	dc 91       	ld	r29, X
 92a:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 92c:	d3 83       	std	Z+3, r29	; 0x03
 92e:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 930:	8c 81       	ldd	r24, Y+4	; 0x04
 932:	9d 81       	ldd	r25, Y+5	; 0x05
 934:	95 83       	std	Z+5, r25	; 0x05
 936:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 938:	8c 81       	ldd	r24, Y+4	; 0x04
 93a:	9d 81       	ldd	r25, Y+5	; 0x05
 93c:	dc 01       	movw	r26, r24
 93e:	13 96       	adiw	r26, 0x03	; 3
 940:	7c 93       	st	X, r23
 942:	6e 93       	st	-X, r22
 944:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
 946:	7d 83       	std	Y+5, r23	; 0x05
 948:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 94a:	31 87       	std	Z+9, r19	; 0x09
 94c:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
 94e:	f9 01       	movw	r30, r18
 950:	80 81       	ld	r24, Z
 952:	8f 5f       	subi	r24, 0xFF	; 255
 954:	80 83       	st	Z, r24
}
 956:	df 91       	pop	r29
 958:	cf 91       	pop	r28
 95a:	08 95       	ret

0000095c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 95c:	cf 93       	push	r28
 95e:	df 93       	push	r29
 960:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 962:	48 81       	ld	r20, Y
 964:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 966:	4f 3f       	cpi	r20, 0xFF	; 255
 968:	2f ef       	ldi	r18, 0xFF	; 255
 96a:	52 07       	cpc	r21, r18
 96c:	21 f4       	brne	.+8      	; 0x976 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 96e:	fc 01       	movw	r30, r24
 970:	a7 81       	ldd	r26, Z+7	; 0x07
 972:	b0 85       	ldd	r27, Z+8	; 0x08
 974:	0d c0       	rjmp	.+26     	; 0x990 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 976:	dc 01       	movw	r26, r24
 978:	13 96       	adiw	r26, 0x03	; 3
 97a:	01 c0       	rjmp	.+2      	; 0x97e <vListInsert+0x22>
 97c:	df 01       	movw	r26, r30
 97e:	12 96       	adiw	r26, 0x02	; 2
 980:	ed 91       	ld	r30, X+
 982:	fc 91       	ld	r31, X
 984:	13 97       	sbiw	r26, 0x03	; 3
 986:	20 81       	ld	r18, Z
 988:	31 81       	ldd	r19, Z+1	; 0x01
 98a:	42 17       	cp	r20, r18
 98c:	53 07       	cpc	r21, r19
 98e:	b0 f7       	brcc	.-20     	; 0x97c <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 990:	12 96       	adiw	r26, 0x02	; 2
 992:	ed 91       	ld	r30, X+
 994:	fc 91       	ld	r31, X
 996:	13 97       	sbiw	r26, 0x03	; 3
 998:	fb 83       	std	Y+3, r31	; 0x03
 99a:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 99c:	d5 83       	std	Z+5, r29	; 0x05
 99e:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
 9a0:	bd 83       	std	Y+5, r27	; 0x05
 9a2:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
 9a4:	13 96       	adiw	r26, 0x03	; 3
 9a6:	dc 93       	st	X, r29
 9a8:	ce 93       	st	-X, r28
 9aa:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 9ac:	99 87       	std	Y+9, r25	; 0x09
 9ae:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 9b0:	fc 01       	movw	r30, r24
 9b2:	20 81       	ld	r18, Z
 9b4:	2f 5f       	subi	r18, 0xFF	; 255
 9b6:	20 83       	st	Z, r18
}
 9b8:	df 91       	pop	r29
 9ba:	cf 91       	pop	r28
 9bc:	08 95       	ret

000009be <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 9be:	cf 93       	push	r28
 9c0:	df 93       	push	r29
 9c2:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 9c4:	a0 85       	ldd	r26, Z+8	; 0x08
 9c6:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 9c8:	c2 81       	ldd	r28, Z+2	; 0x02
 9ca:	d3 81       	ldd	r29, Z+3	; 0x03
 9cc:	84 81       	ldd	r24, Z+4	; 0x04
 9ce:	95 81       	ldd	r25, Z+5	; 0x05
 9d0:	9d 83       	std	Y+5, r25	; 0x05
 9d2:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 9d4:	c4 81       	ldd	r28, Z+4	; 0x04
 9d6:	d5 81       	ldd	r29, Z+5	; 0x05
 9d8:	82 81       	ldd	r24, Z+2	; 0x02
 9da:	93 81       	ldd	r25, Z+3	; 0x03
 9dc:	9b 83       	std	Y+3, r25	; 0x03
 9de:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 9e0:	11 96       	adiw	r26, 0x01	; 1
 9e2:	8d 91       	ld	r24, X+
 9e4:	9c 91       	ld	r25, X
 9e6:	12 97       	sbiw	r26, 0x02	; 2
 9e8:	e8 17       	cp	r30, r24
 9ea:	f9 07       	cpc	r31, r25
 9ec:	31 f4       	brne	.+12     	; 0x9fa <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 9ee:	84 81       	ldd	r24, Z+4	; 0x04
 9f0:	95 81       	ldd	r25, Z+5	; 0x05
 9f2:	12 96       	adiw	r26, 0x02	; 2
 9f4:	9c 93       	st	X, r25
 9f6:	8e 93       	st	-X, r24
 9f8:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 9fa:	11 86       	std	Z+9, r1	; 0x09
 9fc:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 9fe:	8c 91       	ld	r24, X
 a00:	81 50       	subi	r24, 0x01	; 1
 a02:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
 a04:	df 91       	pop	r29
 a06:	cf 91       	pop	r28
 a08:	08 95       	ret

00000a0a <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 a0a:	31 e1       	ldi	r19, 0x11	; 17
 a0c:	fc 01       	movw	r30, r24
 a0e:	30 83       	st	Z, r19
 a10:	31 97       	sbiw	r30, 0x01	; 1
 a12:	22 e2       	ldi	r18, 0x22	; 34
 a14:	20 83       	st	Z, r18
 a16:	31 97       	sbiw	r30, 0x01	; 1
 a18:	a3 e3       	ldi	r26, 0x33	; 51
 a1a:	a0 83       	st	Z, r26
 a1c:	31 97       	sbiw	r30, 0x01	; 1
 a1e:	60 83       	st	Z, r22
 a20:	31 97       	sbiw	r30, 0x01	; 1
 a22:	70 83       	st	Z, r23
 a24:	31 97       	sbiw	r30, 0x01	; 1
 a26:	10 82       	st	Z, r1
 a28:	31 97       	sbiw	r30, 0x01	; 1
 a2a:	60 e8       	ldi	r22, 0x80	; 128
 a2c:	60 83       	st	Z, r22
 a2e:	31 97       	sbiw	r30, 0x01	; 1
 a30:	10 82       	st	Z, r1
 a32:	31 97       	sbiw	r30, 0x01	; 1
 a34:	62 e0       	ldi	r22, 0x02	; 2
 a36:	60 83       	st	Z, r22
 a38:	31 97       	sbiw	r30, 0x01	; 1
 a3a:	63 e0       	ldi	r22, 0x03	; 3
 a3c:	60 83       	st	Z, r22
 a3e:	31 97       	sbiw	r30, 0x01	; 1
 a40:	64 e0       	ldi	r22, 0x04	; 4
 a42:	60 83       	st	Z, r22
 a44:	31 97       	sbiw	r30, 0x01	; 1
 a46:	65 e0       	ldi	r22, 0x05	; 5
 a48:	60 83       	st	Z, r22
 a4a:	31 97       	sbiw	r30, 0x01	; 1
 a4c:	66 e0       	ldi	r22, 0x06	; 6
 a4e:	60 83       	st	Z, r22
 a50:	31 97       	sbiw	r30, 0x01	; 1
 a52:	67 e0       	ldi	r22, 0x07	; 7
 a54:	60 83       	st	Z, r22
 a56:	31 97       	sbiw	r30, 0x01	; 1
 a58:	68 e0       	ldi	r22, 0x08	; 8
 a5a:	60 83       	st	Z, r22
 a5c:	31 97       	sbiw	r30, 0x01	; 1
 a5e:	69 e0       	ldi	r22, 0x09	; 9
 a60:	60 83       	st	Z, r22
 a62:	31 97       	sbiw	r30, 0x01	; 1
 a64:	60 e1       	ldi	r22, 0x10	; 16
 a66:	60 83       	st	Z, r22
 a68:	31 97       	sbiw	r30, 0x01	; 1
 a6a:	30 83       	st	Z, r19
 a6c:	31 97       	sbiw	r30, 0x01	; 1
 a6e:	32 e1       	ldi	r19, 0x12	; 18
 a70:	30 83       	st	Z, r19
 a72:	31 97       	sbiw	r30, 0x01	; 1
 a74:	33 e1       	ldi	r19, 0x13	; 19
 a76:	30 83       	st	Z, r19
 a78:	31 97       	sbiw	r30, 0x01	; 1
 a7a:	34 e1       	ldi	r19, 0x14	; 20
 a7c:	30 83       	st	Z, r19
 a7e:	31 97       	sbiw	r30, 0x01	; 1
 a80:	35 e1       	ldi	r19, 0x15	; 21
 a82:	30 83       	st	Z, r19
 a84:	31 97       	sbiw	r30, 0x01	; 1
 a86:	36 e1       	ldi	r19, 0x16	; 22
 a88:	30 83       	st	Z, r19
 a8a:	31 97       	sbiw	r30, 0x01	; 1
 a8c:	37 e1       	ldi	r19, 0x17	; 23
 a8e:	30 83       	st	Z, r19
 a90:	31 97       	sbiw	r30, 0x01	; 1
 a92:	38 e1       	ldi	r19, 0x18	; 24
 a94:	30 83       	st	Z, r19
 a96:	31 97       	sbiw	r30, 0x01	; 1
 a98:	39 e1       	ldi	r19, 0x19	; 25
 a9a:	30 83       	st	Z, r19
 a9c:	31 97       	sbiw	r30, 0x01	; 1
 a9e:	30 e2       	ldi	r19, 0x20	; 32
 aa0:	30 83       	st	Z, r19
 aa2:	31 97       	sbiw	r30, 0x01	; 1
 aa4:	31 e2       	ldi	r19, 0x21	; 33
 aa6:	30 83       	st	Z, r19
 aa8:	31 97       	sbiw	r30, 0x01	; 1
 aaa:	20 83       	st	Z, r18
 aac:	31 97       	sbiw	r30, 0x01	; 1
 aae:	23 e2       	ldi	r18, 0x23	; 35
 ab0:	20 83       	st	Z, r18
 ab2:	31 97       	sbiw	r30, 0x01	; 1
 ab4:	40 83       	st	Z, r20
 ab6:	31 97       	sbiw	r30, 0x01	; 1
 ab8:	50 83       	st	Z, r21
 aba:	31 97       	sbiw	r30, 0x01	; 1
 abc:	26 e2       	ldi	r18, 0x26	; 38
 abe:	20 83       	st	Z, r18
 ac0:	31 97       	sbiw	r30, 0x01	; 1
 ac2:	27 e2       	ldi	r18, 0x27	; 39
 ac4:	20 83       	st	Z, r18
 ac6:	31 97       	sbiw	r30, 0x01	; 1
 ac8:	28 e2       	ldi	r18, 0x28	; 40
 aca:	20 83       	st	Z, r18
 acc:	31 97       	sbiw	r30, 0x01	; 1
 ace:	29 e2       	ldi	r18, 0x29	; 41
 ad0:	20 83       	st	Z, r18
 ad2:	31 97       	sbiw	r30, 0x01	; 1
 ad4:	20 e3       	ldi	r18, 0x30	; 48
 ad6:	20 83       	st	Z, r18
 ad8:	31 97       	sbiw	r30, 0x01	; 1
 ada:	21 e3       	ldi	r18, 0x31	; 49
 adc:	20 83       	st	Z, r18
 ade:	86 97       	sbiw	r24, 0x26	; 38
 ae0:	08 95       	ret

00000ae2 <xPortStartScheduler>:
 ae2:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
 ae6:	89 ef       	ldi	r24, 0xF9	; 249
 ae8:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
 aec:	e1 e8       	ldi	r30, 0x81	; 129
 aee:	f0 e0       	ldi	r31, 0x00	; 0
 af0:	80 81       	ld	r24, Z
 af2:	8b 60       	ori	r24, 0x0B	; 11
 af4:	80 83       	st	Z, r24
 af6:	ef e6       	ldi	r30, 0x6F	; 111
 af8:	f0 e0       	ldi	r31, 0x00	; 0
 afa:	80 81       	ld	r24, Z
 afc:	82 60       	ori	r24, 0x02	; 2
 afe:	80 83       	st	Z, r24
 b00:	a0 91 6a 01 	lds	r26, 0x016A	; 0x80016a <pxCurrentTCB>
 b04:	b0 91 6b 01 	lds	r27, 0x016B	; 0x80016b <pxCurrentTCB+0x1>
 b08:	cd 91       	ld	r28, X+
 b0a:	cd bf       	out	0x3d, r28	; 61
 b0c:	dd 91       	ld	r29, X+
 b0e:	de bf       	out	0x3e, r29	; 62
 b10:	ff 91       	pop	r31
 b12:	ef 91       	pop	r30
 b14:	df 91       	pop	r29
 b16:	cf 91       	pop	r28
 b18:	bf 91       	pop	r27
 b1a:	af 91       	pop	r26
 b1c:	9f 91       	pop	r25
 b1e:	8f 91       	pop	r24
 b20:	7f 91       	pop	r23
 b22:	6f 91       	pop	r22
 b24:	5f 91       	pop	r21
 b26:	4f 91       	pop	r20
 b28:	3f 91       	pop	r19
 b2a:	2f 91       	pop	r18
 b2c:	1f 91       	pop	r17
 b2e:	0f 91       	pop	r16
 b30:	ff 90       	pop	r15
 b32:	ef 90       	pop	r14
 b34:	df 90       	pop	r13
 b36:	cf 90       	pop	r12
 b38:	bf 90       	pop	r11
 b3a:	af 90       	pop	r10
 b3c:	9f 90       	pop	r9
 b3e:	8f 90       	pop	r8
 b40:	7f 90       	pop	r7
 b42:	6f 90       	pop	r6
 b44:	5f 90       	pop	r5
 b46:	4f 90       	pop	r4
 b48:	3f 90       	pop	r3
 b4a:	2f 90       	pop	r2
 b4c:	1f 90       	pop	r1
 b4e:	0f 90       	pop	r0
 b50:	0f be       	out	0x3f, r0	; 63
 b52:	0f 90       	pop	r0
 b54:	08 95       	ret
 b56:	81 e0       	ldi	r24, 0x01	; 1
 b58:	08 95       	ret

00000b5a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 b5a:	0f 92       	push	r0
 b5c:	0f b6       	in	r0, 0x3f	; 63
 b5e:	f8 94       	cli
 b60:	0f 92       	push	r0
 b62:	1f 92       	push	r1
 b64:	11 24       	eor	r1, r1
 b66:	2f 92       	push	r2
 b68:	3f 92       	push	r3
 b6a:	4f 92       	push	r4
 b6c:	5f 92       	push	r5
 b6e:	6f 92       	push	r6
 b70:	7f 92       	push	r7
 b72:	8f 92       	push	r8
 b74:	9f 92       	push	r9
 b76:	af 92       	push	r10
 b78:	bf 92       	push	r11
 b7a:	cf 92       	push	r12
 b7c:	df 92       	push	r13
 b7e:	ef 92       	push	r14
 b80:	ff 92       	push	r15
 b82:	0f 93       	push	r16
 b84:	1f 93       	push	r17
 b86:	2f 93       	push	r18
 b88:	3f 93       	push	r19
 b8a:	4f 93       	push	r20
 b8c:	5f 93       	push	r21
 b8e:	6f 93       	push	r22
 b90:	7f 93       	push	r23
 b92:	8f 93       	push	r24
 b94:	9f 93       	push	r25
 b96:	af 93       	push	r26
 b98:	bf 93       	push	r27
 b9a:	cf 93       	push	r28
 b9c:	df 93       	push	r29
 b9e:	ef 93       	push	r30
 ba0:	ff 93       	push	r31
 ba2:	a0 91 6a 01 	lds	r26, 0x016A	; 0x80016a <pxCurrentTCB>
 ba6:	b0 91 6b 01 	lds	r27, 0x016B	; 0x80016b <pxCurrentTCB+0x1>
 baa:	0d b6       	in	r0, 0x3d	; 61
 bac:	0d 92       	st	X+, r0
 bae:	0e b6       	in	r0, 0x3e	; 62
 bb0:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 bb2:	0e 94 df 03 	call	0x7be	; 0x7be <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 bb6:	a0 91 6a 01 	lds	r26, 0x016A	; 0x80016a <pxCurrentTCB>
 bba:	b0 91 6b 01 	lds	r27, 0x016B	; 0x80016b <pxCurrentTCB+0x1>
 bbe:	cd 91       	ld	r28, X+
 bc0:	cd bf       	out	0x3d, r28	; 61
 bc2:	dd 91       	ld	r29, X+
 bc4:	de bf       	out	0x3e, r29	; 62
 bc6:	ff 91       	pop	r31
 bc8:	ef 91       	pop	r30
 bca:	df 91       	pop	r29
 bcc:	cf 91       	pop	r28
 bce:	bf 91       	pop	r27
 bd0:	af 91       	pop	r26
 bd2:	9f 91       	pop	r25
 bd4:	8f 91       	pop	r24
 bd6:	7f 91       	pop	r23
 bd8:	6f 91       	pop	r22
 bda:	5f 91       	pop	r21
 bdc:	4f 91       	pop	r20
 bde:	3f 91       	pop	r19
 be0:	2f 91       	pop	r18
 be2:	1f 91       	pop	r17
 be4:	0f 91       	pop	r16
 be6:	ff 90       	pop	r15
 be8:	ef 90       	pop	r14
 bea:	df 90       	pop	r13
 bec:	cf 90       	pop	r12
 bee:	bf 90       	pop	r11
 bf0:	af 90       	pop	r10
 bf2:	9f 90       	pop	r9
 bf4:	8f 90       	pop	r8
 bf6:	7f 90       	pop	r7
 bf8:	6f 90       	pop	r6
 bfa:	5f 90       	pop	r5
 bfc:	4f 90       	pop	r4
 bfe:	3f 90       	pop	r3
 c00:	2f 90       	pop	r2
 c02:	1f 90       	pop	r1
 c04:	0f 90       	pop	r0
 c06:	0f be       	out	0x3f, r0	; 63
 c08:	0f 90       	pop	r0

	asm volatile ( "ret" );
 c0a:	08 95       	ret

00000c0c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 c0c:	0f 92       	push	r0
 c0e:	0f b6       	in	r0, 0x3f	; 63
 c10:	f8 94       	cli
 c12:	0f 92       	push	r0
 c14:	1f 92       	push	r1
 c16:	11 24       	eor	r1, r1
 c18:	2f 92       	push	r2
 c1a:	3f 92       	push	r3
 c1c:	4f 92       	push	r4
 c1e:	5f 92       	push	r5
 c20:	6f 92       	push	r6
 c22:	7f 92       	push	r7
 c24:	8f 92       	push	r8
 c26:	9f 92       	push	r9
 c28:	af 92       	push	r10
 c2a:	bf 92       	push	r11
 c2c:	cf 92       	push	r12
 c2e:	df 92       	push	r13
 c30:	ef 92       	push	r14
 c32:	ff 92       	push	r15
 c34:	0f 93       	push	r16
 c36:	1f 93       	push	r17
 c38:	2f 93       	push	r18
 c3a:	3f 93       	push	r19
 c3c:	4f 93       	push	r20
 c3e:	5f 93       	push	r21
 c40:	6f 93       	push	r22
 c42:	7f 93       	push	r23
 c44:	8f 93       	push	r24
 c46:	9f 93       	push	r25
 c48:	af 93       	push	r26
 c4a:	bf 93       	push	r27
 c4c:	cf 93       	push	r28
 c4e:	df 93       	push	r29
 c50:	ef 93       	push	r30
 c52:	ff 93       	push	r31
 c54:	a0 91 6a 01 	lds	r26, 0x016A	; 0x80016a <pxCurrentTCB>
 c58:	b0 91 6b 01 	lds	r27, 0x016B	; 0x80016b <pxCurrentTCB+0x1>
 c5c:	0d b6       	in	r0, 0x3d	; 61
 c5e:	0d 92       	st	X+, r0
 c60:	0e b6       	in	r0, 0x3e	; 62
 c62:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 c64:	0e 94 54 02 	call	0x4a8	; 0x4a8 <xTaskIncrementTick>
 c68:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 c6a:	0e 94 df 03 	call	0x7be	; 0x7be <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
 c6e:	a0 91 6a 01 	lds	r26, 0x016A	; 0x80016a <pxCurrentTCB>
 c72:	b0 91 6b 01 	lds	r27, 0x016B	; 0x80016b <pxCurrentTCB+0x1>
 c76:	cd 91       	ld	r28, X+
 c78:	cd bf       	out	0x3d, r28	; 61
 c7a:	dd 91       	ld	r29, X+
 c7c:	de bf       	out	0x3e, r29	; 62
 c7e:	ff 91       	pop	r31
 c80:	ef 91       	pop	r30
 c82:	df 91       	pop	r29
 c84:	cf 91       	pop	r28
 c86:	bf 91       	pop	r27
 c88:	af 91       	pop	r26
 c8a:	9f 91       	pop	r25
 c8c:	8f 91       	pop	r24
 c8e:	7f 91       	pop	r23
 c90:	6f 91       	pop	r22
 c92:	5f 91       	pop	r21
 c94:	4f 91       	pop	r20
 c96:	3f 91       	pop	r19
 c98:	2f 91       	pop	r18
 c9a:	1f 91       	pop	r17
 c9c:	0f 91       	pop	r16
 c9e:	ff 90       	pop	r15
 ca0:	ef 90       	pop	r14
 ca2:	df 90       	pop	r13
 ca4:	cf 90       	pop	r12
 ca6:	bf 90       	pop	r11
 ca8:	af 90       	pop	r10
 caa:	9f 90       	pop	r9
 cac:	8f 90       	pop	r8
 cae:	7f 90       	pop	r7
 cb0:	6f 90       	pop	r6
 cb2:	5f 90       	pop	r5
 cb4:	4f 90       	pop	r4
 cb6:	3f 90       	pop	r3
 cb8:	2f 90       	pop	r2
 cba:	1f 90       	pop	r1
 cbc:	0f 90       	pop	r0
 cbe:	0f be       	out	0x3f, r0	; 63
 cc0:	0f 90       	pop	r0

	asm volatile ( "ret" );
 cc2:	08 95       	ret

00000cc4 <__vector_11>:
	
	
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
 cc4:	0e 94 06 06 	call	0xc0c	; 0xc0c <vPortYieldFromTick>
		asm volatile ( "reti" );
 cc8:	18 95       	reti

00000cca <_exit>:
 cca:	f8 94       	cli

00000ccc <__stop_program>:
 ccc:	ff cf       	rjmp	.-2      	; 0xccc <__stop_program>
