
Watering.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000de  00800100  00003cf2  00003d86  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003cf2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006e7  008001de  008001de  00003e64  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003e64  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00003e94  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005e0  00000000  00000000  00003ed8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000129fb  00000000  00000000  000044b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000031d8  00000000  00000000  00016eb3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00004dde  00000000  00000000  0001a08b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000013c4  00000000  00000000  0001ee6c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00005520  00000000  00000000  00020230  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007fba  00000000  00000000  00025750  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000006b0  00000000  00000000  0002d70a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 36 00 	jmp	0x6c	; 0x6c <__ctors_end>
       4:	0c 94 5e 00 	jmp	0xbc	; 0xbc <__bad_interrupt>
       8:	0c 94 5e 00 	jmp	0xbc	; 0xbc <__bad_interrupt>
       c:	0c 94 5e 00 	jmp	0xbc	; 0xbc <__bad_interrupt>
      10:	0c 94 5e 00 	jmp	0xbc	; 0xbc <__bad_interrupt>
      14:	0c 94 5e 00 	jmp	0xbc	; 0xbc <__bad_interrupt>
      18:	0c 94 5e 00 	jmp	0xbc	; 0xbc <__bad_interrupt>
      1c:	0c 94 5e 00 	jmp	0xbc	; 0xbc <__bad_interrupt>
      20:	0c 94 5e 00 	jmp	0xbc	; 0xbc <__bad_interrupt>
      24:	0c 94 5e 00 	jmp	0xbc	; 0xbc <__bad_interrupt>
      28:	0c 94 5e 00 	jmp	0xbc	; 0xbc <__bad_interrupt>
      2c:	0c 94 71 16 	jmp	0x2ce2	; 0x2ce2 <__vector_11>
      30:	0c 94 5e 00 	jmp	0xbc	; 0xbc <__bad_interrupt>
      34:	0c 94 5e 00 	jmp	0xbc	; 0xbc <__bad_interrupt>
      38:	0c 94 5e 00 	jmp	0xbc	; 0xbc <__bad_interrupt>
      3c:	0c 94 5e 00 	jmp	0xbc	; 0xbc <__bad_interrupt>
      40:	0c 94 3c 01 	jmp	0x278	; 0x278 <__vector_16>
      44:	0c 94 5e 00 	jmp	0xbc	; 0xbc <__bad_interrupt>
      48:	0c 94 d9 17 	jmp	0x2fb2	; 0x2fb2 <__vector_18>
      4c:	0c 94 11 18 	jmp	0x3022	; 0x3022 <__vector_19>
      50:	0c 94 5e 00 	jmp	0xbc	; 0xbc <__bad_interrupt>
      54:	0c 94 5e 00 	jmp	0xbc	; 0xbc <__bad_interrupt>
      58:	0c 94 5e 00 	jmp	0xbc	; 0xbc <__bad_interrupt>
      5c:	0c 94 5e 00 	jmp	0xbc	; 0xbc <__bad_interrupt>
      60:	0c 94 5e 00 	jmp	0xbc	; 0xbc <__bad_interrupt>
      64:	0c 94 5e 00 	jmp	0xbc	; 0xbc <__bad_interrupt>

00000068 <__ctors_start>:
      68:	07 01       	movw	r0, r14
      6a:	55 18       	sub	r5, r5

0000006c <__ctors_end>:
      6c:	11 24       	eor	r1, r1
      6e:	1f be       	out	0x3f, r1	; 63
      70:	cf ef       	ldi	r28, 0xFF	; 255
      72:	d8 e0       	ldi	r29, 0x08	; 8
      74:	de bf       	out	0x3e, r29	; 62
      76:	cd bf       	out	0x3d, r28	; 61

00000078 <__do_copy_data>:
      78:	11 e0       	ldi	r17, 0x01	; 1
      7a:	a0 e0       	ldi	r26, 0x00	; 0
      7c:	b1 e0       	ldi	r27, 0x01	; 1
      7e:	e2 ef       	ldi	r30, 0xF2	; 242
      80:	fc e3       	ldi	r31, 0x3C	; 60
      82:	02 c0       	rjmp	.+4      	; 0x88 <__do_copy_data+0x10>
      84:	05 90       	lpm	r0, Z+
      86:	0d 92       	st	X+, r0
      88:	ae 3d       	cpi	r26, 0xDE	; 222
      8a:	b1 07       	cpc	r27, r17
      8c:	d9 f7       	brne	.-10     	; 0x84 <__do_copy_data+0xc>

0000008e <__do_clear_bss>:
      8e:	28 e0       	ldi	r18, 0x08	; 8
      90:	ae ed       	ldi	r26, 0xDE	; 222
      92:	b1 e0       	ldi	r27, 0x01	; 1
      94:	01 c0       	rjmp	.+2      	; 0x98 <.do_clear_bss_start>

00000096 <.do_clear_bss_loop>:
      96:	1d 92       	st	X+, r1

00000098 <.do_clear_bss_start>:
      98:	a5 3c       	cpi	r26, 0xC5	; 197
      9a:	b2 07       	cpc	r27, r18
      9c:	e1 f7       	brne	.-8      	; 0x96 <.do_clear_bss_loop>

0000009e <__do_global_ctors>:
      9e:	10 e0       	ldi	r17, 0x00	; 0
      a0:	c6 e3       	ldi	r28, 0x36	; 54
      a2:	d0 e0       	ldi	r29, 0x00	; 0
      a4:	04 c0       	rjmp	.+8      	; 0xae <__do_global_ctors+0x10>
      a6:	21 97       	sbiw	r28, 0x01	; 1
      a8:	fe 01       	movw	r30, r28
      aa:	0e 94 05 1d 	call	0x3a0a	; 0x3a0a <__tablejump2__>
      ae:	c4 33       	cpi	r28, 0x34	; 52
      b0:	d1 07       	cpc	r29, r17
      b2:	c9 f7       	brne	.-14     	; 0xa6 <__do_global_ctors+0x8>
      b4:	0e 94 0e 01 	call	0x21c	; 0x21c <main>
      b8:	0c 94 77 1e 	jmp	0x3cee	; 0x3cee <_exit>

000000bc <__bad_interrupt>:
      bc:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000c0 <_Z41__static_initialization_and_destruction_0ii>:
);

Pump_t water_impl;

guarded<Settings> settings(Settings::load());
guarded<Clocks,guard_timer0> clocks;
      c0:	cf 93       	push	r28
      c2:	df 93       	push	r29
      c4:	cd b7       	in	r28, 0x3d	; 61
      c6:	de b7       	in	r29, 0x3e	; 62
      c8:	6c 97       	sbiw	r28, 0x1c	; 28
      ca:	0f b6       	in	r0, 0x3f	; 63
      cc:	f8 94       	cli
      ce:	de bf       	out	0x3e, r29	; 62
      d0:	0f be       	out	0x3f, r0	; 63
      d2:	cd bf       	out	0x3d, r28	; 61
      d4:	01 97       	sbiw	r24, 0x01	; 1
      d6:	09 f0       	breq	.+2      	; 0xda <_Z41__static_initialization_and_destruction_0ii+0x1a>
      d8:	91 c0       	rjmp	.+290    	; 0x1fc <_Z41__static_initialization_and_destruction_0ii+0x13c>
      da:	6f 3f       	cpi	r22, 0xFF	; 255
      dc:	7f 4f       	sbci	r23, 0xFF	; 255
      de:	09 f0       	breq	.+2      	; 0xe2 <_Z41__static_initialization_and_destruction_0ii+0x22>
      e0:	8d c0       	rjmp	.+282    	; 0x1fc <_Z41__static_initialization_and_destruction_0ii+0x13c>
struct guarded{
	T value;
	mutable guarg_t m;
	
	template <typename...Args>
	inline guarded(Args &&...args):value(Std::forward<Args>(args)...){}
      e2:	10 92 35 02 	sts	0x0235, r1	; 0x800235 <Temp>
      e6:	10 92 36 02 	sts	0x0236, r1	; 0x800236 <Temp+0x1>
      ea:	10 92 37 02 	sts	0x0237, r1	; 0x800237 <Temp+0x2>
      ee:	10 92 38 02 	sts	0x0238, r1	; 0x800238 <Temp+0x3>


guarded<float,atomic_guard> Temp = 0;
guarded<water_plan_array_t &> water_plan( 
	*reinterpret_cast<water_plan_array_t*>(
		calloc(sizeof(water_plan_array_t),1)
      f2:	61 e0       	ldi	r22, 0x01	; 1
      f4:	70 e0       	ldi	r23, 0x00	; 0
      f6:	88 e6       	ldi	r24, 0x68	; 104
      f8:	90 e0       	ldi	r25, 0x00	; 0
      fa:	0e 94 1a 1d 	call	0x3a34	; 0x3a34 <calloc>
      fe:	90 93 32 02 	sts	0x0232, r25	; 0x800232 <water_plan+0x1>
     102:	80 93 31 02 	sts	0x0231, r24	; 0x800231 <water_plan>
	)
);
guarded<water_every_array_t &> water_every(
	*reinterpret_cast<water_every_array_t*>(
		calloc(sizeof(water_every_array_t),1)
     106:	61 e0       	ldi	r22, 0x01	; 1
     108:	70 e0       	ldi	r23, 0x00	; 0
     10a:	88 e2       	ldi	r24, 0x28	; 40
     10c:	90 e0       	ldi	r25, 0x00	; 0
     10e:	0e 94 1a 1d 	call	0x3a34	; 0x3a34 <calloc>
     112:	90 93 2e 02 	sts	0x022E, r25	; 0x80022e <water_every+0x1>
     116:	80 93 2d 02 	sts	0x022D, r24	; 0x80022d <water_every>
#define PIN_MASK_12 0b00010000
#define PIN_MASK_13 0b00100000

inline void set_port_bit(volatile uint8_t & _port,uint8_t bit_num,uint8_t value){
	if(value){
		_port |= (1<<bit_num);
     11a:	87 b1       	in	r24, 0x07	; 7
     11c:	84 60       	ori	r24, 0x04	; 4
     11e:	87 b9       	out	0x07, r24	; 7
	} else {
		_port &= ~(1<<bit_num);
     120:	87 b1       	in	r24, 0x07	; 7
     122:	8b 7f       	andi	r24, 0xFB	; 251
     124:	87 b9       	out	0x07, r24	; 7
        Twd = 60;
        f_cpu = 16000000UL;
    }
    static Settings load(){
        Settings S;
        eeprom_read_block((void *)&S,NULL,sizeof(Settings));
     126:	4c e1       	ldi	r20, 0x1C	; 28
     128:	50 e0       	ldi	r21, 0x00	; 0
     12a:	60 e0       	ldi	r22, 0x00	; 0
     12c:	70 e0       	ldi	r23, 0x00	; 0
     12e:	ce 01       	movw	r24, r28
     130:	01 96       	adiw	r24, 0x01	; 1
     132:	0e 94 67 1e 	call	0x3cce	; 0x3cce <eeprom_read_block>
        if(S.f_cpu < 7000000UL || S.f_cpu > 20000000UL){
     136:	89 8d       	ldd	r24, Y+25	; 0x19
     138:	9a 8d       	ldd	r25, Y+26	; 0x1a
     13a:	ab 8d       	ldd	r26, Y+27	; 0x1b
     13c:	bc 8d       	ldd	r27, Y+28	; 0x1c
     13e:	80 5c       	subi	r24, 0xC0	; 192
     140:	9f 4c       	sbci	r25, 0xCF	; 207
     142:	aa 46       	sbci	r26, 0x6A	; 106
     144:	b1 09       	sbc	r27, r1
     146:	81 34       	cpi	r24, 0x41	; 65
     148:	9d 45       	sbci	r25, 0x5D	; 93
     14a:	a6 4c       	sbci	r26, 0xC6	; 198
     14c:	b1 05       	cpc	r27, r1
     14e:	80 f1       	brcs	.+96     	; 0x1b0 <_Z41__static_initialization_and_destruction_0ii+0xf0>
    //internal clock parameter
    uint_least32_t f_cpu; // actual _f_cpu in Hz

    
    void set_default(){
        T1o = 28;
     150:	40 e0       	ldi	r20, 0x00	; 0
     152:	50 e0       	ldi	r21, 0x00	; 0
     154:	60 ee       	ldi	r22, 0xE0	; 224
     156:	71 e4       	ldi	r23, 0x41	; 65
     158:	49 83       	std	Y+1, r20	; 0x01
     15a:	5a 83       	std	Y+2, r21	; 0x02
     15c:	6b 83       	std	Y+3, r22	; 0x03
     15e:	7c 83       	std	Y+4, r23	; 0x04
        T1c = 27;
     160:	80 e0       	ldi	r24, 0x00	; 0
     162:	90 e0       	ldi	r25, 0x00	; 0
     164:	a8 ed       	ldi	r26, 0xD8	; 216
     166:	b1 e4       	ldi	r27, 0x41	; 65
     168:	8d 83       	std	Y+5, r24	; 0x05
     16a:	9e 83       	std	Y+6, r25	; 0x06
     16c:	af 83       	std	Y+7, r26	; 0x07
     16e:	b8 87       	std	Y+8, r27	; 0x08
        T2o = 28;
     170:	49 87       	std	Y+9, r20	; 0x09
     172:	5a 87       	std	Y+10, r21	; 0x0a
     174:	6b 87       	std	Y+11, r22	; 0x0b
     176:	7c 87       	std	Y+12, r23	; 0x0c
        T2c = 27;
     178:	8d 87       	std	Y+13, r24	; 0x0d
     17a:	9e 87       	std	Y+14, r25	; 0x0e
     17c:	af 87       	std	Y+15, r26	; 0x0f
     17e:	b8 8b       	std	Y+16, r27	; 0x10

        Tmd = 3600.0*24;
     180:	80 e8       	ldi	r24, 0x80	; 128
     182:	91 e5       	ldi	r25, 0x51	; 81
     184:	a1 e0       	ldi	r26, 0x01	; 1
     186:	b0 e0       	ldi	r27, 0x00	; 0
     188:	89 8b       	std	Y+17, r24	; 0x11
     18a:	9a 8b       	std	Y+18, r25	; 0x12
     18c:	ab 8b       	std	Y+19, r26	; 0x13
     18e:	bc 8b       	std	Y+20, r27	; 0x14
        Twd = 60;
     190:	8c e3       	ldi	r24, 0x3C	; 60
     192:	90 e0       	ldi	r25, 0x00	; 0
     194:	a0 e0       	ldi	r26, 0x00	; 0
     196:	b0 e0       	ldi	r27, 0x00	; 0
     198:	8d 8b       	std	Y+21, r24	; 0x15
     19a:	9e 8b       	std	Y+22, r25	; 0x16
     19c:	af 8b       	std	Y+23, r26	; 0x17
     19e:	b8 8f       	std	Y+24, r27	; 0x18
        f_cpu = 16000000UL;
     1a0:	80 e0       	ldi	r24, 0x00	; 0
     1a2:	94 e2       	ldi	r25, 0x24	; 36
     1a4:	a4 ef       	ldi	r26, 0xF4	; 244
     1a6:	b0 e0       	ldi	r27, 0x00	; 0
     1a8:	89 8f       	std	Y+25, r24	; 0x19
     1aa:	9a 8f       	std	Y+26, r25	; 0x1a
     1ac:	ab 8f       	std	Y+27, r26	; 0x1b
     1ae:	bc 8f       	std	Y+28, r27	; 0x1c
     1b0:	8c e1       	ldi	r24, 0x1C	; 28
     1b2:	fe 01       	movw	r30, r28
     1b4:	31 96       	adiw	r30, 0x01	; 1
     1b6:	af e0       	ldi	r26, 0x0F	; 15
     1b8:	b2 e0       	ldi	r27, 0x02	; 2
     1ba:	01 90       	ld	r0, Z+
     1bc:	0d 92       	st	X+, r0
     1be:	8a 95       	dec	r24
     1c0:	e1 f7       	brne	.-8      	; 0x1ba <_Z41__static_initialization_and_destruction_0ii+0xfa>
    uint_least32_t days;
	
	
    hh_mm_ss_dd(){}
    hh_mm_ss_dd(int_least32_t days,uint_least8_t hh,uint_least8_t mm,uint_least8_t ss = 0):
    hh(hh),mm(mm),ss(ss),days(days){}
     1c2:	ee ed       	ldi	r30, 0xDE	; 222
     1c4:	f1 e0       	ldi	r31, 0x01	; 1
     1c6:	10 82       	st	Z, r1
     1c8:	11 82       	std	Z+1, r1	; 0x01
     1ca:	12 82       	std	Z+2, r1	; 0x02
     1cc:	13 82       	std	Z+3, r1	; 0x03
     1ce:	14 82       	std	Z+4, r1	; 0x04
     1d0:	15 82       	std	Z+5, r1	; 0x05
     1d2:	16 82       	std	Z+6, r1	; 0x06
#include <stdint.h>
#include "data_time.h"

struct Clocks : public hh_mm_ss_dd{
    inline Clocks():hh_mm_ss_dd(0,0,0,0),
    _inday_counter(0),_tacts_per_count(1),_f_cpu(1){}
     1d4:	17 82       	std	Z+7, r1	; 0x07
     1d6:	10 86       	std	Z+8, r1	; 0x08
     1d8:	11 86       	std	Z+9, r1	; 0x09
     1da:	12 86       	std	Z+10, r1	; 0x0a
     1dc:	13 86       	std	Z+11, r1	; 0x0b
     1de:	14 86       	std	Z+12, r1	; 0x0c
     1e0:	15 86       	std	Z+13, r1	; 0x0d
     1e2:	16 86       	std	Z+14, r1	; 0x0e
     1e4:	81 e0       	ldi	r24, 0x01	; 1
     1e6:	90 e0       	ldi	r25, 0x00	; 0
     1e8:	a0 e0       	ldi	r26, 0x00	; 0
     1ea:	b0 e0       	ldi	r27, 0x00	; 0
     1ec:	87 87       	std	Z+15, r24	; 0x0f
     1ee:	90 8b       	std	Z+16, r25	; 0x10
     1f0:	a1 8b       	std	Z+17, r26	; 0x11
     1f2:	b2 8b       	std	Z+18, r27	; 0x12
     1f4:	83 8b       	std	Z+19, r24	; 0x13
     1f6:	94 8b       	std	Z+20, r25	; 0x14
     1f8:	a5 8b       	std	Z+21, r26	; 0x15
     1fa:	b6 8b       	std	Z+22, r27	; 0x16
);

Pump_t water_impl;

guarded<Settings> settings(Settings::load());
guarded<Clocks,guard_timer0> clocks;
     1fc:	6c 96       	adiw	r28, 0x1c	; 28
     1fe:	0f b6       	in	r0, 0x3f	; 63
     200:	f8 94       	cli
     202:	de bf       	out	0x3e, r29	; 62
     204:	0f be       	out	0x3f, r0	; 63
     206:	cd bf       	out	0x3d, r28	; 61
     208:	df 91       	pop	r29
     20a:	cf 91       	pop	r28
     20c:	08 95       	ret

0000020e <_GLOBAL__sub_I_Temp>:
     20e:	6f ef       	ldi	r22, 0xFF	; 255
     210:	7f ef       	ldi	r23, 0xFF	; 255
     212:	81 e0       	ldi	r24, 0x01	; 1
     214:	90 e0       	ldi	r25, 0x00	; 0
     216:	0e 94 60 00 	call	0xc0	; 0xc0 <_Z41__static_initialization_and_destruction_0ii>
     21a:	08 95       	ret

0000021c <main>:
void task_window(void *);
void task_command_executor(void *);

int main(void)
{
	xTaskCreate(update_clock,"task_update",configMINIMAL_STACK_SIZE,NULL,1,NULL);
     21c:	e1 2c       	mov	r14, r1
     21e:	f1 2c       	mov	r15, r1
     220:	01 e0       	ldi	r16, 0x01	; 1
     222:	20 e0       	ldi	r18, 0x00	; 0
     224:	30 e0       	ldi	r19, 0x00	; 0
     226:	45 e5       	ldi	r20, 0x55	; 85
     228:	50 e0       	ldi	r21, 0x00	; 0
     22a:	66 e0       	ldi	r22, 0x06	; 6
     22c:	71 e0       	ldi	r23, 0x01	; 1
     22e:	8e e9       	ldi	r24, 0x9E	; 158
     230:	91 e0       	ldi	r25, 0x01	; 1
     232:	0e 94 84 10 	call	0x2108	; 0x2108 <xTaskCreate>
	xTaskCreate(task_watering, "task_watering", configMINIMAL_STACK_SIZE, NULL, 1, NULL);
     236:	20 e0       	ldi	r18, 0x00	; 0
     238:	30 e0       	ldi	r19, 0x00	; 0
     23a:	45 e5       	ldi	r20, 0x55	; 85
     23c:	50 e0       	ldi	r21, 0x00	; 0
     23e:	62 e1       	ldi	r22, 0x12	; 18
     240:	71 e0       	ldi	r23, 0x01	; 1
     242:	8f ea       	ldi	r24, 0xAF	; 175
     244:	9a e0       	ldi	r25, 0x0A	; 10
     246:	0e 94 84 10 	call	0x2108	; 0x2108 <xTaskCreate>
	xTaskCreate(task_window, "task_window", configMINIMAL_STACK_SIZE, NULL, 1, NULL);
     24a:	20 e0       	ldi	r18, 0x00	; 0
     24c:	30 e0       	ldi	r19, 0x00	; 0
     24e:	45 e5       	ldi	r20, 0x55	; 85
     250:	50 e0       	ldi	r21, 0x00	; 0
     252:	60 e2       	ldi	r22, 0x20	; 32
     254:	71 e0       	ldi	r23, 0x01	; 1
     256:	8f e3       	ldi	r24, 0x3F	; 63
     258:	9d e0       	ldi	r25, 0x0D	; 13
     25a:	0e 94 84 10 	call	0x2108	; 0x2108 <xTaskCreate>
	xTaskCreate(task_command_executor, "task_command_executor", 2*configMINIMAL_STACK_SIZE, NULL, 1, NULL);
     25e:	20 e0       	ldi	r18, 0x00	; 0
     260:	30 e0       	ldi	r19, 0x00	; 0
     262:	4a ea       	ldi	r20, 0xAA	; 170
     264:	50 e0       	ldi	r21, 0x00	; 0
     266:	6c e2       	ldi	r22, 0x2C	; 44
     268:	71 e0       	ldi	r23, 0x01	; 1
     26a:	8e e3       	ldi	r24, 0x3E	; 62
     26c:	96 e0       	ldi	r25, 0x06	; 6
     26e:	0e 94 84 10 	call	0x2108	; 0x2108 <xTaskCreate>
	
	vTaskStartScheduler();
     272:	0e 94 91 11 	call	0x2322	; 0x2322 <vTaskStartScheduler>
     276:	ff cf       	rjmp	.-2      	; 0x276 <main+0x5a>

00000278 <__vector_16>:
			days.first--;
		}			
	}
}

ISR(TIMER0_OVF_vect){
     278:	1f 92       	push	r1
     27a:	0f 92       	push	r0
     27c:	0f b6       	in	r0, 0x3f	; 63
     27e:	0f 92       	push	r0
     280:	11 24       	eor	r1, r1
     282:	2f 93       	push	r18
     284:	3f 93       	push	r19
     286:	4f 93       	push	r20
     288:	5f 93       	push	r21
     28a:	6f 93       	push	r22
     28c:	7f 93       	push	r23
     28e:	8f 93       	push	r24
     290:	9f 93       	push	r25
     292:	af 93       	push	r26
     294:	ef 93       	push	r30
     296:	ff 93       	push	r31
        _inday_counter = (m_secs*_f_cpu)/_tacts_per_count;
        update();
    }

    inline void tick(){
        ++_inday_counter;
     298:	ee ed       	ldi	r30, 0xDE	; 222
     29a:	f1 e0       	ldi	r31, 0x01	; 1
     29c:	27 81       	ldd	r18, Z+7	; 0x07
     29e:	30 85       	ldd	r19, Z+8	; 0x08
     2a0:	41 85       	ldd	r20, Z+9	; 0x09
     2a2:	52 85       	ldd	r21, Z+10	; 0x0a
     2a4:	63 85       	ldd	r22, Z+11	; 0x0b
     2a6:	74 85       	ldd	r23, Z+12	; 0x0c
     2a8:	85 85       	ldd	r24, Z+13	; 0x0d
     2aa:	96 85       	ldd	r25, Z+14	; 0x0e
     2ac:	a1 e0       	ldi	r26, 0x01	; 1
     2ae:	0e 94 e7 1c 	call	0x39ce	; 0x39ce <__adddi3_s8>
     2b2:	27 83       	std	Z+7, r18	; 0x07
     2b4:	30 87       	std	Z+8, r19	; 0x08
     2b6:	41 87       	std	Z+9, r20	; 0x09
     2b8:	52 87       	std	Z+10, r21	; 0x0a
     2ba:	63 87       	std	Z+11, r22	; 0x0b
     2bc:	74 87       	std	Z+12, r23	; 0x0c
     2be:	85 87       	std	Z+13, r24	; 0x0d
     2c0:	96 87       	std	Z+14, r25	; 0x0e
	clocks.value.tick();
     2c2:	ff 91       	pop	r31
     2c4:	ef 91       	pop	r30
     2c6:	af 91       	pop	r26
     2c8:	9f 91       	pop	r25
     2ca:	8f 91       	pop	r24
     2cc:	7f 91       	pop	r23
     2ce:	6f 91       	pop	r22
     2d0:	5f 91       	pop	r21
     2d2:	4f 91       	pop	r20
     2d4:	3f 91       	pop	r19
     2d6:	2f 91       	pop	r18
     2d8:	0f 90       	pop	r0
     2da:	0f be       	out	0x3f, r0	; 63
     2dc:	0f 90       	pop	r0
     2de:	1f 90       	pop	r1
     2e0:	18 95       	reti

000002e2 <_ZN3Std9make_pairIRmS1_EENS_4pairINS_5decayIT_E4typeES6_EEOS4_OT0_>:
		T first;
		U second;
	};
	
	template <typename T,typename U>
	pair<decay_t<T>,decay_t<T>> make_pair(T && _arg1,U && _arg2){
     2e2:	cf 93       	push	r28
     2e4:	df 93       	push	r29
     2e6:	cd b7       	in	r28, 0x3d	; 61
     2e8:	de b7       	in	r29, 0x3e	; 62
     2ea:	28 97       	sbiw	r28, 0x08	; 8
     2ec:	0f b6       	in	r0, 0x3f	; 63
     2ee:	f8 94       	cli
     2f0:	de bf       	out	0x3e, r29	; 62
     2f2:	0f be       	out	0x3f, r0	; 63
     2f4:	cd bf       	out	0x3d, r28	; 61
     2f6:	dc 01       	movw	r26, r24
     2f8:	fb 01       	movw	r30, r22
		return {forward<T>(_arg1),forward<U>(_arg2)};
     2fa:	2c 91       	ld	r18, X
     2fc:	11 96       	adiw	r26, 0x01	; 1
     2fe:	3c 91       	ld	r19, X
     300:	11 97       	sbiw	r26, 0x01	; 1
     302:	12 96       	adiw	r26, 0x02	; 2
     304:	9c 91       	ld	r25, X
     306:	12 97       	sbiw	r26, 0x02	; 2
     308:	13 96       	adiw	r26, 0x03	; 3
     30a:	8c 91       	ld	r24, X
     30c:	3a 83       	std	Y+2, r19	; 0x02
     30e:	9b 83       	std	Y+3, r25	; 0x03
     310:	8c 83       	std	Y+4, r24	; 0x04
     312:	80 81       	ld	r24, Z
     314:	41 81       	ldd	r20, Z+1	; 0x01
     316:	32 81       	ldd	r19, Z+2	; 0x02
     318:	93 81       	ldd	r25, Z+3	; 0x03
     31a:	4e 83       	std	Y+6, r20	; 0x06
     31c:	3f 83       	std	Y+7, r19	; 0x07
     31e:	3a 81       	ldd	r19, Y+2	; 0x02
     320:	4b 81       	ldd	r20, Y+3	; 0x03
     322:	5c 81       	ldd	r21, Y+4	; 0x04
     324:	68 2f       	mov	r22, r24
     326:	7e 81       	ldd	r23, Y+6	; 0x06
	}
     328:	8f 81       	ldd	r24, Y+7	; 0x07
     32a:	28 96       	adiw	r28, 0x08	; 8
     32c:	0f b6       	in	r0, 0x3f	; 63
     32e:	f8 94       	cli
     330:	de bf       	out	0x3e, r29	; 62
     332:	0f be       	out	0x3f, r0	; 63
     334:	cd bf       	out	0x3d, r28	; 61
     336:	df 91       	pop	r29
     338:	cf 91       	pop	r28
     33a:	08 95       	ret

0000033c <_Z12update_clockPv>:
	TCCR0B = (1 << CS00) | (1 << CS02); //prescalar 1024
	TIMSK0 = (1 << TOIE0);
};


void update_clock(void *){
     33c:	cf 93       	push	r28
     33e:	df 93       	push	r29
     340:	cd b7       	in	r28, 0x3d	; 61
     342:	de b7       	in	r29, 0x3e	; 62
     344:	a7 97       	sbiw	r28, 0x27	; 39
     346:	0f b6       	in	r0, 0x3f	; 63
     348:	f8 94       	cli
     34a:	de bf       	out	0x3e, r29	; 62
     34c:	0f be       	out	0x3f, r0	; 63
     34e:	cd bf       	out	0x3d, r28	; 61
	while(1){
		vTaskDelay(200);
     350:	88 ec       	ldi	r24, 0xC8	; 200
     352:	90 e0       	ldi	r25, 0x00	; 0
     354:	0e 94 fb 12 	call	0x25f6	; 0x25f6 <vTaskDelay>
struct guard_timer0{
	mutex m;
	inline guard_timer0(){}
	
	inline void lock(){
		TIMSK0 = 0;
     358:	10 92 6e 00 	sts	0x006E, r1	; 0x80006e <__TEXT_REGION_LENGTH__+0x7f806e>
#include "../../FreeRTOS/semphr.h"

struct mutex{
	SemaphoreHandle_t xMutex;
	void lock(){
		xSemaphoreTake(xMutex, portMAX_DELAY);
     35c:	0e ed       	ldi	r16, 0xDE	; 222
     35e:	11 e0       	ldi	r17, 0x01	; 1
     360:	20 e0       	ldi	r18, 0x00	; 0
     362:	4f ef       	ldi	r20, 0xFF	; 255
     364:	5f ef       	ldi	r21, 0xFF	; 255
     366:	60 e0       	ldi	r22, 0x00	; 0
     368:	70 e0       	ldi	r23, 0x00	; 0
     36a:	d8 01       	movw	r26, r16
     36c:	9f 96       	adiw	r26, 0x2f	; 47
     36e:	8d 91       	ld	r24, X+
     370:	9c 91       	ld	r25, X
     372:	d0 97       	sbiw	r26, 0x30	; 48
     374:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <xQueueGenericReceive>
		
		Std::pair<uint_least32_t,uint_least32_t> days= 
			clocks.apply([](Clocks & clk)
		{
			auto prv_day = clk.days;
     378:	f8 01       	movw	r30, r16
     37a:	83 81       	ldd	r24, Z+3	; 0x03
     37c:	94 81       	ldd	r25, Z+4	; 0x04
     37e:	a5 81       	ldd	r26, Z+5	; 0x05
     380:	b6 81       	ldd	r27, Z+6	; 0x06
     382:	89 8f       	std	Y+25, r24	; 0x19
     384:	9a 8f       	std	Y+26, r25	; 0x1a
     386:	ab 8f       	std	Y+27, r26	; 0x1b
     388:	bc 8f       	std	Y+28, r27	; 0x1c
		update();
	}
	
	
    inline void update(){
        while(_inday_counter >=  _d_counts){
     38a:	ee ed       	ldi	r30, 0xDE	; 222
     38c:	f1 e0       	ldi	r31, 0x01	; 1
     38e:	87 80       	ldd	r8, Z+7	; 0x07
     390:	90 84       	ldd	r9, Z+8	; 0x08
     392:	21 85       	ldd	r18, Z+9	; 0x09
     394:	2d 8f       	std	Y+29, r18	; 0x1d
     396:	82 85       	ldd	r24, Z+10	; 0x0a
     398:	8e 8f       	std	Y+30, r24	; 0x1e
     39a:	a3 85       	ldd	r26, Z+11	; 0x0b
     39c:	af 8f       	std	Y+31, r26	; 0x1f
     39e:	b4 85       	ldd	r27, Z+12	; 0x0c
     3a0:	b8 a3       	std	Y+32, r27	; 0x20
     3a2:	25 85       	ldd	r18, Z+13	; 0x0d
     3a4:	29 a3       	std	Y+33, r18	; 0x21
     3a6:	86 85       	ldd	r24, Z+14	; 0x0e
     3a8:	8a a3       	std	Y+34, r24	; 0x22
     3aa:	27 88       	ldd	r2, Z+23	; 0x17
     3ac:	30 8c       	ldd	r3, Z+24	; 0x18
     3ae:	41 8c       	ldd	r4, Z+25	; 0x19
     3b0:	52 8c       	ldd	r5, Z+26	; 0x1a
     3b2:	63 8c       	ldd	r6, Z+27	; 0x1b
     3b4:	74 8c       	ldd	r7, Z+28	; 0x1c
     3b6:	b5 8d       	ldd	r27, Z+29	; 0x1d
     3b8:	a6 8d       	ldd	r26, Z+30	; 0x1e
     3ba:	28 2d       	mov	r18, r8
     3bc:	39 2d       	mov	r19, r9
     3be:	4d 8d       	ldd	r20, Y+29	; 0x1d
     3c0:	5e 8d       	ldd	r21, Y+30	; 0x1e
     3c2:	6f 8d       	ldd	r22, Y+31	; 0x1f
     3c4:	78 a1       	ldd	r23, Y+32	; 0x20
     3c6:	89 a1       	ldd	r24, Y+33	; 0x21
     3c8:	9a a1       	ldd	r25, Y+34	; 0x22
     3ca:	a2 2c       	mov	r10, r2
     3cc:	b3 2c       	mov	r11, r3
     3ce:	c4 2c       	mov	r12, r4
     3d0:	d5 2c       	mov	r13, r5
     3d2:	e6 2c       	mov	r14, r6
     3d4:	f7 2c       	mov	r15, r7
     3d6:	0b 2f       	mov	r16, r27
     3d8:	1a 2f       	mov	r17, r26
     3da:	0e 94 fc 1c 	call	0x39f8	; 0x39f8 <__cmpdi2>
     3de:	b0 f0       	brcs	.+44     	; 0x40c <__EEPROM_REGION_LENGTH__+0xc>
            _inday_counter -= _d_counts;
     3e0:	0e 94 f3 1c 	call	0x39e6	; 0x39e6 <__subdi3>
     3e4:	27 83       	std	Z+7, r18	; 0x07
     3e6:	30 87       	std	Z+8, r19	; 0x08
     3e8:	41 87       	std	Z+9, r20	; 0x09
     3ea:	52 87       	std	Z+10, r21	; 0x0a
     3ec:	63 87       	std	Z+11, r22	; 0x0b
     3ee:	74 87       	std	Z+12, r23	; 0x0c
     3f0:	85 87       	std	Z+13, r24	; 0x0d
     3f2:	96 87       	std	Z+14, r25	; 0x0e
            days += 1;
     3f4:	83 81       	ldd	r24, Z+3	; 0x03
     3f6:	94 81       	ldd	r25, Z+4	; 0x04
     3f8:	a5 81       	ldd	r26, Z+5	; 0x05
     3fa:	b6 81       	ldd	r27, Z+6	; 0x06
     3fc:	01 96       	adiw	r24, 0x01	; 1
     3fe:	a1 1d       	adc	r26, r1
     400:	b1 1d       	adc	r27, r1
     402:	83 83       	std	Z+3, r24	; 0x03
     404:	94 83       	std	Z+4, r25	; 0x04
     406:	a5 83       	std	Z+5, r26	; 0x05
     408:	b6 83       	std	Z+6, r27	; 0x06
     40a:	bf cf       	rjmp	.-130    	; 0x38a <_Z12update_clockPv+0x4e>
        }
        hh = _inday_counter/_hh_counts;
     40c:	0f 2e       	mov	r0, r31
     40e:	fe ed       	ldi	r31, 0xDE	; 222
     410:	6f 2e       	mov	r6, r31
     412:	f1 e0       	ldi	r31, 0x01	; 1
     414:	7f 2e       	mov	r7, r31
     416:	f0 2d       	mov	r31, r0
     418:	d3 01       	movw	r26, r6
     41a:	5f 96       	adiw	r26, 0x1f	; 31
     41c:	4c 90       	ld	r4, X
     41e:	5f 97       	sbiw	r26, 0x1f	; 31
     420:	90 96       	adiw	r26, 0x20	; 32
     422:	3c 90       	ld	r3, X
     424:	90 97       	sbiw	r26, 0x20	; 32
     426:	91 96       	adiw	r26, 0x21	; 33
     428:	2c 90       	ld	r2, X
     42a:	91 97       	sbiw	r26, 0x21	; 33
     42c:	92 96       	adiw	r26, 0x22	; 34
     42e:	bc 91       	ld	r27, X
     430:	bb a3       	std	Y+35, r27	; 0x23
     432:	f3 01       	movw	r30, r6
     434:	f3 a1       	ldd	r31, Z+35	; 0x23
     436:	fc a3       	std	Y+36, r31	; 0x24
     438:	d3 01       	movw	r26, r6
     43a:	94 96       	adiw	r26, 0x24	; 36
     43c:	bc 91       	ld	r27, X
     43e:	bd a3       	std	Y+37, r27	; 0x25
     440:	f3 01       	movw	r30, r6
     442:	f5 a1       	ldd	r31, Z+37	; 0x25
     444:	fe a3       	std	Y+38, r31	; 0x26
     446:	d3 01       	movw	r26, r6
     448:	96 96       	adiw	r26, 0x26	; 38
     44a:	5c 90       	ld	r5, X
     44c:	a4 2c       	mov	r10, r4
     44e:	b3 2c       	mov	r11, r3
     450:	c2 2c       	mov	r12, r2
     452:	db a0       	ldd	r13, Y+35	; 0x23
     454:	ec a0       	ldd	r14, Y+36	; 0x24
     456:	fd a0       	ldd	r15, Y+37	; 0x25
     458:	0f 2f       	mov	r16, r31
     45a:	15 2d       	mov	r17, r5
     45c:	28 2d       	mov	r18, r8
     45e:	39 2d       	mov	r19, r9
     460:	4d 8d       	ldd	r20, Y+29	; 0x1d
     462:	5e 8d       	ldd	r21, Y+30	; 0x1e
     464:	6f 8d       	ldd	r22, Y+31	; 0x1f
     466:	78 a1       	ldd	r23, Y+32	; 0x20
     468:	89 a1       	ldd	r24, Y+33	; 0x21
     46a:	9a a1       	ldd	r25, Y+34	; 0x22
     46c:	0e 94 81 1c 	call	0x3902	; 0x3902 <__udivdi3>
     470:	2f a3       	std	Y+39, r18	; 0x27
     472:	f3 01       	movw	r30, r6
     474:	20 83       	st	Z, r18
        uint_least32_t _inday_minut_counter = _inday_counter%_hh_counts;
     476:	28 2d       	mov	r18, r8
     478:	39 2d       	mov	r19, r9
     47a:	4d 8d       	ldd	r20, Y+29	; 0x1d
     47c:	5e 8d       	ldd	r21, Y+30	; 0x1e
     47e:	6f 8d       	ldd	r22, Y+31	; 0x1f
     480:	78 a1       	ldd	r23, Y+32	; 0x20
     482:	89 a1       	ldd	r24, Y+33	; 0x21
     484:	9a a1       	ldd	r25, Y+34	; 0x22
     486:	0e 94 7f 1c 	call	0x38fe	; 0x38fe <__umoddi3>
     48a:	62 2f       	mov	r22, r18
     48c:	73 2f       	mov	r23, r19
     48e:	84 2f       	mov	r24, r20
     490:	95 2f       	mov	r25, r21
        if(hh >= 24)
     492:	ff a1       	ldd	r31, Y+39	; 0x27
     494:	f8 31       	cpi	r31, 0x18	; 24
     496:	18 f0       	brcs	.+6      	; 0x49e <__EEPROM_REGION_LENGTH__+0x9e>
            hh = 23;
     498:	27 e1       	ldi	r18, 0x17	; 23
     49a:	20 93 de 01 	sts	0x01DE, r18	; 0x8001de <__data_end>
        mm = _inday_minut_counter/_mm_counts;
     49e:	0e ed       	ldi	r16, 0xDE	; 222
     4a0:	11 e0       	ldi	r17, 0x01	; 1
     4a2:	d8 01       	movw	r26, r16
     4a4:	97 96       	adiw	r26, 0x27	; 39
     4a6:	2d 91       	ld	r18, X+
     4a8:	3d 91       	ld	r19, X+
     4aa:	4d 91       	ld	r20, X+
     4ac:	5c 91       	ld	r21, X
     4ae:	9a 97       	sbiw	r26, 0x2a	; 42
     4b0:	0e 94 52 1c 	call	0x38a4	; 0x38a4 <__udivmodsi4>
     4b4:	e2 2f       	mov	r30, r18
     4b6:	9b 01       	movw	r18, r22
     4b8:	ac 01       	movw	r20, r24
     4ba:	d8 01       	movw	r26, r16
     4bc:	11 96       	adiw	r26, 0x01	; 1
     4be:	ec 93       	st	X, r30
        uint_least32_t _inday_sec_counter = _inday_minut_counter%_mm_counts;
        if(mm >= 60)
     4c0:	ec 33       	cpi	r30, 0x3C	; 60
     4c2:	18 f0       	brcs	.+6      	; 0x4ca <__EEPROM_REGION_LENGTH__+0xca>
            mm = 59;
     4c4:	8b e3       	ldi	r24, 0x3B	; 59
     4c6:	80 93 df 01 	sts	0x01DF, r24	; 0x8001df <__data_end+0x1>
        ss = (_inday_sec_counter*_tacts_per_count)/_f_cpu;
     4ca:	0e ed       	ldi	r16, 0xDE	; 222
     4cc:	11 e0       	ldi	r17, 0x01	; 1
     4ce:	f8 01       	movw	r30, r16
     4d0:	67 85       	ldd	r22, Z+15	; 0x0f
     4d2:	70 89       	ldd	r23, Z+16	; 0x10
     4d4:	81 89       	ldd	r24, Z+17	; 0x11
     4d6:	92 89       	ldd	r25, Z+18	; 0x12
     4d8:	0e 94 42 1c 	call	0x3884	; 0x3884 <__mulsi3>
     4dc:	23 89       	ldd	r18, Z+19	; 0x13
     4de:	34 89       	ldd	r19, Z+20	; 0x14
     4e0:	45 89       	ldd	r20, Z+21	; 0x15
     4e2:	56 89       	ldd	r21, Z+22	; 0x16
     4e4:	0e 94 52 1c 	call	0x38a4	; 0x38a4 <__udivmodsi4>
     4e8:	d8 01       	movw	r26, r16
     4ea:	12 96       	adiw	r26, 0x02	; 2
     4ec:	2c 93       	st	X, r18
        if(ss >= 60)
     4ee:	2c 33       	cpi	r18, 0x3C	; 60
     4f0:	18 f0       	brcs	.+6      	; 0x4f8 <__EEPROM_REGION_LENGTH__+0xf8>
            ss = 59;
     4f2:	8b e3       	ldi	r24, 0x3B	; 59
     4f4:	80 93 e0 01 	sts	0x01E0, r24	; 0x8001e0 <__data_end+0x2>
			clk.update();
			auto m_day = clk.days;
     4f8:	0e ed       	ldi	r16, 0xDE	; 222
     4fa:	11 e0       	ldi	r17, 0x01	; 1
     4fc:	f8 01       	movw	r30, r16
     4fe:	83 81       	ldd	r24, Z+3	; 0x03
     500:	94 81       	ldd	r25, Z+4	; 0x04
     502:	a5 81       	ldd	r26, Z+5	; 0x05
     504:	b6 81       	ldd	r27, Z+6	; 0x06
     506:	89 8b       	std	Y+17, r24	; 0x11
     508:	9a 8b       	std	Y+18, r25	; 0x12
     50a:	ab 8b       	std	Y+19, r26	; 0x13
     50c:	bc 8b       	std	Y+20, r27	; 0x14
			return Std::make_pair(m_day,prv_day);
     50e:	be 01       	movw	r22, r28
     510:	67 5e       	subi	r22, 0xE7	; 231
     512:	7f 4f       	sbci	r23, 0xFF	; 255
     514:	ce 01       	movw	r24, r28
     516:	41 96       	adiw	r24, 0x11	; 17
     518:	0e 94 71 01 	call	0x2e2	; 0x2e2 <_ZN3Std9make_pairIRmS1_EENS_4pairINS_5decayIT_E4typeES6_EEOS4_OT0_>
     51c:	29 83       	std	Y+1, r18	; 0x01
     51e:	3a 83       	std	Y+2, r19	; 0x02
     520:	4b 83       	std	Y+3, r20	; 0x03
     522:	5c 83       	std	Y+4, r21	; 0x04
     524:	6d 83       	std	Y+5, r22	; 0x05
     526:	7e 83       	std	Y+6, r23	; 0x06
     528:	8f 83       	std	Y+7, r24	; 0x07
     52a:	98 87       	std	Y+8, r25	; 0x08
     52c:	88 e0       	ldi	r24, 0x08	; 8
     52e:	fe 01       	movw	r30, r28
     530:	31 96       	adiw	r30, 0x01	; 1
     532:	de 01       	movw	r26, r28
     534:	51 96       	adiw	r26, 0x11	; 17
     536:	01 90       	ld	r0, Z+
     538:	0d 92       	st	X+, r0
     53a:	8a 95       	dec	r24
     53c:	e1 f7       	brne	.-8      	; 0x536 <__EEPROM_REGION_LENGTH__+0x136>
	};
	void unlock(){
		xSemaphoreGive(xMutex);
     53e:	20 e0       	ldi	r18, 0x00	; 0
     540:	40 e0       	ldi	r20, 0x00	; 0
     542:	50 e0       	ldi	r21, 0x00	; 0
     544:	60 e0       	ldi	r22, 0x00	; 0
     546:	70 e0       	ldi	r23, 0x00	; 0
     548:	d8 01       	movw	r26, r16
     54a:	9f 96       	adiw	r26, 0x2f	; 47
     54c:	8d 91       	ld	r24, X+
     54e:	9c 91       	ld	r25, X
     550:	d0 97       	sbiw	r26, 0x30	; 48
     552:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <xQueueGenericSend>
		TIMSK0 = 0;
		m.lock();
	}
	inline void unlock(){
		m.unlock();
		TIMSK0 = 1<<TOIE0;
     556:	81 e0       	ldi	r24, 0x01	; 1
     558:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x7f806e>
	inline auto apply(Func_t && F){
		//static_assert(!Std::is_same_v<Std::invoke_result_t<Func_t,T &>,void>,"void function in not void spec");
		lock();
		auto result = F(value);
		unlock();
		return result;
     55c:	88 e0       	ldi	r24, 0x08	; 8
     55e:	fe 01       	movw	r30, r28
     560:	71 96       	adiw	r30, 0x11	; 17
     562:	de 01       	movw	r26, r28
     564:	19 96       	adiw	r26, 0x09	; 9
     566:	01 90       	ld	r0, Z+
     568:	0d 92       	st	X+, r0
     56a:	8a 95       	dec	r24
     56c:	e1 f7       	brne	.-8      	; 0x566 <__EEPROM_REGION_LENGTH__+0x166>
     56e:	88 e0       	ldi	r24, 0x08	; 8
     570:	fe 01       	movw	r30, r28
     572:	39 96       	adiw	r30, 0x09	; 9
     574:	de 01       	movw	r26, r28
     576:	51 96       	adiw	r26, 0x11	; 17
     578:	01 90       	ld	r0, Z+
     57a:	0d 92       	st	X+, r0
     57c:	8a 95       	dec	r24
     57e:	e1 f7       	brne	.-8      	; 0x578 <__EEPROM_REGION_LENGTH__+0x178>
		});  
		
		while( days.first > days.second){
     580:	49 88       	ldd	r4, Y+17	; 0x11
     582:	5a 88       	ldd	r5, Y+18	; 0x12
     584:	6b 88       	ldd	r6, Y+19	; 0x13
     586:	7c 88       	ldd	r7, Y+20	; 0x14
     588:	8d 89       	ldd	r24, Y+21	; 0x15
     58a:	9e 89       	ldd	r25, Y+22	; 0x16
     58c:	af 89       	ldd	r26, Y+23	; 0x17
     58e:	b8 8d       	ldd	r27, Y+24	; 0x18
     590:	84 15       	cp	r24, r4
     592:	95 05       	cpc	r25, r5
     594:	a6 05       	cpc	r26, r6
     596:	b7 05       	cpc	r27, r7
     598:	08 f0       	brcs	.+2      	; 0x59c <__EEPROM_REGION_LENGTH__+0x19c>
     59a:	da ce       	rjmp	.-588    	; 0x350 <_Z12update_clockPv+0x14>
			NextDayUpdatePlans();
     59c:	0e 94 8a 08 	call	0x1114	; 0x1114 <_Z18NextDayUpdatePlansv>
			days.first--;
     5a0:	b1 e0       	ldi	r27, 0x01	; 1
     5a2:	4b 1a       	sub	r4, r27
     5a4:	51 08       	sbc	r5, r1
     5a6:	61 08       	sbc	r6, r1
     5a8:	71 08       	sbc	r7, r1
     5aa:	49 8a       	std	Y+17, r4	; 0x11
     5ac:	5a 8a       	std	Y+18, r5	; 0x12
     5ae:	6b 8a       	std	Y+19, r6	; 0x13
     5b0:	7c 8a       	std	Y+20, r7	; 0x14
			clk.update();
			auto m_day = clk.days;
			return Std::make_pair(m_day,prv_day);
		});  
		
		while( days.first > days.second){
     5b2:	e6 cf       	rjmp	.-52     	; 0x580 <__EEPROM_REGION_LENGTH__+0x180>

000005b4 <_Z13parse_commandRN3Std11string_viewE>:
    }
    return 0;
}


Std::string_view parse_command(Std::string_view & S){
     5b4:	cf 93       	push	r28
     5b6:	df 93       	push	r29
     5b8:	fc 01       	movw	r30, r24
        void step(){
            _size--;
            _data++;
        }
        bool empty(){
            return _size == 0;
     5ba:	82 81       	ldd	r24, Z+2	; 0x02
     5bc:	93 81       	ldd	r25, Z+3	; 0x03
    using namespace StrFlt;
    while(!S.empty() && space(S.front())){
     5be:	00 97       	sbiw	r24, 0x00	; 0
     5c0:	99 f0       	breq	.+38     	; 0x5e8 <_Z13parse_commandRN3Std11string_viewE+0x34>
        }
        constexpr  char operator [](size_t i) const{
            return _data[i];
        }
        constexpr  char front() const{
            return *_data;
     5c2:	a0 81       	ld	r26, Z
     5c4:	b1 81       	ldd	r27, Z+1	; 0x01
     5c6:	2c 91       	ld	r18, X
            return c=='_';
        }
    };
    struct filter_space_t:public filter_base<filter_space_t>{
        constexpr bool operator ()(char c)const{
            return c=='\n' || c=='\t' || c=='\r' || c == ' ';
     5c8:	37 ef       	ldi	r19, 0xF7	; 247
     5ca:	32 0f       	add	r19, r18
     5cc:	32 30       	cpi	r19, 0x02	; 2
     5ce:	30 f0       	brcs	.+12     	; 0x5dc <_Z13parse_commandRN3Std11string_viewE+0x28>
     5d0:	2d 30       	cpi	r18, 0x0D	; 13
     5d2:	31 f0       	breq	.+12     	; 0x5e0 <_Z13parse_commandRN3Std11string_viewE+0x2c>
     5d4:	20 32       	cpi	r18, 0x20	; 32
     5d6:	31 f4       	brne	.+12     	; 0x5e4 <_Z13parse_commandRN3Std11string_viewE+0x30>
     5d8:	21 e0       	ldi	r18, 0x01	; 1
     5da:	07 c0       	rjmp	.+14     	; 0x5ea <_Z13parse_commandRN3Std11string_viewE+0x36>
     5dc:	21 e0       	ldi	r18, 0x01	; 1
     5de:	05 c0       	rjmp	.+10     	; 0x5ea <_Z13parse_commandRN3Std11string_viewE+0x36>
     5e0:	21 e0       	ldi	r18, 0x01	; 1
     5e2:	03 c0       	rjmp	.+6      	; 0x5ea <_Z13parse_commandRN3Std11string_viewE+0x36>
     5e4:	20 e0       	ldi	r18, 0x00	; 0
     5e6:	01 c0       	rjmp	.+2      	; 0x5ea <_Z13parse_commandRN3Std11string_viewE+0x36>
     5e8:	20 e0       	ldi	r18, 0x00	; 0
     5ea:	22 23       	and	r18, r18
     5ec:	49 f0       	breq	.+18     	; 0x600 <_Z13parse_commandRN3Std11string_viewE+0x4c>
		const char * cend()const{
			return _data+_size;
		}
		
        void step(){
            _size--;
     5ee:	01 97       	sbiw	r24, 0x01	; 1
     5f0:	93 83       	std	Z+3, r25	; 0x03
     5f2:	82 83       	std	Z+2, r24	; 0x02
            _data++;
     5f4:	80 81       	ld	r24, Z
     5f6:	91 81       	ldd	r25, Z+1	; 0x01
     5f8:	01 96       	adiw	r24, 0x01	; 1
     5fa:	91 83       	std	Z+1, r25	; 0x01
     5fc:	80 83       	st	Z, r24
     5fe:	dd cf       	rjmp	.-70     	; 0x5ba <_Z13parse_commandRN3Std11string_viewE+0x6>
        S.step();
    }
    if(!S.empty() && letter(S.front())){
     600:	00 97       	sbiw	r24, 0x00	; 0
     602:	81 f0       	breq	.+32     	; 0x624 <_Z13parse_commandRN3Std11string_viewE+0x70>
        }
        constexpr  char operator [](size_t i) const{
            return _data[i];
        }
        constexpr  char front() const{
            return *_data;
     604:	a0 81       	ld	r26, Z
     606:	b1 81       	ldd	r27, Z+1	; 0x01
     608:	3c 91       	ld	r19, X
        }
    };

    struct filter_letter_t:public filter_base<filter_letter_t>{
        constexpr bool operator ()(char c)const{
            return ((c>='a') && (c<='z')) || ((c>='A') && (c<='Z'));
     60a:	4f e9       	ldi	r20, 0x9F	; 159
     60c:	43 0f       	add	r20, r19
     60e:	4a 31       	cpi	r20, 0x1A	; 26
     610:	28 f0       	brcs	.+10     	; 0x61c <_Z13parse_commandRN3Std11string_viewE+0x68>
     612:	31 54       	subi	r19, 0x41	; 65
     614:	3a 31       	cpi	r19, 0x1A	; 26
     616:	20 f4       	brcc	.+8      	; 0x620 <_Z13parse_commandRN3Std11string_viewE+0x6c>
     618:	71 e0       	ldi	r23, 0x01	; 1
     61a:	05 c0       	rjmp	.+10     	; 0x626 <_Z13parse_commandRN3Std11string_viewE+0x72>
     61c:	71 e0       	ldi	r23, 0x01	; 1
     61e:	03 c0       	rjmp	.+6      	; 0x626 <_Z13parse_commandRN3Std11string_viewE+0x72>
     620:	72 2f       	mov	r23, r18
     622:	01 c0       	rjmp	.+2      	; 0x626 <_Z13parse_commandRN3Std11string_viewE+0x72>
     624:	72 2f       	mov	r23, r18
     626:	77 23       	and	r23, r23
     628:	91 f1       	breq	.+100    	; 0x68e <_Z13parse_commandRN3Std11string_viewE+0xda>
        constexpr string_view substr(size_t start)const{
            return string_view(_data + start,_size-start);
        }

        const char * begin()const{
            return _data;
     62a:	a0 81       	ld	r26, Z
     62c:	b1 81       	ldd	r27, Z+1	; 0x01
		const char * cend()const{
			return _data+_size;
		}
		
        void step(){
            _size--;
     62e:	01 97       	sbiw	r24, 0x01	; 1
     630:	93 83       	std	Z+3, r25	; 0x03
     632:	82 83       	std	Z+2, r24	; 0x02
            _data++;
     634:	cd 01       	movw	r24, r26
     636:	01 96       	adiw	r24, 0x01	; 1
     638:	91 83       	std	Z+1, r25	; 0x01
     63a:	80 83       	st	Z, r24
        const char * begin =  S.begin();
        size_t _size=1;
     63c:	41 e0       	ldi	r20, 0x01	; 1
     63e:	50 e0       	ldi	r21, 0x00	; 0
        }
        bool empty(){
            return _size == 0;
     640:	82 81       	ldd	r24, Z+2	; 0x02
     642:	93 81       	ldd	r25, Z+3	; 0x03
        S.step();
        while(!S.empty() && letter(S.front())){
     644:	00 97       	sbiw	r24, 0x00	; 0
     646:	81 f0       	breq	.+32     	; 0x668 <_Z13parse_commandRN3Std11string_viewE+0xb4>
        }
        constexpr  char operator [](size_t i) const{
            return _data[i];
        }
        constexpr  char front() const{
            return *_data;
     648:	c0 81       	ld	r28, Z
     64a:	d1 81       	ldd	r29, Z+1	; 0x01
     64c:	38 81       	ld	r19, Y
     64e:	6f e9       	ldi	r22, 0x9F	; 159
     650:	63 0f       	add	r22, r19
     652:	6a 31       	cpi	r22, 0x1A	; 26
     654:	28 f0       	brcs	.+10     	; 0x660 <_Z13parse_commandRN3Std11string_viewE+0xac>
     656:	31 54       	subi	r19, 0x41	; 65
     658:	3a 31       	cpi	r19, 0x1A	; 26
     65a:	20 f4       	brcc	.+8      	; 0x664 <_Z13parse_commandRN3Std11string_viewE+0xb0>
     65c:	37 2f       	mov	r19, r23
     65e:	05 c0       	rjmp	.+10     	; 0x66a <_Z13parse_commandRN3Std11string_viewE+0xb6>
     660:	37 2f       	mov	r19, r23
     662:	03 c0       	rjmp	.+6      	; 0x66a <_Z13parse_commandRN3Std11string_viewE+0xb6>
     664:	32 2f       	mov	r19, r18
     666:	01 c0       	rjmp	.+2      	; 0x66a <_Z13parse_commandRN3Std11string_viewE+0xb6>
     668:	32 2f       	mov	r19, r18
     66a:	33 23       	and	r19, r19
     66c:	59 f0       	breq	.+22     	; 0x684 <_Z13parse_commandRN3Std11string_viewE+0xd0>
		const char * cend()const{
			return _data+_size;
		}
		
        void step(){
            _size--;
     66e:	01 97       	sbiw	r24, 0x01	; 1
     670:	93 83       	std	Z+3, r25	; 0x03
     672:	82 83       	std	Z+2, r24	; 0x02
            _data++;
     674:	80 81       	ld	r24, Z
     676:	91 81       	ldd	r25, Z+1	; 0x01
     678:	01 96       	adiw	r24, 0x01	; 1
     67a:	91 83       	std	Z+1, r25	; 0x01
     67c:	80 83       	st	Z, r24
            S.step();
            _size++;
     67e:	4f 5f       	subi	r20, 0xFF	; 255
     680:	5f 4f       	sbci	r21, 0xFF	; 255
    }
    if(!S.empty() && letter(S.front())){
        const char * begin =  S.begin();
        size_t _size=1;
        S.step();
        while(!S.empty() && letter(S.front())){
     682:	de cf       	rjmp	.-68     	; 0x640 <_Z13parse_commandRN3Std11string_viewE+0x8c>
        constexpr string_view(const char * _data = NULL):
            _data(_data), _size(_data != NULL ? strlen(_data) : 0)
        {
        }
        constexpr string_view(const char * _data,size_t _size):
            _data(_data), _size(_size)
     684:	6a 2f       	mov	r22, r26
     686:	7b 2f       	mov	r23, r27
     688:	84 2f       	mov	r24, r20
     68a:	95 2f       	mov	r25, r21
     68c:	04 c0       	rjmp	.+8      	; 0x696 <_Z13parse_commandRN3Std11string_viewE+0xe2>
            S.step();
            _size++;
        }
        return Std::string_view(begin,_size);
    } 
    return {};
     68e:	60 e0       	ldi	r22, 0x00	; 0
     690:	70 e0       	ldi	r23, 0x00	; 0
     692:	80 e0       	ldi	r24, 0x00	; 0
     694:	90 e0       	ldi	r25, 0x00	; 0
}
     696:	df 91       	pop	r29
     698:	cf 91       	pop	r28
     69a:	08 95       	ret

0000069c <_Z14parse_variableRN3Std11string_viewE>:

Std::string_view parse_variable(Std::string_view & S){
     69c:	cf 93       	push	r28
     69e:	df 93       	push	r29
     6a0:	fc 01       	movw	r30, r24
        void step(){
            _size--;
            _data++;
        }
        bool empty(){
            return _size == 0;
     6a2:	82 81       	ldd	r24, Z+2	; 0x02
     6a4:	93 81       	ldd	r25, Z+3	; 0x03
    using namespace StrFlt;
    while(!S.empty() && space(S.front())){
     6a6:	00 97       	sbiw	r24, 0x00	; 0
     6a8:	99 f0       	breq	.+38     	; 0x6d0 <_Z14parse_variableRN3Std11string_viewE+0x34>
        }
        constexpr  char operator [](size_t i) const{
            return _data[i];
        }
        constexpr  char front() const{
            return *_data;
     6aa:	a0 81       	ld	r26, Z
     6ac:	b1 81       	ldd	r27, Z+1	; 0x01
     6ae:	2c 91       	ld	r18, X
            return c=='_';
        }
    };
    struct filter_space_t:public filter_base<filter_space_t>{
        constexpr bool operator ()(char c)const{
            return c=='\n' || c=='\t' || c=='\r' || c == ' ';
     6b0:	37 ef       	ldi	r19, 0xF7	; 247
     6b2:	32 0f       	add	r19, r18
     6b4:	32 30       	cpi	r19, 0x02	; 2
     6b6:	30 f0       	brcs	.+12     	; 0x6c4 <_Z14parse_variableRN3Std11string_viewE+0x28>
     6b8:	2d 30       	cpi	r18, 0x0D	; 13
     6ba:	31 f0       	breq	.+12     	; 0x6c8 <_Z14parse_variableRN3Std11string_viewE+0x2c>
     6bc:	20 32       	cpi	r18, 0x20	; 32
     6be:	31 f4       	brne	.+12     	; 0x6cc <_Z14parse_variableRN3Std11string_viewE+0x30>
     6c0:	21 e0       	ldi	r18, 0x01	; 1
     6c2:	07 c0       	rjmp	.+14     	; 0x6d2 <_Z14parse_variableRN3Std11string_viewE+0x36>
     6c4:	21 e0       	ldi	r18, 0x01	; 1
     6c6:	05 c0       	rjmp	.+10     	; 0x6d2 <_Z14parse_variableRN3Std11string_viewE+0x36>
     6c8:	21 e0       	ldi	r18, 0x01	; 1
     6ca:	03 c0       	rjmp	.+6      	; 0x6d2 <_Z14parse_variableRN3Std11string_viewE+0x36>
     6cc:	20 e0       	ldi	r18, 0x00	; 0
     6ce:	01 c0       	rjmp	.+2      	; 0x6d2 <_Z14parse_variableRN3Std11string_viewE+0x36>
     6d0:	20 e0       	ldi	r18, 0x00	; 0
     6d2:	22 23       	and	r18, r18
     6d4:	49 f0       	breq	.+18     	; 0x6e8 <_Z14parse_variableRN3Std11string_viewE+0x4c>
		const char * cend()const{
			return _data+_size;
		}
		
        void step(){
            _size--;
     6d6:	01 97       	sbiw	r24, 0x01	; 1
     6d8:	93 83       	std	Z+3, r25	; 0x03
     6da:	82 83       	std	Z+2, r24	; 0x02
            _data++;
     6dc:	80 81       	ld	r24, Z
     6de:	91 81       	ldd	r25, Z+1	; 0x01
     6e0:	01 96       	adiw	r24, 0x01	; 1
     6e2:	91 83       	std	Z+1, r25	; 0x01
     6e4:	80 83       	st	Z, r24
     6e6:	dd cf       	rjmp	.-70     	; 0x6a2 <_Z14parse_variableRN3Std11string_viewE+0x6>
        S.step();
    }
    if(!S.empty() && variable_begin(S.front())){
     6e8:	00 97       	sbiw	r24, 0x00	; 0
     6ea:	b1 f0       	breq	.+44     	; 0x718 <_Z14parse_variableRN3Std11string_viewE+0x7c>
        }
        constexpr  char operator [](size_t i) const{
            return _data[i];
        }
        constexpr  char front() const{
            return *_data;
     6ec:	a0 81       	ld	r26, Z
     6ee:	b1 81       	ldd	r27, Z+1	; 0x01
     6f0:	3c 91       	ld	r19, X
        }
    };

    struct filter_letter_t:public filter_base<filter_letter_t>{
        constexpr bool operator ()(char c)const{
            return ((c>='a') && (c<='z')) || ((c>='A') && (c<='Z'));
     6f2:	4f e9       	ldi	r20, 0x9F	; 159
     6f4:	43 0f       	add	r20, r19
     6f6:	4a 31       	cpi	r20, 0x1A	; 26
     6f8:	30 f0       	brcs	.+12     	; 0x706 <_Z14parse_variableRN3Std11string_viewE+0x6a>
     6fa:	4f eb       	ldi	r20, 0xBF	; 191
     6fc:	43 0f       	add	r20, r19
     6fe:	4a 31       	cpi	r20, 0x1A	; 26
     700:	20 f4       	brcc	.+8      	; 0x70a <_Z14parse_variableRN3Std11string_viewE+0x6e>
     702:	71 e0       	ldi	r23, 0x01	; 1
     704:	03 c0       	rjmp	.+6      	; 0x70c <_Z14parse_variableRN3Std11string_viewE+0x70>
     706:	71 e0       	ldi	r23, 0x01	; 1
     708:	01 c0       	rjmp	.+2      	; 0x70c <_Z14parse_variableRN3Std11string_viewE+0x70>
     70a:	72 2f       	mov	r23, r18
        Filter1 _F1;
        Filter2 _F2;
        constexpr filter_or(Filter1  const & _F1, Filter2  _F2):
            _F1(_F1),_F2(_F2){}
        constexpr bool operator ()(char c)const{
            return _F1(c) || _F2(c);
     70c:	71 11       	cpse	r23, r1
     70e:	05 c0       	rjmp	.+10     	; 0x71a <_Z14parse_variableRN3Std11string_viewE+0x7e>
     710:	3f 35       	cpi	r19, 0x5F	; 95
     712:	19 f4       	brne	.+6      	; 0x71a <_Z14parse_variableRN3Std11string_viewE+0x7e>
     714:	71 e0       	ldi	r23, 0x01	; 1
     716:	01 c0       	rjmp	.+2      	; 0x71a <_Z14parse_variableRN3Std11string_viewE+0x7e>
     718:	72 2f       	mov	r23, r18
     71a:	77 23       	and	r23, r23
     71c:	f1 f1       	breq	.+124    	; 0x79a <_Z14parse_variableRN3Std11string_viewE+0xfe>
        constexpr string_view substr(size_t start)const{
            return string_view(_data + start,_size-start);
        }

        const char * begin()const{
            return _data;
     71e:	a0 81       	ld	r26, Z
     720:	b1 81       	ldd	r27, Z+1	; 0x01
		const char * cend()const{
			return _data+_size;
		}
		
        void step(){
            _size--;
     722:	01 97       	sbiw	r24, 0x01	; 1
     724:	93 83       	std	Z+3, r25	; 0x03
     726:	82 83       	std	Z+2, r24	; 0x02
            _data++;
     728:	cd 01       	movw	r24, r26
     72a:	01 96       	adiw	r24, 0x01	; 1
     72c:	91 83       	std	Z+1, r25	; 0x01
     72e:	80 83       	st	Z, r24
        const char * begin =  S.begin();
        size_t _size=1;
     730:	41 e0       	ldi	r20, 0x01	; 1
     732:	50 e0       	ldi	r21, 0x00	; 0
        }
        bool empty(){
            return _size == 0;
     734:	82 81       	ldd	r24, Z+2	; 0x02
     736:	93 81       	ldd	r25, Z+3	; 0x03
        S.step();
        while(!S.empty() && variable(S.front())){
     738:	00 97       	sbiw	r24, 0x00	; 0
     73a:	e1 f0       	breq	.+56     	; 0x774 <_Z14parse_variableRN3Std11string_viewE+0xd8>
        }
        constexpr  char operator [](size_t i) const{
            return _data[i];
        }
        constexpr  char front() const{
            return *_data;
     73c:	c0 81       	ld	r28, Z
     73e:	d1 81       	ldd	r29, Z+1	; 0x01
     740:	68 81       	ld	r22, Y
        }
    };

    struct filter_letter_t:public filter_base<filter_letter_t>{
        constexpr bool operator ()(char c)const{
            return ((c>='a') && (c<='z')) || ((c>='A') && (c<='Z'));
     742:	3f e9       	ldi	r19, 0x9F	; 159
     744:	36 0f       	add	r19, r22
     746:	3a 31       	cpi	r19, 0x1A	; 26
     748:	30 f0       	brcs	.+12     	; 0x756 <_Z14parse_variableRN3Std11string_viewE+0xba>
     74a:	3f eb       	ldi	r19, 0xBF	; 191
     74c:	36 0f       	add	r19, r22
     74e:	3a 31       	cpi	r19, 0x1A	; 26
     750:	20 f4       	brcc	.+8      	; 0x75a <_Z14parse_variableRN3Std11string_viewE+0xbe>
     752:	37 2f       	mov	r19, r23
     754:	03 c0       	rjmp	.+6      	; 0x75c <_Z14parse_variableRN3Std11string_viewE+0xc0>
     756:	37 2f       	mov	r19, r23
     758:	01 c0       	rjmp	.+2      	; 0x75c <_Z14parse_variableRN3Std11string_viewE+0xc0>
     75a:	32 2f       	mov	r19, r18
        Filter1 _F1;
        Filter2 _F2;
        constexpr filter_or(Filter1  const & _F1, Filter2  _F2):
            _F1(_F1),_F2(_F2){}
        constexpr bool operator ()(char c)const{
            return _F1(c) || _F2(c);
     75c:	31 11       	cpse	r19, r1
     75e:	03 c0       	rjmp	.+6      	; 0x766 <_Z14parse_variableRN3Std11string_viewE+0xca>
     760:	6f 35       	cpi	r22, 0x5F	; 95
     762:	09 f4       	brne	.+2      	; 0x766 <_Z14parse_variableRN3Std11string_viewE+0xca>
     764:	37 2f       	mov	r19, r23
     766:	31 11       	cpse	r19, r1
     768:	06 c0       	rjmp	.+12     	; 0x776 <_Z14parse_variableRN3Std11string_viewE+0xda>
        }
    };
    struct filter_num_t:public filter_base<filter_num_t>
    {
        constexpr bool operator ()(char c)const{
            return c>='0' && c<='9';
     76a:	60 53       	subi	r22, 0x30	; 48
        Filter1 _F1;
        Filter2 _F2;
        constexpr filter_or(Filter1  const & _F1, Filter2  _F2):
            _F1(_F1),_F2(_F2){}
        constexpr bool operator ()(char c)const{
            return _F1(c) || _F2(c);
     76c:	6a 30       	cpi	r22, 0x0A	; 10
     76e:	18 f4       	brcc	.+6      	; 0x776 <_Z14parse_variableRN3Std11string_viewE+0xda>
     770:	37 2f       	mov	r19, r23
     772:	01 c0       	rjmp	.+2      	; 0x776 <_Z14parse_variableRN3Std11string_viewE+0xda>
     774:	32 2f       	mov	r19, r18
     776:	33 23       	and	r19, r19
     778:	59 f0       	breq	.+22     	; 0x790 <_Z14parse_variableRN3Std11string_viewE+0xf4>
		const char * cend()const{
			return _data+_size;
		}
		
        void step(){
            _size--;
     77a:	01 97       	sbiw	r24, 0x01	; 1
     77c:	93 83       	std	Z+3, r25	; 0x03
     77e:	82 83       	std	Z+2, r24	; 0x02
            _data++;
     780:	80 81       	ld	r24, Z
     782:	91 81       	ldd	r25, Z+1	; 0x01
     784:	01 96       	adiw	r24, 0x01	; 1
     786:	91 83       	std	Z+1, r25	; 0x01
     788:	80 83       	st	Z, r24
            S.step();
            _size++;
     78a:	4f 5f       	subi	r20, 0xFF	; 255
     78c:	5f 4f       	sbci	r21, 0xFF	; 255
    }
    if(!S.empty() && variable_begin(S.front())){
        const char * begin =  S.begin();
        size_t _size=1;
        S.step();
        while(!S.empty() && variable(S.front())){
     78e:	d2 cf       	rjmp	.-92     	; 0x734 <_Z14parse_variableRN3Std11string_viewE+0x98>
        constexpr string_view(const char * _data = NULL):
            _data(_data), _size(_data != NULL ? strlen(_data) : 0)
        {
        }
        constexpr string_view(const char * _data,size_t _size):
            _data(_data), _size(_size)
     790:	6a 2f       	mov	r22, r26
     792:	7b 2f       	mov	r23, r27
     794:	84 2f       	mov	r24, r20
     796:	95 2f       	mov	r25, r21
     798:	04 c0       	rjmp	.+8      	; 0x7a2 <_Z14parse_variableRN3Std11string_viewE+0x106>
            S.step();
            _size++;
        }
        return Std::string_view(begin,_size);
    } 
    return {};
     79a:	60 e0       	ldi	r22, 0x00	; 0
     79c:	70 e0       	ldi	r23, 0x00	; 0
     79e:	80 e0       	ldi	r24, 0x00	; 0
     7a0:	90 e0       	ldi	r25, 0x00	; 0
}
     7a2:	df 91       	pop	r29
     7a4:	cf 91       	pop	r28
     7a6:	08 95       	ret

000007a8 <_Z11print_clockRK11hh_mm_ss_dd>:
	}
}



void print_clock(hh_mm_ss_dd const & m_time){
     7a8:	cf 93       	push	r28
     7aa:	df 93       	push	r29
     7ac:	cd b7       	in	r28, 0x3d	; 61
     7ae:	de b7       	in	r29, 0x3e	; 62
     7b0:	29 97       	sbiw	r28, 0x09	; 9
     7b2:	0f b6       	in	r0, 0x3f	; 63
     7b4:	f8 94       	cli
     7b6:	de bf       	out	0x3e, r29	; 62
     7b8:	0f be       	out	0x3f, r0	; 63
     7ba:	cd bf       	out	0x3d, r28	; 61
		uint8_t rm = value%10;
		return {del%10+'0', rm+'0'};
	};
	constexpr uint8_t length = 9;
	char str[length];
	memcpy(str + 0,getNum1Num2(m_time.hh).data(),2);
     7bc:	1a 82       	std	Y+2, r1	; 0x02
     7be:	19 82       	std	Y+1, r1	; 0x01
	str[2] = ':';
     7c0:	8a e3       	ldi	r24, 0x3A	; 58
     7c2:	8b 83       	std	Y+3, r24	; 0x03
	memcpy(str + 3,getNum1Num2(m_time.mm).data(),2);
     7c4:	1d 82       	std	Y+5, r1	; 0x05
     7c6:	1c 82       	std	Y+4, r1	; 0x04
	str[5] = ':';
     7c8:	8e 83       	std	Y+6, r24	; 0x06
	memcpy(str + 6,getNum1Num2(m_time.ss).data(),2);
     7ca:	18 86       	std	Y+8, r1	; 0x08
     7cc:	1f 82       	std	Y+7, r1	; 0x07
	str[8] = 0;
     7ce:	19 86       	std	Y+9, r1	; 0x09
	Serial.print(str);
     7d0:	be 01       	movw	r22, r28
     7d2:	6f 5f       	subi	r22, 0xFF	; 255
     7d4:	7f 4f       	sbci	r23, 0xFF	; 255
     7d6:	80 e8       	ldi	r24, 0x80	; 128
     7d8:	98 e0       	ldi	r25, 0x08	; 8
     7da:	0e 94 8c 18 	call	0x3118	; 0x3118 <_ZN5Print5printEPKc>
}
     7de:	29 96       	adiw	r28, 0x09	; 9
     7e0:	0f b6       	in	r0, 0x3f	; 63
     7e2:	f8 94       	cli
     7e4:	de bf       	out	0x3e, r29	; 62
     7e6:	0f be       	out	0x3f, r0	; 63
     7e8:	cd bf       	out	0x3d, r28	; 61
     7ea:	df 91       	pop	r29
     7ec:	cf 91       	pop	r28
     7ee:	08 95       	ret

000007f0 <_Z15get_float_param11float_pname>:
#define SETTINGS_PARAM_CASE(pname) \
case float_pname::pname:\
	return settings.get([](Settings const & S){return S.pname;});\
	break;

float get_float_param(float_pname pname){
     7f0:	cf 92       	push	r12
     7f2:	df 92       	push	r13
     7f4:	ef 92       	push	r14
     7f6:	ff 92       	push	r15
     7f8:	cf 93       	push	r28
     7fa:	df 93       	push	r29
	switch (pname)
     7fc:	82 30       	cpi	r24, 0x02	; 2
     7fe:	89 f1       	breq	.+98     	; 0x862 <__DATA_REGION_LENGTH__+0x62>
     800:	28 f4       	brcc	.+10     	; 0x80c <__DATA_REGION_LENGTH__+0xc>
     802:	88 23       	and	r24, r24
     804:	51 f0       	breq	.+20     	; 0x81a <__DATA_REGION_LENGTH__+0x1a>
     806:	81 30       	cpi	r24, 0x01	; 1
     808:	99 f0       	breq	.+38     	; 0x830 <__DATA_REGION_LENGTH__+0x30>
     80a:	76 c0       	rjmp	.+236    	; 0x8f8 <__DATA_REGION_LENGTH__+0xf8>
     80c:	83 30       	cpi	r24, 0x03	; 3
     80e:	09 f4       	brne	.+2      	; 0x812 <__DATA_REGION_LENGTH__+0x12>
     810:	41 c0       	rjmp	.+130    	; 0x894 <__DATA_REGION_LENGTH__+0x94>
     812:	84 30       	cpi	r24, 0x04	; 4
     814:	09 f4       	brne	.+2      	; 0x818 <__DATA_REGION_LENGTH__+0x18>
     816:	57 c0       	rjmp	.+174    	; 0x8c6 <__DATA_REGION_LENGTH__+0xc6>
     818:	6f c0       	rjmp	.+222    	; 0x8f8 <__DATA_REGION_LENGTH__+0xf8>
};

struct atomic_guard{
	uint8_t sreg;
	inline void lock(){
		uint8_t sreg_tmp = SREG;
     81a:	8f b7       	in	r24, 0x3f	; 63
		cli();
     81c:	f8 94       	cli
		sreg = sreg_tmp;
     81e:	e5 e3       	ldi	r30, 0x35	; 53
     820:	f2 e0       	ldi	r31, 0x02	; 2
     822:	84 83       	std	Z+4, r24	; 0x04
		unlock();
		return m_value;
	}
	
	inline Std::remove_reference_t<T> get() const{
		return get([](auto const &x){return x;});
     824:	c0 80       	ld	r12, Z
     826:	d1 80       	ldd	r13, Z+1	; 0x01
     828:	e2 80       	ldd	r14, Z+2	; 0x02
     82a:	f3 80       	ldd	r15, Z+3	; 0x03
		uint8_t sreg_tmp = SREG;
		cli();
		sreg = sreg_tmp;
	}
	inline void unlock(){
		SREG = sreg;
     82c:	8f bf       	out	0x3f, r24	; 63
	{
	case float_pname::Temp:
		return Temp.get();
     82e:	6d c0       	rjmp	.+218    	; 0x90a <__stack+0xb>
#include "../../FreeRTOS/semphr.h"

struct mutex{
	SemaphoreHandle_t xMutex;
	void lock(){
		xSemaphoreTake(xMutex, portMAX_DELAY);
     830:	cf e0       	ldi	r28, 0x0F	; 15
     832:	d2 e0       	ldi	r29, 0x02	; 2
     834:	20 e0       	ldi	r18, 0x00	; 0
     836:	4f ef       	ldi	r20, 0xFF	; 255
     838:	5f ef       	ldi	r21, 0xFF	; 255
     83a:	60 e0       	ldi	r22, 0x00	; 0
     83c:	70 e0       	ldi	r23, 0x00	; 0
     83e:	8c 8d       	ldd	r24, Y+28	; 0x1c
     840:	9d 8d       	ldd	r25, Y+29	; 0x1d
     842:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <xQueueGenericReceive>
		break;
	SETTINGS_PARAM_CASE(T1o)
     846:	c8 80       	ld	r12, Y
     848:	d9 80       	ldd	r13, Y+1	; 0x01
     84a:	ea 80       	ldd	r14, Y+2	; 0x02
     84c:	fb 80       	ldd	r15, Y+3	; 0x03
	};
	void unlock(){
		xSemaphoreGive(xMutex);
     84e:	20 e0       	ldi	r18, 0x00	; 0
     850:	40 e0       	ldi	r20, 0x00	; 0
     852:	50 e0       	ldi	r21, 0x00	; 0
     854:	60 e0       	ldi	r22, 0x00	; 0
     856:	70 e0       	ldi	r23, 0x00	; 0
     858:	8c 8d       	ldd	r24, Y+28	; 0x1c
     85a:	9d 8d       	ldd	r25, Y+29	; 0x1d
     85c:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <xQueueGenericSend>
     860:	54 c0       	rjmp	.+168    	; 0x90a <__stack+0xb>
#include "../../FreeRTOS/semphr.h"

struct mutex{
	SemaphoreHandle_t xMutex;
	void lock(){
		xSemaphoreTake(xMutex, portMAX_DELAY);
     862:	cf e0       	ldi	r28, 0x0F	; 15
     864:	d2 e0       	ldi	r29, 0x02	; 2
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	4f ef       	ldi	r20, 0xFF	; 255
     86a:	5f ef       	ldi	r21, 0xFF	; 255
     86c:	60 e0       	ldi	r22, 0x00	; 0
     86e:	70 e0       	ldi	r23, 0x00	; 0
     870:	8c 8d       	ldd	r24, Y+28	; 0x1c
     872:	9d 8d       	ldd	r25, Y+29	; 0x1d
     874:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <xQueueGenericReceive>
	SETTINGS_PARAM_CASE(T1c)
     878:	cc 80       	ldd	r12, Y+4	; 0x04
     87a:	dd 80       	ldd	r13, Y+5	; 0x05
     87c:	ee 80       	ldd	r14, Y+6	; 0x06
     87e:	ff 80       	ldd	r15, Y+7	; 0x07
	};
	void unlock(){
		xSemaphoreGive(xMutex);
     880:	20 e0       	ldi	r18, 0x00	; 0
     882:	40 e0       	ldi	r20, 0x00	; 0
     884:	50 e0       	ldi	r21, 0x00	; 0
     886:	60 e0       	ldi	r22, 0x00	; 0
     888:	70 e0       	ldi	r23, 0x00	; 0
     88a:	8c 8d       	ldd	r24, Y+28	; 0x1c
     88c:	9d 8d       	ldd	r25, Y+29	; 0x1d
     88e:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <xQueueGenericSend>
     892:	3b c0       	rjmp	.+118    	; 0x90a <__stack+0xb>
#include "../../FreeRTOS/semphr.h"

struct mutex{
	SemaphoreHandle_t xMutex;
	void lock(){
		xSemaphoreTake(xMutex, portMAX_DELAY);
     894:	cf e0       	ldi	r28, 0x0F	; 15
     896:	d2 e0       	ldi	r29, 0x02	; 2
     898:	20 e0       	ldi	r18, 0x00	; 0
     89a:	4f ef       	ldi	r20, 0xFF	; 255
     89c:	5f ef       	ldi	r21, 0xFF	; 255
     89e:	60 e0       	ldi	r22, 0x00	; 0
     8a0:	70 e0       	ldi	r23, 0x00	; 0
     8a2:	8c 8d       	ldd	r24, Y+28	; 0x1c
     8a4:	9d 8d       	ldd	r25, Y+29	; 0x1d
     8a6:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <xQueueGenericReceive>
	SETTINGS_PARAM_CASE(T2o)
     8aa:	c8 84       	ldd	r12, Y+8	; 0x08
     8ac:	d9 84       	ldd	r13, Y+9	; 0x09
     8ae:	ea 84       	ldd	r14, Y+10	; 0x0a
     8b0:	fb 84       	ldd	r15, Y+11	; 0x0b
	};
	void unlock(){
		xSemaphoreGive(xMutex);
     8b2:	20 e0       	ldi	r18, 0x00	; 0
     8b4:	40 e0       	ldi	r20, 0x00	; 0
     8b6:	50 e0       	ldi	r21, 0x00	; 0
     8b8:	60 e0       	ldi	r22, 0x00	; 0
     8ba:	70 e0       	ldi	r23, 0x00	; 0
     8bc:	8c 8d       	ldd	r24, Y+28	; 0x1c
     8be:	9d 8d       	ldd	r25, Y+29	; 0x1d
     8c0:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <xQueueGenericSend>
     8c4:	22 c0       	rjmp	.+68     	; 0x90a <__stack+0xb>
#include "../../FreeRTOS/semphr.h"

struct mutex{
	SemaphoreHandle_t xMutex;
	void lock(){
		xSemaphoreTake(xMutex, portMAX_DELAY);
     8c6:	cf e0       	ldi	r28, 0x0F	; 15
     8c8:	d2 e0       	ldi	r29, 0x02	; 2
     8ca:	20 e0       	ldi	r18, 0x00	; 0
     8cc:	4f ef       	ldi	r20, 0xFF	; 255
     8ce:	5f ef       	ldi	r21, 0xFF	; 255
     8d0:	60 e0       	ldi	r22, 0x00	; 0
     8d2:	70 e0       	ldi	r23, 0x00	; 0
     8d4:	8c 8d       	ldd	r24, Y+28	; 0x1c
     8d6:	9d 8d       	ldd	r25, Y+29	; 0x1d
     8d8:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <xQueueGenericReceive>
	SETTINGS_PARAM_CASE(T2c)
     8dc:	cc 84       	ldd	r12, Y+12	; 0x0c
     8de:	dd 84       	ldd	r13, Y+13	; 0x0d
     8e0:	ee 84       	ldd	r14, Y+14	; 0x0e
     8e2:	ff 84       	ldd	r15, Y+15	; 0x0f
	};
	void unlock(){
		xSemaphoreGive(xMutex);
     8e4:	20 e0       	ldi	r18, 0x00	; 0
     8e6:	40 e0       	ldi	r20, 0x00	; 0
     8e8:	50 e0       	ldi	r21, 0x00	; 0
     8ea:	60 e0       	ldi	r22, 0x00	; 0
     8ec:	70 e0       	ldi	r23, 0x00	; 0
     8ee:	8c 8d       	ldd	r24, Y+28	; 0x1c
     8f0:	9d 8d       	ldd	r25, Y+29	; 0x1d
     8f2:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <xQueueGenericSend>
     8f6:	09 c0       	rjmp	.+18     	; 0x90a <__stack+0xb>
	default:
		return 0.0/0.0;
     8f8:	20 e0       	ldi	r18, 0x00	; 0
     8fa:	30 e0       	ldi	r19, 0x00	; 0
     8fc:	a9 01       	movw	r20, r18
     8fe:	ca 01       	movw	r24, r20
     900:	b9 01       	movw	r22, r18
     902:	0e 94 44 0d 	call	0x1a88	; 0x1a88 <__divsf3>
     906:	6b 01       	movw	r12, r22
     908:	7c 01       	movw	r14, r24
	}
}
     90a:	c7 01       	movw	r24, r14
     90c:	b6 01       	movw	r22, r12
     90e:	df 91       	pop	r29
     910:	cf 91       	pop	r28
     912:	ff 90       	pop	r15
     914:	ef 90       	pop	r14
     916:	df 90       	pop	r13
     918:	cf 90       	pop	r12
     91a:	08 95       	ret

0000091c <_Z16get_uint32_param12uint32_pname>:

#define SETTINGS_I_PARAM_CASE(pname) \
case uint32_pname::pname:\
	return settings.get([](Settings const & S){return S.pname;});\
	break;
uint_least32_t get_uint32_param(uint32_pname pname){
     91c:	cf 92       	push	r12
     91e:	df 92       	push	r13
     920:	ef 92       	push	r14
     922:	ff 92       	push	r15
     924:	cf 93       	push	r28
     926:	df 93       	push	r29
	switch (pname)
     928:	81 30       	cpi	r24, 0x01	; 1
     92a:	91 05       	cpc	r25, r1
     92c:	f9 f0       	breq	.+62     	; 0x96c <_Z16get_uint32_param12uint32_pname+0x50>
     92e:	82 30       	cpi	r24, 0x02	; 2
     930:	91 05       	cpc	r25, r1
     932:	a9 f1       	breq	.+106    	; 0x99e <_Z16get_uint32_param12uint32_pname+0x82>
     934:	89 2b       	or	r24, r25
     936:	09 f0       	breq	.+2      	; 0x93a <_Z16get_uint32_param12uint32_pname+0x1e>
     938:	4b c0       	rjmp	.+150    	; 0x9d0 <_Z16get_uint32_param12uint32_pname+0xb4>
#include "../../FreeRTOS/semphr.h"

struct mutex{
	SemaphoreHandle_t xMutex;
	void lock(){
		xSemaphoreTake(xMutex, portMAX_DELAY);
     93a:	cf e0       	ldi	r28, 0x0F	; 15
     93c:	d2 e0       	ldi	r29, 0x02	; 2
     93e:	20 e0       	ldi	r18, 0x00	; 0
     940:	4f ef       	ldi	r20, 0xFF	; 255
     942:	5f ef       	ldi	r21, 0xFF	; 255
     944:	60 e0       	ldi	r22, 0x00	; 0
     946:	70 e0       	ldi	r23, 0x00	; 0
     948:	8c 8d       	ldd	r24, Y+28	; 0x1c
     94a:	9d 8d       	ldd	r25, Y+29	; 0x1d
     94c:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <xQueueGenericReceive>
	{
		SETTINGS_I_PARAM_CASE(Tmd)
     950:	c8 88       	ldd	r12, Y+16	; 0x10
     952:	d9 88       	ldd	r13, Y+17	; 0x11
     954:	ea 88       	ldd	r14, Y+18	; 0x12
     956:	fb 88       	ldd	r15, Y+19	; 0x13
	};
	void unlock(){
		xSemaphoreGive(xMutex);
     958:	20 e0       	ldi	r18, 0x00	; 0
     95a:	40 e0       	ldi	r20, 0x00	; 0
     95c:	50 e0       	ldi	r21, 0x00	; 0
     95e:	60 e0       	ldi	r22, 0x00	; 0
     960:	70 e0       	ldi	r23, 0x00	; 0
     962:	8c 8d       	ldd	r24, Y+28	; 0x1c
     964:	9d 8d       	ldd	r25, Y+29	; 0x1d
     966:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <xQueueGenericSend>
     96a:	35 c0       	rjmp	.+106    	; 0x9d6 <_Z16get_uint32_param12uint32_pname+0xba>
#include "../../FreeRTOS/semphr.h"

struct mutex{
	SemaphoreHandle_t xMutex;
	void lock(){
		xSemaphoreTake(xMutex, portMAX_DELAY);
     96c:	cf e0       	ldi	r28, 0x0F	; 15
     96e:	d2 e0       	ldi	r29, 0x02	; 2
     970:	20 e0       	ldi	r18, 0x00	; 0
     972:	4f ef       	ldi	r20, 0xFF	; 255
     974:	5f ef       	ldi	r21, 0xFF	; 255
     976:	60 e0       	ldi	r22, 0x00	; 0
     978:	70 e0       	ldi	r23, 0x00	; 0
     97a:	8c 8d       	ldd	r24, Y+28	; 0x1c
     97c:	9d 8d       	ldd	r25, Y+29	; 0x1d
     97e:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <xQueueGenericReceive>
		SETTINGS_I_PARAM_CASE(Twd)
     982:	cc 88       	ldd	r12, Y+20	; 0x14
     984:	dd 88       	ldd	r13, Y+21	; 0x15
     986:	ee 88       	ldd	r14, Y+22	; 0x16
     988:	ff 88       	ldd	r15, Y+23	; 0x17
	};
	void unlock(){
		xSemaphoreGive(xMutex);
     98a:	20 e0       	ldi	r18, 0x00	; 0
     98c:	40 e0       	ldi	r20, 0x00	; 0
     98e:	50 e0       	ldi	r21, 0x00	; 0
     990:	60 e0       	ldi	r22, 0x00	; 0
     992:	70 e0       	ldi	r23, 0x00	; 0
     994:	8c 8d       	ldd	r24, Y+28	; 0x1c
     996:	9d 8d       	ldd	r25, Y+29	; 0x1d
     998:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <xQueueGenericSend>
     99c:	1c c0       	rjmp	.+56     	; 0x9d6 <_Z16get_uint32_param12uint32_pname+0xba>
#include "../../FreeRTOS/semphr.h"

struct mutex{
	SemaphoreHandle_t xMutex;
	void lock(){
		xSemaphoreTake(xMutex, portMAX_DELAY);
     99e:	cf e0       	ldi	r28, 0x0F	; 15
     9a0:	d2 e0       	ldi	r29, 0x02	; 2
     9a2:	20 e0       	ldi	r18, 0x00	; 0
     9a4:	4f ef       	ldi	r20, 0xFF	; 255
     9a6:	5f ef       	ldi	r21, 0xFF	; 255
     9a8:	60 e0       	ldi	r22, 0x00	; 0
     9aa:	70 e0       	ldi	r23, 0x00	; 0
     9ac:	8c 8d       	ldd	r24, Y+28	; 0x1c
     9ae:	9d 8d       	ldd	r25, Y+29	; 0x1d
     9b0:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <xQueueGenericReceive>
		SETTINGS_I_PARAM_CASE(f_cpu)
     9b4:	c8 8c       	ldd	r12, Y+24	; 0x18
     9b6:	d9 8c       	ldd	r13, Y+25	; 0x19
     9b8:	ea 8c       	ldd	r14, Y+26	; 0x1a
     9ba:	fb 8c       	ldd	r15, Y+27	; 0x1b
	};
	void unlock(){
		xSemaphoreGive(xMutex);
     9bc:	20 e0       	ldi	r18, 0x00	; 0
     9be:	40 e0       	ldi	r20, 0x00	; 0
     9c0:	50 e0       	ldi	r21, 0x00	; 0
     9c2:	60 e0       	ldi	r22, 0x00	; 0
     9c4:	70 e0       	ldi	r23, 0x00	; 0
     9c6:	8c 8d       	ldd	r24, Y+28	; 0x1c
     9c8:	9d 8d       	ldd	r25, Y+29	; 0x1d
     9ca:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <xQueueGenericSend>
     9ce:	03 c0       	rjmp	.+6      	; 0x9d6 <_Z16get_uint32_param12uint32_pname+0xba>
		default:
			return 0;
     9d0:	c1 2c       	mov	r12, r1
     9d2:	d1 2c       	mov	r13, r1
     9d4:	76 01       	movw	r14, r12
			break;
	}
}
     9d6:	c7 01       	movw	r24, r14
     9d8:	b6 01       	movw	r22, r12
     9da:	df 91       	pop	r29
     9dc:	cf 91       	pop	r28
     9de:	ff 90       	pop	r15
     9e0:	ef 90       	pop	r14
     9e2:	df 90       	pop	r13
     9e4:	cf 90       	pop	r12
     9e6:	08 95       	ret

000009e8 <_Z14print_durationm>:

void print_duration(uint_least32_t m_secs){
     9e8:	4f 92       	push	r4
     9ea:	5f 92       	push	r5
     9ec:	6f 92       	push	r6
     9ee:	7f 92       	push	r7
     9f0:	8f 92       	push	r8
     9f2:	9f 92       	push	r9
     9f4:	af 92       	push	r10
     9f6:	bf 92       	push	r11
     9f8:	cf 92       	push	r12
     9fa:	df 92       	push	r13
     9fc:	ef 92       	push	r14
     9fe:	ff 92       	push	r15
     a00:	cf 93       	push	r28
     a02:	df 93       	push	r29
     a04:	4b 01       	movw	r8, r22
     a06:	5c 01       	movw	r10, r24
	static	hh_mm_ss_dd from_sec(uint_least32_t m_sec){
		uint_least32_t m_min = m_sec/60;
     a08:	0f 2e       	mov	r0, r31
     a0a:	fc e3       	ldi	r31, 0x3C	; 60
     a0c:	cf 2e       	mov	r12, r31
     a0e:	d1 2c       	mov	r13, r1
     a10:	e1 2c       	mov	r14, r1
     a12:	f1 2c       	mov	r15, r1
     a14:	f0 2d       	mov	r31, r0
     a16:	a7 01       	movw	r20, r14
     a18:	96 01       	movw	r18, r12
     a1a:	0e 94 52 1c 	call	0x38a4	; 0x38a4 <__udivmodsi4>
     a1e:	29 01       	movw	r4, r18
     a20:	3a 01       	movw	r6, r20
     a22:	c6 2f       	mov	r28, r22
		uint_least8_t sec_rm = m_sec%60;
		
		uint_least32_t m_hou = m_min/60;
     a24:	c5 01       	movw	r24, r10
     a26:	b4 01       	movw	r22, r8
     a28:	20 e1       	ldi	r18, 0x10	; 16
     a2a:	3e e0       	ldi	r19, 0x0E	; 14
     a2c:	40 e0       	ldi	r20, 0x00	; 0
     a2e:	50 e0       	ldi	r21, 0x00	; 0
     a30:	0e 94 52 1c 	call	0x38a4	; 0x38a4 <__udivmodsi4>
     a34:	49 01       	movw	r8, r18
     a36:	5a 01       	movw	r10, r20
		uint_least8_t min_rm = m_min%60;
     a38:	c3 01       	movw	r24, r6
     a3a:	b2 01       	movw	r22, r4
     a3c:	a7 01       	movw	r20, r14
     a3e:	96 01       	movw	r18, r12
     a40:	0e 94 52 1c 	call	0x38a4	; 0x38a4 <__udivmodsi4>
     a44:	d6 2f       	mov	r29, r22
     a46:	f6 2e       	mov	r15, r22
		
		return {m_hou/24,m_hou%24,min_rm,sec_rm};
     a48:	c5 01       	movw	r24, r10
     a4a:	b4 01       	movw	r22, r8
     a4c:	28 e1       	ldi	r18, 0x18	; 24
     a4e:	30 e0       	ldi	r19, 0x00	; 0
     a50:	40 e0       	ldi	r20, 0x00	; 0
     a52:	50 e0       	ldi	r21, 0x00	; 0
     a54:	0e 94 52 1c 	call	0x38a4	; 0x38a4 <__udivmodsi4>
	hh_mm_ss_dd m_dur = hh_mm_ss_dd::from_sec(m_secs);
	if(m_dur.hh != 0)
     a58:	66 23       	and	r22, r22
     a5a:	69 f0       	breq	.+26     	; 0xa76 <_Z14print_durationm+0x8e>
	{
		Serial.print((int)m_dur.hh);
     a5c:	70 e0       	ldi	r23, 0x00	; 0
     a5e:	4a e0       	ldi	r20, 0x0A	; 10
     a60:	50 e0       	ldi	r21, 0x00	; 0
     a62:	80 e8       	ldi	r24, 0x80	; 128
     a64:	98 e0       	ldi	r25, 0x08	; 8
     a66:	0e 94 6a 19 	call	0x32d4	; 0x32d4 <_ZN5Print5printEii>
		Serial.print(" hours, ");
     a6a:	62 e4       	ldi	r22, 0x42	; 66
     a6c:	71 e0       	ldi	r23, 0x01	; 1
     a6e:	80 e8       	ldi	r24, 0x80	; 128
     a70:	98 e0       	ldi	r25, 0x08	; 8
     a72:	0e 94 8c 18 	call	0x3118	; 0x3118 <_ZN5Print5printEPKc>
	}
	if(m_dur.mm != 0 )
     a76:	ff 20       	and	r15, r15
     a78:	71 f0       	breq	.+28     	; 0xa96 <_Z14print_durationm+0xae>
	{
		Serial.print((int)m_dur.mm);
     a7a:	6d 2f       	mov	r22, r29
     a7c:	70 e0       	ldi	r23, 0x00	; 0
     a7e:	4a e0       	ldi	r20, 0x0A	; 10
     a80:	50 e0       	ldi	r21, 0x00	; 0
     a82:	80 e8       	ldi	r24, 0x80	; 128
     a84:	98 e0       	ldi	r25, 0x08	; 8
     a86:	0e 94 6a 19 	call	0x32d4	; 0x32d4 <_ZN5Print5printEii>
		Serial.print(" mins, ");
     a8a:	6b e4       	ldi	r22, 0x4B	; 75
     a8c:	71 e0       	ldi	r23, 0x01	; 1
     a8e:	80 e8       	ldi	r24, 0x80	; 128
     a90:	98 e0       	ldi	r25, 0x08	; 8
     a92:	0e 94 8c 18 	call	0x3118	; 0x3118 <_ZN5Print5printEPKc>
	}
	Serial.print((int)m_dur.ss);
     a96:	6c 2f       	mov	r22, r28
     a98:	70 e0       	ldi	r23, 0x00	; 0
     a9a:	4a e0       	ldi	r20, 0x0A	; 10
     a9c:	50 e0       	ldi	r21, 0x00	; 0
     a9e:	80 e8       	ldi	r24, 0x80	; 128
     aa0:	98 e0       	ldi	r25, 0x08	; 8
     aa2:	0e 94 6a 19 	call	0x32d4	; 0x32d4 <_ZN5Print5printEii>
	Serial.print(" secs");
     aa6:	63 e5       	ldi	r22, 0x53	; 83
     aa8:	71 e0       	ldi	r23, 0x01	; 1
     aaa:	80 e8       	ldi	r24, 0x80	; 128
     aac:	98 e0       	ldi	r25, 0x08	; 8
     aae:	0e 94 8c 18 	call	0x3118	; 0x3118 <_ZN5Print5printEPKc>
}
     ab2:	df 91       	pop	r29
     ab4:	cf 91       	pop	r28
     ab6:	ff 90       	pop	r15
     ab8:	ef 90       	pop	r14
     aba:	df 90       	pop	r13
     abc:	cf 90       	pop	r12
     abe:	bf 90       	pop	r11
     ac0:	af 90       	pop	r10
     ac2:	9f 90       	pop	r9
     ac4:	8f 90       	pop	r8
     ac6:	7f 90       	pop	r7
     ac8:	6f 90       	pop	r6
     aca:	5f 90       	pop	r5
     acc:	4f 90       	pop	r4
     ace:	08 95       	ret

00000ad0 <_Z10print_planv>:

void print_plan(){
     ad0:	cf 92       	push	r12
     ad2:	df 92       	push	r13
     ad4:	ef 92       	push	r14
     ad6:	ff 92       	push	r15
     ad8:	0f 93       	push	r16
     ada:	1f 93       	push	r17
     adc:	cf 93       	push	r28
     ade:	df 93       	push	r29
	water_plan_array_t const& mplan = water_plan.value;
     ae0:	e0 90 31 02 	lds	r14, 0x0231	; 0x800231 <water_plan>
     ae4:	f0 90 32 02 	lds	r15, 0x0232	; 0x800232 <water_plan+0x1>
	uint8_t num = 0;
	for(uint8_t i=0;i<mplan.size();++i){
     ae8:	c0 e0       	ldi	r28, 0x00	; 0
	Serial.print(" secs");
}

void print_plan(){
	water_plan_array_t const& mplan = water_plan.value;
	uint8_t num = 0;
     aea:	d0 e0       	ldi	r29, 0x00	; 0
	for(uint8_t i=0;i<mplan.size();++i){
     aec:	c8 30       	cpi	r28, 0x08	; 8
     aee:	08 f0       	brcs	.+2      	; 0xaf2 <_Z10print_planv+0x22>
     af0:	40 c0       	rjmp	.+128    	; 0xb72 <_Z10print_planv+0xa2>
		if(mplan[i].actual){
     af2:	0c 2f       	mov	r16, r28
     af4:	10 e0       	ldi	r17, 0x00	; 0
     af6:	8d e0       	ldi	r24, 0x0D	; 13
     af8:	80 9f       	mul	r24, r16
     afa:	f0 01       	movw	r30, r0
     afc:	81 9f       	mul	r24, r17
     afe:	f0 0d       	add	r31, r0
     b00:	11 24       	eor	r1, r1
     b02:	ee 0d       	add	r30, r14
     b04:	ff 1d       	adc	r31, r15
     b06:	80 81       	ld	r24, Z
     b08:	88 23       	and	r24, r24
     b0a:	89 f1       	breq	.+98     	; 0xb6e <_Z10print_planv+0x9e>
			Serial.print((char) (num+'0'));
     b0c:	60 e3       	ldi	r22, 0x30	; 48
     b0e:	6d 0f       	add	r22, r29
     b10:	80 e8       	ldi	r24, 0x80	; 128
     b12:	98 e0       	ldi	r25, 0x08	; 8
     b14:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN5Print5printEc>
			Serial.print(')');
     b18:	69 e2       	ldi	r22, 0x29	; 41
     b1a:	80 e8       	ldi	r24, 0x80	; 128
     b1c:	98 e0       	ldi	r25, 0x08	; 8
     b1e:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN5Print5printEc>
			Serial.print(" at ");
     b22:	69 e5       	ldi	r22, 0x59	; 89
     b24:	71 e0       	ldi	r23, 0x01	; 1
     b26:	80 e8       	ldi	r24, 0x80	; 128
     b28:	98 e0       	ldi	r25, 0x08	; 8
     b2a:	0e 94 8c 18 	call	0x3118	; 0x3118 <_ZN5Print5printEPKc>
			print_clock(mplan[i].ptime);
     b2e:	8d e0       	ldi	r24, 0x0D	; 13
     b30:	80 9f       	mul	r24, r16
     b32:	60 01       	movw	r12, r0
     b34:	81 9f       	mul	r24, r17
     b36:	d0 0c       	add	r13, r0
     b38:	11 24       	eor	r1, r1
     b3a:	c6 01       	movw	r24, r12
     b3c:	02 96       	adiw	r24, 0x02	; 2
     b3e:	8e 0d       	add	r24, r14
     b40:	9f 1d       	adc	r25, r15
     b42:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <_Z11print_clockRK11hh_mm_ss_dd>
			Serial.print(" , ");
     b46:	6e e5       	ldi	r22, 0x5E	; 94
     b48:	71 e0       	ldi	r23, 0x01	; 1
     b4a:	80 e8       	ldi	r24, 0x80	; 128
     b4c:	98 e0       	ldi	r25, 0x08	; 8
     b4e:	0e 94 8c 18 	call	0x3118	; 0x3118 <_ZN5Print5printEPKc>
			print_duration(mplan[i].duration);
     b52:	f7 01       	movw	r30, r14
     b54:	ec 0d       	add	r30, r12
     b56:	fd 1d       	adc	r31, r13
     b58:	61 85       	ldd	r22, Z+9	; 0x09
     b5a:	72 85       	ldd	r23, Z+10	; 0x0a
     b5c:	83 85       	ldd	r24, Z+11	; 0x0b
     b5e:	94 85       	ldd	r25, Z+12	; 0x0c
     b60:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <_Z14print_durationm>
			Serial.println();
     b64:	80 e8       	ldi	r24, 0x80	; 128
     b66:	98 e0       	ldi	r25, 0x08	; 8
     b68:	0e 94 aa 18 	call	0x3154	; 0x3154 <_ZN5Print7printlnEv>
			++num;
     b6c:	df 5f       	subi	r29, 0xFF	; 255
}

void print_plan(){
	water_plan_array_t const& mplan = water_plan.value;
	uint8_t num = 0;
	for(uint8_t i=0;i<mplan.size();++i){
     b6e:	cf 5f       	subi	r28, 0xFF	; 255
     b70:	bd cf       	rjmp	.-134    	; 0xaec <_Z10print_planv+0x1c>
			print_duration(mplan[i].duration);
			Serial.println();
			++num;
		}
	}
}
     b72:	df 91       	pop	r29
     b74:	cf 91       	pop	r28
     b76:	1f 91       	pop	r17
     b78:	0f 91       	pop	r16
     b7a:	ff 90       	pop	r15
     b7c:	ef 90       	pop	r14
     b7e:	df 90       	pop	r13
     b80:	cf 90       	pop	r12
     b82:	08 95       	ret

00000b84 <_Z11print_everyv>:
void print_every(){
     b84:	cf 92       	push	r12
     b86:	df 92       	push	r13
     b88:	ef 92       	push	r14
     b8a:	ff 92       	push	r15
     b8c:	0f 93       	push	r16
     b8e:	1f 93       	push	r17
     b90:	cf 93       	push	r28
     b92:	df 93       	push	r29
     b94:	cd b7       	in	r28, 0x3d	; 61
     b96:	de b7       	in	r29, 0x3e	; 62
     b98:	27 97       	sbiw	r28, 0x07	; 7
     b9a:	0f b6       	in	r0, 0x3f	; 63
     b9c:	f8 94       	cli
     b9e:	de bf       	out	0x3e, r29	; 62
     ba0:	0f be       	out	0x3f, r0	; 63
     ba2:	cd bf       	out	0x3d, r28	; 61
	water_every_array_t const& m_every = water_every.value;
     ba4:	e0 90 2d 02 	lds	r14, 0x022D	; 0x80022d <water_every>
     ba8:	f0 90 2e 02 	lds	r15, 0x022E	; 0x80022e <water_every+0x1>
	uint8_t num = 0;
	for(uint8_t i=0;i<m_every.size();++i){
     bac:	d1 2c       	mov	r13, r1
		}
	}
}
void print_every(){
	water_every_array_t const& m_every = water_every.value;
	uint8_t num = 0;
     bae:	c1 2c       	mov	r12, r1
	for(uint8_t i=0;i<m_every.size();++i){
     bb0:	83 e0       	ldi	r24, 0x03	; 3
     bb2:	8d 15       	cp	r24, r13
     bb4:	08 f4       	brcc	.+2      	; 0xbb8 <_Z11print_everyv+0x34>
     bb6:	53 c0       	rjmp	.+166    	; 0xc5e <_Z11print_everyv+0xda>
		if(m_every[i].exist_flag){
     bb8:	0d 2d       	mov	r16, r13
     bba:	10 e0       	ldi	r17, 0x00	; 0
     bbc:	f8 01       	movw	r30, r16
     bbe:	ee 0f       	add	r30, r30
     bc0:	ff 1f       	adc	r31, r31
     bc2:	c8 01       	movw	r24, r16
     bc4:	88 0f       	add	r24, r24
     bc6:	99 1f       	adc	r25, r25
     bc8:	88 0f       	add	r24, r24
     bca:	99 1f       	adc	r25, r25
     bcc:	88 0f       	add	r24, r24
     bce:	99 1f       	adc	r25, r25
     bd0:	e8 0f       	add	r30, r24
     bd2:	f9 1f       	adc	r31, r25
     bd4:	ee 0d       	add	r30, r14
     bd6:	ff 1d       	adc	r31, r15
     bd8:	80 81       	ld	r24, Z
     bda:	88 23       	and	r24, r24
     bdc:	f1 f1       	breq	.+124    	; 0xc5a <_Z11print_everyv+0xd6>
			Serial.print((char) (num+'0'));
     bde:	60 e3       	ldi	r22, 0x30	; 48
     be0:	6c 0d       	add	r22, r12
     be2:	80 e8       	ldi	r24, 0x80	; 128
     be4:	98 e0       	ldi	r25, 0x08	; 8
     be6:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN5Print5printEc>
			Serial.print(')');
     bea:	69 e2       	ldi	r22, 0x29	; 41
     bec:	80 e8       	ldi	r24, 0x80	; 128
     bee:	98 e0       	ldi	r25, 0x08	; 8
     bf0:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN5Print5printEc>
			Serial.print("every ");
     bf4:	62 e6       	ldi	r22, 0x62	; 98
     bf6:	71 e0       	ldi	r23, 0x01	; 1
     bf8:	80 e8       	ldi	r24, 0x80	; 128
     bfa:	98 e0       	ldi	r25, 0x08	; 8
     bfc:	0e 94 8c 18 	call	0x3118	; 0x3118 <_ZN5Print5printEPKc>
			print_clock(hh_mm_ss_dd(0,m_every[i].hh,m_every[i].mm,0));
     c00:	c8 01       	movw	r24, r16
     c02:	88 0f       	add	r24, r24
     c04:	99 1f       	adc	r25, r25
     c06:	00 0f       	add	r16, r16
     c08:	11 1f       	adc	r17, r17
     c0a:	00 0f       	add	r16, r16
     c0c:	11 1f       	adc	r17, r17
     c0e:	00 0f       	add	r16, r16
     c10:	11 1f       	adc	r17, r17
     c12:	08 0f       	add	r16, r24
     c14:	19 1f       	adc	r17, r25
     c16:	0e 0d       	add	r16, r14
     c18:	1f 1d       	adc	r17, r15
     c1a:	f8 01       	movw	r30, r16
     c1c:	84 81       	ldd	r24, Z+4	; 0x04
     c1e:	93 81       	ldd	r25, Z+3	; 0x03
    uint_least32_t days;
	
	
    hh_mm_ss_dd(){}
    hh_mm_ss_dd(int_least32_t days,uint_least8_t hh,uint_least8_t mm,uint_least8_t ss = 0):
    hh(hh),mm(mm),ss(ss),days(days){}
     c20:	99 83       	std	Y+1, r25	; 0x01
     c22:	8a 83       	std	Y+2, r24	; 0x02
     c24:	1b 82       	std	Y+3, r1	; 0x03
     c26:	1c 82       	std	Y+4, r1	; 0x04
     c28:	1d 82       	std	Y+5, r1	; 0x05
     c2a:	1e 82       	std	Y+6, r1	; 0x06
     c2c:	1f 82       	std	Y+7, r1	; 0x07
     c2e:	ce 01       	movw	r24, r28
     c30:	01 96       	adiw	r24, 0x01	; 1
     c32:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <_Z11print_clockRK11hh_mm_ss_dd>
			Serial.print(" , ");
     c36:	6e e5       	ldi	r22, 0x5E	; 94
     c38:	71 e0       	ldi	r23, 0x01	; 1
     c3a:	80 e8       	ldi	r24, 0x80	; 128
     c3c:	98 e0       	ldi	r25, 0x08	; 8
     c3e:	0e 94 8c 18 	call	0x3118	; 0x3118 <_ZN5Print5printEPKc>
			print_duration(m_every[i].duration);
     c42:	f8 01       	movw	r30, r16
     c44:	66 81       	ldd	r22, Z+6	; 0x06
     c46:	77 81       	ldd	r23, Z+7	; 0x07
     c48:	80 85       	ldd	r24, Z+8	; 0x08
     c4a:	91 85       	ldd	r25, Z+9	; 0x09
     c4c:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <_Z14print_durationm>
			Serial.println();
     c50:	80 e8       	ldi	r24, 0x80	; 128
     c52:	98 e0       	ldi	r25, 0x08	; 8
     c54:	0e 94 aa 18 	call	0x3154	; 0x3154 <_ZN5Print7printlnEv>
			++num;
     c58:	c3 94       	inc	r12
	}
}
void print_every(){
	water_every_array_t const& m_every = water_every.value;
	uint8_t num = 0;
	for(uint8_t i=0;i<m_every.size();++i){
     c5a:	d3 94       	inc	r13
     c5c:	a9 cf       	rjmp	.-174    	; 0xbb0 <_Z11print_everyv+0x2c>
			print_duration(m_every[i].duration);
			Serial.println();
			++num;
		}
	}
     c5e:	27 96       	adiw	r28, 0x07	; 7
     c60:	0f b6       	in	r0, 0x3f	; 63
     c62:	f8 94       	cli
     c64:	de bf       	out	0x3e, r29	; 62
     c66:	0f be       	out	0x3f, r0	; 63
     c68:	cd bf       	out	0x3d, r28	; 61
     c6a:	df 91       	pop	r29
     c6c:	cf 91       	pop	r28
     c6e:	1f 91       	pop	r17
     c70:	0f 91       	pop	r16
     c72:	ff 90       	pop	r15
     c74:	ef 90       	pop	r14
     c76:	df 90       	pop	r13
     c78:	cf 90       	pop	r12
     c7a:	08 95       	ret

00000c7c <_Z21task_command_executorPv>:
inline void print_sw(Std::string_view const &m_string){
	Serial.write(m_string.data(),m_string.size());
}
void print_clock(hh_mm_ss_dd const & m_time);

void task_command_executor(void *){
     c7c:	cf 93       	push	r28
     c7e:	df 93       	push	r29
     c80:	cd b7       	in	r28, 0x3d	; 61
     c82:	de b7       	in	r29, 0x3e	; 62
     c84:	cb 59       	subi	r28, 0x9B	; 155
     c86:	d1 09       	sbc	r29, r1
     c88:	0f b6       	in	r0, 0x3f	; 63
     c8a:	f8 94       	cli
     c8c:	de bf       	out	0x3e, r29	; 62
     c8e:	0f be       	out	0x3f, r0	; 63
     c90:	cd bf       	out	0x3d, r28	; 61
	constexpr uint8_t max_buf_size = 64;
	char strbuf[max_buf_size];
	while(1){
		
		uint8_t rd_bt = Serial.readBytesUntil('\n',strbuf,max_buf_size);
     c92:	7e 01       	movw	r14, r28
     c94:	24 e2       	ldi	r18, 0x24	; 36
     c96:	e2 0e       	add	r14, r18
     c98:	f1 1c       	adc	r15, r1
     c9a:	20 e4       	ldi	r18, 0x40	; 64
     c9c:	30 e0       	ldi	r19, 0x00	; 0
     c9e:	a7 01       	movw	r20, r14
     ca0:	6a e0       	ldi	r22, 0x0A	; 10
     ca2:	80 e8       	ldi	r24, 0x80	; 128
     ca4:	98 e0       	ldi	r25, 0x08	; 8
     ca6:	0e 94 97 1a 	call	0x352e	; 0x352e <_ZN6Stream14readBytesUntilEcPcj>
     caa:	c8 56       	subi	r28, 0x68	; 104
     cac:	df 4f       	sbci	r29, 0xFF	; 255
     cae:	f9 82       	std	Y+1, r15	; 0x01
     cb0:	e8 82       	st	Y, r14
     cb2:	c8 59       	subi	r28, 0x98	; 152
     cb4:	d0 40       	sbci	r29, 0x00	; 0
     cb6:	99 27       	eor	r25, r25
     cb8:	c6 56       	subi	r28, 0x66	; 102
     cba:	df 4f       	sbci	r29, 0xFF	; 255
     cbc:	99 83       	std	Y+1, r25	; 0x01
     cbe:	88 83       	st	Y, r24
     cc0:	ca 59       	subi	r28, 0x9A	; 154
     cc2:	d0 40       	sbci	r29, 0x00	; 0
		Std::string_view m_string(strbuf,rd_bt);
		Std::string_view m_command = parse_command(m_string);
     cc4:	ce 01       	movw	r24, r28
     cc6:	88 56       	subi	r24, 0x68	; 104
     cc8:	9f 4f       	sbci	r25, 0xFF	; 255
     cca:	0e 94 da 02 	call	0x5b4	; 0x5b4 <_Z13parse_commandRN3Std11string_viewE>
     cce:	4b 01       	movw	r8, r22
     cd0:	5c 01       	movw	r10, r24
		template <size_t N>
		constexpr string_view(Std::array<char,N> const & m_char_array):
			_data(m_char_array.data()),_size(N){}

        inline size_t size()const{
            return _size;
     cd2:	75 01       	movw	r14, r10
		if(m_command.size() == 0){
     cd4:	ab 28       	or	r10, r11
     cd6:	89 f4       	brne	.+34     	; 0xcfa <_Z21task_command_executorPv+0x7e>
			char error_code[] = "error no command name";
     cd8:	86 e1       	ldi	r24, 0x16	; 22
     cda:	e2 e8       	ldi	r30, 0x82	; 130
     cdc:	f1 e0       	ldi	r31, 0x01	; 1
     cde:	de 01       	movw	r26, r28
     ce0:	ac 59       	subi	r26, 0x9C	; 156
     ce2:	bf 4f       	sbci	r27, 0xFF	; 255
     ce4:	01 90       	ld	r0, Z+
     ce6:	0d 92       	st	X+, r0
     ce8:	8a 95       	dec	r24
     cea:	e1 f7       	brne	.-8      	; 0xce4 <_Z21task_command_executorPv+0x68>
			Serial.println(error_code);
     cec:	be 01       	movw	r22, r28
     cee:	6c 59       	subi	r22, 0x9C	; 156
     cf0:	7f 4f       	sbci	r23, 0xFF	; 255
     cf2:	80 e8       	ldi	r24, 0x80	; 128
     cf4:	98 e0       	ldi	r25, 0x08	; 8
     cf6:	0e 94 b6 18 	call	0x316c	; 0x316c <_ZN5Print7printlnEPKc>
        constexpr  char back() const{
            return _data[_size-1];
        }

        constexpr bool operator == (const char * _other)const{
            for(size_t i=0;i<_size;++i){
     cfa:	60 e0       	ldi	r22, 0x00	; 0
     cfc:	70 e0       	ldi	r23, 0x00	; 0
     cfe:	6e 15       	cp	r22, r14
     d00:	7f 05       	cpc	r23, r15
     d02:	c0 f4       	brcc	.+48     	; 0xd34 <_Z21task_command_executorPv+0xb8>
                if(_other[i] == 0){
     d04:	fb 01       	movw	r30, r22
     d06:	ec 54       	subi	r30, 0x4C	; 76
     d08:	fe 4f       	sbci	r31, 0xFE	; 254
     d0a:	80 81       	ld	r24, Z
     d0c:	81 11       	cpse	r24, r1
     d0e:	09 c0       	rjmp	.+18     	; 0xd22 <_Z21task_command_executorPv+0xa6>
                    return _data[i] == 0;
     d10:	fb 01       	movw	r30, r22
     d12:	e8 0d       	add	r30, r8
     d14:	f9 1d       	adc	r31, r9
     d16:	80 81       	ld	r24, Z
     d18:	11 e0       	ldi	r17, 0x01	; 1
     d1a:	88 23       	and	r24, r24
     d1c:	71 f0       	breq	.+28     	; 0xd3a <_Z21task_command_executorPv+0xbe>
     d1e:	10 e0       	ldi	r17, 0x00	; 0
     d20:	0c c0       	rjmp	.+24     	; 0xd3a <_Z21task_command_executorPv+0xbe>
                }else if(_other[i] != _data[i]){
     d22:	fb 01       	movw	r30, r22
     d24:	e8 0d       	add	r30, r8
     d26:	f9 1d       	adc	r31, r9
     d28:	90 81       	ld	r25, Z
     d2a:	98 13       	cpse	r25, r24
     d2c:	05 c0       	rjmp	.+10     	; 0xd38 <_Z21task_command_executorPv+0xbc>
        constexpr  char back() const{
            return _data[_size-1];
        }

        constexpr bool operator == (const char * _other)const{
            for(size_t i=0;i<_size;++i){
     d2e:	6f 5f       	subi	r22, 0xFF	; 255
     d30:	7f 4f       	sbci	r23, 0xFF	; 255
     d32:	e5 cf       	rjmp	.-54     	; 0xcfe <_Z21task_command_executorPv+0x82>
                    return _data[i] == 0;
                }else if(_other[i] != _data[i]){
                    return false;
				}
            }
			 return true;
     d34:	11 e0       	ldi	r17, 0x01	; 1
     d36:	01 c0       	rjmp	.+2      	; 0xd3a <_Z21task_command_executorPv+0xbe>
        constexpr bool operator == (const char * _other)const{
            for(size_t i=0;i<_size;++i){
                if(_other[i] == 0){
                    return _data[i] == 0;
                }else if(_other[i] != _data[i]){
                    return false;
     d38:	10 e0       	ldi	r17, 0x00	; 0
		}
		
		
		
		if(m_command == "get"){
     d3a:	11 23       	and	r17, r17
     d3c:	09 f4       	brne	.+2      	; 0xd40 <_Z21task_command_executorPv+0xc4>
     d3e:	a9 cf       	rjmp	.-174    	; 0xc92 <_Z21task_command_executorPv+0x16>
			char m_params_raw[] = "TempT1oT1cT2oT2c";
			Std::array<const char * ,5> float_params
			(m_params_raw,m_params_raw+4,m_params_raw+4+3,m_params_raw+4+3*2,m_params_raw+4+3*3);
			 
			Std::string_view m_pname = parse_variable(m_string);
     d40:	ce 01       	movw	r24, r28
     d42:	88 56       	subi	r24, 0x68	; 104
     d44:	9f 4f       	sbci	r25, 0xFF	; 255
     d46:	0e 94 4e 03 	call	0x69c	; 0x69c <_Z14parse_variableRN3Std11string_viewE>
     d4a:	fe 01       	movw	r30, r28
     d4c:	ec 56       	subi	r30, 0x6C	; 108
     d4e:	ff 4f       	sbci	r31, 0xFF	; 255
     d50:	60 83       	st	Z, r22
     d52:	71 83       	std	Z+1, r23	; 0x01
     d54:	82 83       	std	Z+2, r24	; 0x02
     d56:	93 83       	std	Z+3, r25	; 0x03
		}
		
		template <typename U>
		inline size_t find(const U & _cmprtr) const{
			const U * _cpm_ptr = &_cmprtr;
			return find_if([_cpm_ptr]
     d58:	7f 01       	movw	r14, r30
			return _data;
		}
		
		template <typename Condition_t>
		inline size_t find_if(Condition_t && m_condition) const{
			for(size_t i=0;i<N;++i){
     d5a:	60 e0       	ldi	r22, 0x00	; 0
     d5c:	70 e0       	ldi	r23, 0x00	; 0
     d5e:	65 30       	cpi	r22, 0x05	; 5
     d60:	71 05       	cpc	r23, r1
     d62:	d0 f5       	brcc	.+116    	; 0xdd8 <_Z21task_command_executorPv+0x15c>
		
		template <typename U>
		inline size_t find(const U & _cmprtr) const{
			const U * _cpm_ptr = &_cmprtr;
			return find_if([_cpm_ptr]
				(const T & _this){return  *_cpm_ptr == _this	;});
     d64:	fb 01       	movw	r30, r22
     d66:	ee 0f       	add	r30, r30
     d68:	ff 1f       	adc	r31, r31
     d6a:	84 e8       	ldi	r24, 0x84	; 132
     d6c:	90 e0       	ldi	r25, 0x00	; 0
     d6e:	8c 0f       	add	r24, r28
     d70:	9d 1f       	adc	r25, r29
     d72:	e8 0f       	add	r30, r24
     d74:	f9 1f       	adc	r31, r25
     d76:	c0 80       	ld	r12, Z
     d78:	d1 80       	ldd	r13, Z+1	; 0x01
     d7a:	d7 01       	movw	r26, r14
        constexpr  char back() const{
            return _data[_size-1];
        }

        constexpr bool operator == (const char * _other)const{
            for(size_t i=0;i<_size;++i){
     d7c:	20 e0       	ldi	r18, 0x00	; 0
     d7e:	30 e0       	ldi	r19, 0x00	; 0
     d80:	12 96       	adiw	r26, 0x02	; 2
     d82:	4d 91       	ld	r20, X+
     d84:	5c 91       	ld	r21, X
     d86:	13 97       	sbiw	r26, 0x03	; 3
     d88:	24 17       	cp	r18, r20
     d8a:	35 07       	cpc	r19, r21
     d8c:	e8 f4       	brcc	.+58     	; 0xdc8 <_Z21task_command_executorPv+0x14c>
                if(_other[i] == 0){
     d8e:	f6 01       	movw	r30, r12
     d90:	e2 0f       	add	r30, r18
     d92:	f3 1f       	adc	r31, r19
     d94:	90 81       	ld	r25, Z
     d96:	91 11       	cpse	r25, r1
     d98:	0c c0       	rjmp	.+24     	; 0xdb2 <_Z21task_command_executorPv+0x136>
                    return _data[i] == 0;
     d9a:	f7 01       	movw	r30, r14
     d9c:	80 81       	ld	r24, Z
     d9e:	91 81       	ldd	r25, Z+1	; 0x01
     da0:	fc 01       	movw	r30, r24
     da2:	e2 0f       	add	r30, r18
     da4:	f3 1f       	adc	r31, r19
     da6:	90 81       	ld	r25, Z
     da8:	81 e0       	ldi	r24, 0x01	; 1
     daa:	99 23       	and	r25, r25
     dac:	81 f0       	breq	.+32     	; 0xdce <_Z21task_command_executorPv+0x152>
     dae:	80 e0       	ldi	r24, 0x00	; 0
     db0:	0e c0       	rjmp	.+28     	; 0xdce <_Z21task_command_executorPv+0x152>
                }else if(_other[i] != _data[i]){
     db2:	ed 91       	ld	r30, X+
     db4:	fc 91       	ld	r31, X
     db6:	11 97       	sbiw	r26, 0x01	; 1
     db8:	e2 0f       	add	r30, r18
     dba:	f3 1f       	adc	r31, r19
     dbc:	80 81       	ld	r24, Z
     dbe:	98 13       	cpse	r25, r24
     dc0:	05 c0       	rjmp	.+10     	; 0xdcc <_Z21task_command_executorPv+0x150>
        constexpr  char back() const{
            return _data[_size-1];
        }

        constexpr bool operator == (const char * _other)const{
            for(size_t i=0;i<_size;++i){
     dc2:	2f 5f       	subi	r18, 0xFF	; 255
     dc4:	3f 4f       	sbci	r19, 0xFF	; 255
     dc6:	dc cf       	rjmp	.-72     	; 0xd80 <_Z21task_command_executorPv+0x104>
                    return _data[i] == 0;
                }else if(_other[i] != _data[i]){
                    return false;
				}
            }
			 return true;
     dc8:	81 2f       	mov	r24, r17
     dca:	01 c0       	rjmp	.+2      	; 0xdce <_Z21task_command_executorPv+0x152>
        constexpr bool operator == (const char * _other)const{
            for(size_t i=0;i<_size;++i){
                if(_other[i] == 0){
                    return _data[i] == 0;
                }else if(_other[i] != _data[i]){
                    return false;
     dcc:	80 e0       	ldi	r24, 0x00	; 0
		}
		
		template <typename Condition_t>
		inline size_t find_if(Condition_t && m_condition) const{
			for(size_t i=0;i<N;++i){
				if(m_condition(_data[i])){
     dce:	81 11       	cpse	r24, r1
     dd0:	06 c0       	rjmp	.+12     	; 0xdde <_Z21task_command_executorPv+0x162>
			return _data;
		}
		
		template <typename Condition_t>
		inline size_t find_if(Condition_t && m_condition) const{
			for(size_t i=0;i<N;++i){
     dd2:	6f 5f       	subi	r22, 0xFF	; 255
     dd4:	7f 4f       	sbci	r23, 0xFF	; 255
     dd6:	c3 cf       	rjmp	.-122    	; 0xd5e <_Z21task_command_executorPv+0xe2>
				if(m_condition(_data[i])){
					return i;
				}
			}
			return N;
     dd8:	85 e0       	ldi	r24, 0x05	; 5
     dda:	90 e0       	ldi	r25, 0x00	; 0
     ddc:	01 c0       	rjmp	.+2      	; 0xde0 <_Z21task_command_executorPv+0x164>
		
		template <typename Condition_t>
		inline size_t find_if(Condition_t && m_condition) const{
			for(size_t i=0;i<N;++i){
				if(m_condition(_data[i])){
					return i;
     dde:	cb 01       	movw	r24, r22
     de0:	7c 01       	movw	r14, r24
     de2:	ff 24       	eor	r15, r15
			uint8_t is_float = float_params.find(m_pname);
			
			if(is_float <float_params.size() ){
     de4:	f5 e0       	ldi	r31, 0x05	; 5
     de6:	ef 16       	cp	r14, r31
     de8:	f1 04       	cpc	r15, r1
     dea:	08 f5       	brcc	.+66     	; 0xe2e <_Z21task_command_executorPv+0x1b2>
				float m_param = get_float_param(static_cast<float_pname>(is_float));
     dec:	0e 94 f8 03 	call	0x7f0	; 0x7f0 <_Z15get_float_param11float_pname>
     df0:	4b 01       	movw	r8, r22
     df2:	5c 01       	movw	r10, r24
				Serial.print(float_params[is_float]);
     df4:	ee 0c       	add	r14, r14
     df6:	ff 1c       	adc	r15, r15
     df8:	e4 e8       	ldi	r30, 0x84	; 132
     dfa:	f0 e0       	ldi	r31, 0x00	; 0
     dfc:	ec 0f       	add	r30, r28
     dfe:	fd 1f       	adc	r31, r29
     e00:	ee 0d       	add	r30, r14
     e02:	ff 1d       	adc	r31, r15
     e04:	60 81       	ld	r22, Z
     e06:	71 81       	ldd	r23, Z+1	; 0x01
     e08:	80 e8       	ldi	r24, 0x80	; 128
     e0a:	98 e0       	ldi	r25, 0x08	; 8
     e0c:	0e 94 8c 18 	call	0x3118	; 0x3118 <_ZN5Print5printEPKc>
				Serial.print(" = ");
     e10:	63 e7       	ldi	r22, 0x73	; 115
     e12:	71 e0       	ldi	r23, 0x01	; 1
     e14:	80 e8       	ldi	r24, 0x80	; 128
     e16:	98 e0       	ldi	r25, 0x08	; 8
     e18:	0e 94 8c 18 	call	0x3118	; 0x3118 <_ZN5Print5printEPKc>
				Serial.println(m_param);
     e1c:	22 e0       	ldi	r18, 0x02	; 2
     e1e:	30 e0       	ldi	r19, 0x00	; 0
     e20:	b5 01       	movw	r22, r10
     e22:	a4 01       	movw	r20, r8
     e24:	80 e8       	ldi	r24, 0x80	; 128
     e26:	98 e0       	ldi	r25, 0x08	; 8
     e28:	0e 94 85 1a 	call	0x350a	; 0x350a <_ZN5Print7printlnEdi>
				goto end_loop;
     e2c:	32 cf       	rjmp	.-412    	; 0xc92 <_Z21task_command_executorPv+0x16>
			return _data;
		}
		
		template <typename Condition_t>
		inline size_t find_if(Condition_t && m_condition) const{
			for(size_t i=0;i<N;++i){
     e2e:	40 e0       	ldi	r20, 0x00	; 0
     e30:	50 e0       	ldi	r21, 0x00	; 0
     e32:	43 30       	cpi	r20, 0x03	; 3
     e34:	51 05       	cpc	r21, r1
     e36:	f0 f5       	brcc	.+124    	; 0xeb4 <_Z21task_command_executorPv+0x238>
		
		template <typename U>
		inline size_t find(const U & _cmprtr) const{
			const U * _cpm_ptr = &_cmprtr;
			return find_if([_cpm_ptr]
				(const T & _this){return  *_cpm_ptr == _this	;});
     e38:	fa 01       	movw	r30, r20
     e3a:	ee 0f       	add	r30, r30
     e3c:	ff 1f       	adc	r31, r31
     e3e:	8e e8       	ldi	r24, 0x8E	; 142
     e40:	90 e0       	ldi	r25, 0x00	; 0
     e42:	8c 0f       	add	r24, r28
     e44:	9d 1f       	adc	r25, r29
     e46:	e8 0f       	add	r30, r24
     e48:	f9 1f       	adc	r31, r25
     e4a:	60 81       	ld	r22, Z
     e4c:	71 81       	ldd	r23, Z+1	; 0x01
     e4e:	de 01       	movw	r26, r28
     e50:	ac 56       	subi	r26, 0x6C	; 108
     e52:	bf 4f       	sbci	r27, 0xFF	; 255
        constexpr  char back() const{
            return _data[_size-1];
        }

        constexpr bool operator == (const char * _other)const{
            for(size_t i=0;i<_size;++i){
     e54:	80 e0       	ldi	r24, 0x00	; 0
     e56:	90 e0       	ldi	r25, 0x00	; 0
     e58:	12 96       	adiw	r26, 0x02	; 2
     e5a:	2d 91       	ld	r18, X+
     e5c:	3c 91       	ld	r19, X
     e5e:	13 97       	sbiw	r26, 0x03	; 3
     e60:	82 17       	cp	r24, r18
     e62:	93 07       	cpc	r25, r19
     e64:	f8 f4       	brcc	.+62     	; 0xea4 <_Z21task_command_executorPv+0x228>
                if(_other[i] == 0){
     e66:	fb 01       	movw	r30, r22
     e68:	e8 0f       	add	r30, r24
     e6a:	f9 1f       	adc	r31, r25
     e6c:	20 81       	ld	r18, Z
     e6e:	21 11       	cpse	r18, r1
     e70:	0f c0       	rjmp	.+30     	; 0xe90 <_Z21task_command_executorPv+0x214>
                    return _data[i] == 0;
     e72:	cc 56       	subi	r28, 0x6C	; 108
     e74:	df 4f       	sbci	r29, 0xFF	; 255
     e76:	28 81       	ld	r18, Y
     e78:	39 81       	ldd	r19, Y+1	; 0x01
     e7a:	c4 59       	subi	r28, 0x94	; 148
     e7c:	d0 40       	sbci	r29, 0x00	; 0
     e7e:	f9 01       	movw	r30, r18
     e80:	e8 0f       	add	r30, r24
     e82:	f9 1f       	adc	r31, r25
     e84:	90 81       	ld	r25, Z
     e86:	81 e0       	ldi	r24, 0x01	; 1
     e88:	99 23       	and	r25, r25
     e8a:	79 f0       	breq	.+30     	; 0xeaa <_Z21task_command_executorPv+0x22e>
     e8c:	80 e0       	ldi	r24, 0x00	; 0
     e8e:	0d c0       	rjmp	.+26     	; 0xeaa <_Z21task_command_executorPv+0x22e>
                }else if(_other[i] != _data[i]){
     e90:	ed 91       	ld	r30, X+
     e92:	fc 91       	ld	r31, X
     e94:	11 97       	sbiw	r26, 0x01	; 1
     e96:	e8 0f       	add	r30, r24
     e98:	f9 1f       	adc	r31, r25
     e9a:	30 81       	ld	r19, Z
     e9c:	23 13       	cpse	r18, r19
     e9e:	04 c0       	rjmp	.+8      	; 0xea8 <_Z21task_command_executorPv+0x22c>
        constexpr  char back() const{
            return _data[_size-1];
        }

        constexpr bool operator == (const char * _other)const{
            for(size_t i=0;i<_size;++i){
     ea0:	01 96       	adiw	r24, 0x01	; 1
     ea2:	da cf       	rjmp	.-76     	; 0xe58 <_Z21task_command_executorPv+0x1dc>
                    return _data[i] == 0;
                }else if(_other[i] != _data[i]){
                    return false;
				}
            }
			 return true;
     ea4:	81 2f       	mov	r24, r17
     ea6:	01 c0       	rjmp	.+2      	; 0xeaa <_Z21task_command_executorPv+0x22e>
        constexpr bool operator == (const char * _other)const{
            for(size_t i=0;i<_size;++i){
                if(_other[i] == 0){
                    return _data[i] == 0;
                }else if(_other[i] != _data[i]){
                    return false;
     ea8:	80 e0       	ldi	r24, 0x00	; 0
		}
		
		template <typename Condition_t>
		inline size_t find_if(Condition_t && m_condition) const{
			for(size_t i=0;i<N;++i){
				if(m_condition(_data[i])){
     eaa:	81 11       	cpse	r24, r1
     eac:	05 c0       	rjmp	.+10     	; 0xeb8 <_Z21task_command_executorPv+0x23c>
			return _data;
		}
		
		template <typename Condition_t>
		inline size_t find_if(Condition_t && m_condition) const{
			for(size_t i=0;i<N;++i){
     eae:	4f 5f       	subi	r20, 0xFF	; 255
     eb0:	5f 4f       	sbci	r21, 0xFF	; 255
     eb2:	bf cf       	rjmp	.-130    	; 0xe32 <_Z21task_command_executorPv+0x1b6>
				if(m_condition(_data[i])){
					return i;
				}
			}
			return N;
     eb4:	43 e0       	ldi	r20, 0x03	; 3
     eb6:	50 e0       	ldi	r21, 0x00	; 0
     eb8:	6a 01       	movw	r12, r20
     eba:	dd 24       	eor	r13, r13
			char m_int_raw[] = "TmdTwdf_cpu";
			Std::array<const char * ,3> int_params
				(m_int_raw,m_int_raw+3,m_int_raw+3*2);

			uint8_t is_int = int_params.find(m_pname);
			if(is_int < int_params.size()){
     ebc:	93 e0       	ldi	r25, 0x03	; 3
     ebe:	c9 16       	cp	r12, r25
     ec0:	d1 04       	cpc	r13, r1
     ec2:	10 f5       	brcc	.+68     	; 0xf08 <_Z21task_command_executorPv+0x28c>
				uint_least32_t m_param = get_uint32_param(static_cast<uint32_pname>(is_float));
     ec4:	c7 01       	movw	r24, r14
     ec6:	0e 94 8e 04 	call	0x91c	; 0x91c <_Z16get_uint32_param12uint32_pname>
     eca:	4b 01       	movw	r8, r22
     ecc:	5c 01       	movw	r10, r24
				Serial.print(int_params[is_int]);
     ece:	cc 0c       	add	r12, r12
     ed0:	dd 1c       	adc	r13, r13
     ed2:	ee e8       	ldi	r30, 0x8E	; 142
     ed4:	f0 e0       	ldi	r31, 0x00	; 0
     ed6:	ec 0f       	add	r30, r28
     ed8:	fd 1f       	adc	r31, r29
     eda:	ec 0d       	add	r30, r12
     edc:	fd 1d       	adc	r31, r13
     ede:	60 81       	ld	r22, Z
     ee0:	71 81       	ldd	r23, Z+1	; 0x01
     ee2:	80 e8       	ldi	r24, 0x80	; 128
     ee4:	98 e0       	ldi	r25, 0x08	; 8
     ee6:	0e 94 8c 18 	call	0x3118	; 0x3118 <_ZN5Print5printEPKc>
				Serial.print(" = ");
     eea:	63 e7       	ldi	r22, 0x73	; 115
     eec:	71 e0       	ldi	r23, 0x01	; 1
     eee:	80 e8       	ldi	r24, 0x80	; 128
     ef0:	98 e0       	ldi	r25, 0x08	; 8
     ef2:	0e 94 8c 18 	call	0x3118	; 0x3118 <_ZN5Print5printEPKc>
				Serial.println(m_param);
     ef6:	2a e0       	ldi	r18, 0x0A	; 10
     ef8:	30 e0       	ldi	r19, 0x00	; 0
     efa:	b5 01       	movw	r22, r10
     efc:	a4 01       	movw	r20, r8
     efe:	80 e8       	ldi	r24, 0x80	; 128
     f00:	98 e0       	ldi	r25, 0x08	; 8
     f02:	0e 94 88 19 	call	0x3310	; 0x3310 <_ZN5Print7printlnEmi>
				goto end_loop;
     f06:	c5 ce       	rjmp	.-630    	; 0xc92 <_Z21task_command_executorPv+0x16>
     f08:	80 e0       	ldi	r24, 0x00	; 0
     f0a:	90 e0       	ldi	r25, 0x00	; 0
        constexpr  char back() const{
            return _data[_size-1];
        }

        constexpr bool operator == (const char * _other)const{
            for(size_t i=0;i<_size;++i){
     f0c:	ca 56       	subi	r28, 0x6A	; 106
     f0e:	df 4f       	sbci	r29, 0xFF	; 255
     f10:	28 81       	ld	r18, Y
     f12:	39 81       	ldd	r19, Y+1	; 0x01
     f14:	c6 59       	subi	r28, 0x96	; 150
     f16:	d0 40       	sbci	r29, 0x00	; 0
     f18:	82 17       	cp	r24, r18
     f1a:	93 07       	cpc	r25, r19
     f1c:	10 f5       	brcc	.+68     	; 0xf62 <_Z21task_command_executorPv+0x2e6>
                if(_other[i] == 0){
     f1e:	fc 01       	movw	r30, r24
     f20:	e7 59       	subi	r30, 0x97	; 151
     f22:	fe 4f       	sbci	r31, 0xFE	; 254
     f24:	40 81       	ld	r20, Z
     f26:	41 11       	cpse	r20, r1
     f28:	0f c0       	rjmp	.+30     	; 0xf48 <_Z21task_command_executorPv+0x2cc>
                    return _data[i] == 0;
     f2a:	cc 56       	subi	r28, 0x6C	; 108
     f2c:	df 4f       	sbci	r29, 0xFF	; 255
     f2e:	48 81       	ld	r20, Y
     f30:	59 81       	ldd	r21, Y+1	; 0x01
     f32:	c4 59       	subi	r28, 0x94	; 148
     f34:	d0 40       	sbci	r29, 0x00	; 0
     f36:	fa 01       	movw	r30, r20
     f38:	e8 0f       	add	r30, r24
     f3a:	f9 1f       	adc	r31, r25
     f3c:	80 81       	ld	r24, Z
     f3e:	61 e0       	ldi	r22, 0x01	; 1
     f40:	88 23       	and	r24, r24
     f42:	91 f0       	breq	.+36     	; 0xf68 <_Z21task_command_executorPv+0x2ec>
     f44:	60 e0       	ldi	r22, 0x00	; 0
     f46:	10 c0       	rjmp	.+32     	; 0xf68 <_Z21task_command_executorPv+0x2ec>
                }else if(_other[i] != _data[i]){
     f48:	cc 56       	subi	r28, 0x6C	; 108
     f4a:	df 4f       	sbci	r29, 0xFF	; 255
     f4c:	e8 81       	ld	r30, Y
     f4e:	f9 81       	ldd	r31, Y+1	; 0x01
     f50:	c4 59       	subi	r28, 0x94	; 148
     f52:	d0 40       	sbci	r29, 0x00	; 0
     f54:	e8 0f       	add	r30, r24
     f56:	f9 1f       	adc	r31, r25
     f58:	50 81       	ld	r21, Z
     f5a:	45 13       	cpse	r20, r21
     f5c:	04 c0       	rjmp	.+8      	; 0xf66 <_Z21task_command_executorPv+0x2ea>
        constexpr  char back() const{
            return _data[_size-1];
        }

        constexpr bool operator == (const char * _other)const{
            for(size_t i=0;i<_size;++i){
     f5e:	01 96       	adiw	r24, 0x01	; 1
     f60:	d5 cf       	rjmp	.-86     	; 0xf0c <_Z21task_command_executorPv+0x290>
                    return _data[i] == 0;
                }else if(_other[i] != _data[i]){
                    return false;
				}
            }
			 return true;
     f62:	61 2f       	mov	r22, r17
     f64:	01 c0       	rjmp	.+2      	; 0xf68 <_Z21task_command_executorPv+0x2ec>
        constexpr bool operator == (const char * _other)const{
            for(size_t i=0;i<_size;++i){
                if(_other[i] == 0){
                    return _data[i] == 0;
                }else if(_other[i] != _data[i]){
                    return false;
     f66:	60 e0       	ldi	r22, 0x00	; 0
			}
			if(m_pname == "clock"){
     f68:	66 23       	and	r22, r22
     f6a:	09 f4       	brne	.+2      	; 0xf6e <_Z21task_command_executorPv+0x2f2>
     f6c:	67 c0       	rjmp	.+206    	; 0x103c <_Z21task_command_executorPv+0x3c0>
				Serial.print("Time = ");
     f6e:	6f e6       	ldi	r22, 0x6F	; 111
     f70:	71 e0       	ldi	r23, 0x01	; 1
     f72:	80 e8       	ldi	r24, 0x80	; 128
     f74:	98 e0       	ldi	r25, 0x08	; 8
     f76:	0e 94 8c 18 	call	0x3118	; 0x3118 <_ZN5Print5printEPKc>
struct guard_timer0{
	mutex m;
	inline guard_timer0(){}
	
	inline void lock(){
		TIMSK0 = 0;
     f7a:	0e e6       	ldi	r16, 0x6E	; 110
     f7c:	10 e0       	ldi	r17, 0x00	; 0
     f7e:	f8 01       	movw	r30, r16
     f80:	10 82       	st	Z, r1
#include "../../FreeRTOS/semphr.h"

struct mutex{
	SemaphoreHandle_t xMutex;
	void lock(){
		xSemaphoreTake(xMutex, portMAX_DELAY);
     f82:	0f 2e       	mov	r0, r31
     f84:	fe ed       	ldi	r31, 0xDE	; 222
     f86:	ef 2e       	mov	r14, r31
     f88:	f1 e0       	ldi	r31, 0x01	; 1
     f8a:	ff 2e       	mov	r15, r31
     f8c:	f0 2d       	mov	r31, r0
     f8e:	20 e0       	ldi	r18, 0x00	; 0
     f90:	4f ef       	ldi	r20, 0xFF	; 255
     f92:	5f ef       	ldi	r21, 0xFF	; 255
     f94:	60 e0       	ldi	r22, 0x00	; 0
     f96:	70 e0       	ldi	r23, 0x00	; 0
     f98:	f7 01       	movw	r30, r14
     f9a:	87 a5       	ldd	r24, Z+47	; 0x2f
     f9c:	90 a9       	ldd	r25, Z+48	; 0x30
     f9e:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <xQueueGenericReceive>
				print_clock(clocks.get([](Clocks const & clk){return clk.current();}));
     fa2:	87 e0       	ldi	r24, 0x07	; 7
     fa4:	f7 01       	movw	r30, r14
     fa6:	de 01       	movw	r26, r28
     fa8:	1f 96       	adiw	r26, 0x0f	; 15
     faa:	01 90       	ld	r0, Z+
     fac:	0d 92       	st	X+, r0
     fae:	8a 95       	dec	r24
     fb0:	e1 f7       	brne	.-8      	; 0xfaa <_Z21task_command_executorPv+0x32e>
     fb2:	87 e0       	ldi	r24, 0x07	; 7
     fb4:	fe 01       	movw	r30, r28
     fb6:	3f 96       	adiw	r30, 0x0f	; 15
     fb8:	de 01       	movw	r26, r28
     fba:	18 96       	adiw	r26, 0x08	; 8
     fbc:	01 90       	ld	r0, Z+
     fbe:	0d 92       	st	X+, r0
     fc0:	8a 95       	dec	r24
     fc2:	e1 f7       	brne	.-8      	; 0xfbc <_Z21task_command_executorPv+0x340>
	
	
	template <typename Func_t>
	inline auto get(Func_t && F) const{
		lock();
		auto m_value = F(value);
     fc4:	87 e0       	ldi	r24, 0x07	; 7
     fc6:	fe 01       	movw	r30, r28
     fc8:	38 96       	adiw	r30, 0x08	; 8
     fca:	de 01       	movw	r26, r28
     fcc:	ac 59       	subi	r26, 0x9C	; 156
     fce:	bf 4f       	sbci	r27, 0xFF	; 255
     fd0:	01 90       	ld	r0, Z+
     fd2:	0d 92       	st	X+, r0
     fd4:	8a 95       	dec	r24
     fd6:	e1 f7       	brne	.-8      	; 0xfd0 <_Z21task_command_executorPv+0x354>
	SemaphoreHandle_t xMutex;
	void lock(){
		xSemaphoreTake(xMutex, portMAX_DELAY);
	};
	void unlock(){
		xSemaphoreGive(xMutex);
     fd8:	20 e0       	ldi	r18, 0x00	; 0
     fda:	40 e0       	ldi	r20, 0x00	; 0
     fdc:	50 e0       	ldi	r21, 0x00	; 0
     fde:	60 e0       	ldi	r22, 0x00	; 0
     fe0:	70 e0       	ldi	r23, 0x00	; 0
     fe2:	f7 01       	movw	r30, r14
     fe4:	87 a5       	ldd	r24, Z+47	; 0x2f
     fe6:	90 a9       	ldd	r25, Z+48	; 0x30
     fe8:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <xQueueGenericSend>
		TIMSK0 = 0;
		m.lock();
	}
	inline void unlock(){
		m.unlock();
		TIMSK0 = 1<<TOIE0;
     fec:	81 e0       	ldi	r24, 0x01	; 1
     fee:	f8 01       	movw	r30, r16
     ff0:	80 83       	st	Z, r24
	template <typename Func_t>
	inline auto get(Func_t && F) const{
		lock();
		auto m_value = F(value);
		unlock();
		return m_value;
     ff2:	87 e0       	ldi	r24, 0x07	; 7
     ff4:	fe 01       	movw	r30, r28
     ff6:	ec 59       	subi	r30, 0x9C	; 156
     ff8:	ff 4f       	sbci	r31, 0xFF	; 255
     ffa:	de 01       	movw	r26, r28
     ffc:	11 96       	adiw	r26, 0x01	; 1
     ffe:	01 90       	ld	r0, Z+
    1000:	0d 92       	st	X+, r0
    1002:	8a 95       	dec	r24
    1004:	e1 f7       	brne	.-8      	; 0xffe <_Z21task_command_executorPv+0x382>
    1006:	87 e0       	ldi	r24, 0x07	; 7
    1008:	fe 01       	movw	r30, r28
    100a:	31 96       	adiw	r30, 0x01	; 1
    100c:	de 01       	movw	r26, r28
    100e:	56 96       	adiw	r26, 0x16	; 22
    1010:	01 90       	ld	r0, Z+
    1012:	0d 92       	st	X+, r0
    1014:	8a 95       	dec	r24
    1016:	e1 f7       	brne	.-8      	; 0x1010 <_Z21task_command_executorPv+0x394>
    1018:	87 e0       	ldi	r24, 0x07	; 7
    101a:	fe 01       	movw	r30, r28
    101c:	76 96       	adiw	r30, 0x16	; 22
    101e:	de 01       	movw	r26, r28
    1020:	5d 96       	adiw	r26, 0x1d	; 29
    1022:	01 90       	ld	r0, Z+
    1024:	0d 92       	st	X+, r0
    1026:	8a 95       	dec	r24
    1028:	e1 f7       	brne	.-8      	; 0x1022 <_Z21task_command_executorPv+0x3a6>
    102a:	ce 01       	movw	r24, r28
    102c:	4d 96       	adiw	r24, 0x1d	; 29
    102e:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <_Z11print_clockRK11hh_mm_ss_dd>
				Serial.println();
    1032:	80 e8       	ldi	r24, 0x80	; 128
    1034:	98 e0       	ldi	r25, 0x08	; 8
    1036:	0e 94 aa 18 	call	0x3154	; 0x3154 <_ZN5Print7printlnEv>
				goto end_loop;
    103a:	2b ce       	rjmp	.-938    	; 0xc92 <_Z21task_command_executorPv+0x16>
    103c:	80 e0       	ldi	r24, 0x00	; 0
    103e:	90 e0       	ldi	r25, 0x00	; 0
        constexpr  char back() const{
            return _data[_size-1];
        }

        constexpr bool operator == (const char * _other)const{
            for(size_t i=0;i<_size;++i){
    1040:	82 17       	cp	r24, r18
    1042:	93 07       	cpc	r25, r19
    1044:	10 f5       	brcc	.+68     	; 0x108a <_Z21task_command_executorPv+0x40e>
                if(_other[i] == 0){
    1046:	fc 01       	movw	r30, r24
    1048:	e9 58       	subi	r30, 0x89	; 137
    104a:	fe 4f       	sbci	r31, 0xFE	; 254
    104c:	40 81       	ld	r20, Z
    104e:	41 11       	cpse	r20, r1
    1050:	0f c0       	rjmp	.+30     	; 0x1070 <_Z21task_command_executorPv+0x3f4>
                    return _data[i] == 0;
    1052:	cc 56       	subi	r28, 0x6C	; 108
    1054:	df 4f       	sbci	r29, 0xFF	; 255
    1056:	48 81       	ld	r20, Y
    1058:	59 81       	ldd	r21, Y+1	; 0x01
    105a:	c4 59       	subi	r28, 0x94	; 148
    105c:	d0 40       	sbci	r29, 0x00	; 0
    105e:	fa 01       	movw	r30, r20
    1060:	e8 0f       	add	r30, r24
    1062:	f9 1f       	adc	r31, r25
    1064:	80 81       	ld	r24, Z
    1066:	61 e0       	ldi	r22, 0x01	; 1
    1068:	88 23       	and	r24, r24
    106a:	81 f0       	breq	.+32     	; 0x108c <_Z21task_command_executorPv+0x410>
    106c:	60 e0       	ldi	r22, 0x00	; 0
    106e:	0e c0       	rjmp	.+28     	; 0x108c <_Z21task_command_executorPv+0x410>
                }else if(_other[i] != _data[i]){
    1070:	cc 56       	subi	r28, 0x6C	; 108
    1072:	df 4f       	sbci	r29, 0xFF	; 255
    1074:	e8 81       	ld	r30, Y
    1076:	f9 81       	ldd	r31, Y+1	; 0x01
    1078:	c4 59       	subi	r28, 0x94	; 148
    107a:	d0 40       	sbci	r29, 0x00	; 0
    107c:	e8 0f       	add	r30, r24
    107e:	f9 1f       	adc	r31, r25
    1080:	50 81       	ld	r21, Z
    1082:	45 13       	cpse	r20, r21
    1084:	03 c0       	rjmp	.+6      	; 0x108c <_Z21task_command_executorPv+0x410>
        constexpr  char back() const{
            return _data[_size-1];
        }

        constexpr bool operator == (const char * _other)const{
            for(size_t i=0;i<_size;++i){
    1086:	01 96       	adiw	r24, 0x01	; 1
    1088:	db cf       	rjmp	.-74     	; 0x1040 <_Z21task_command_executorPv+0x3c4>
                    return _data[i] == 0;
                }else if(_other[i] != _data[i]){
                    return false;
				}
            }
			 return true;
    108a:	61 2f       	mov	r22, r17
			}
			if(m_pname == "plan"){
    108c:	66 23       	and	r22, r22
    108e:	19 f0       	breq	.+6      	; 0x1096 <_Z21task_command_executorPv+0x41a>
				print_plan();
    1090:	0e 94 68 05 	call	0xad0	; 0xad0 <_Z10print_planv>
				goto end_loop;
    1094:	fe cd       	rjmp	.-1028   	; 0xc92 <_Z21task_command_executorPv+0x16>
    1096:	80 e0       	ldi	r24, 0x00	; 0
    1098:	90 e0       	ldi	r25, 0x00	; 0
        constexpr  char back() const{
            return _data[_size-1];
        }

        constexpr bool operator == (const char * _other)const{
            for(size_t i=0;i<_size;++i){
    109a:	82 17       	cp	r24, r18
    109c:	93 07       	cpc	r25, r19
    109e:	18 f5       	brcc	.+70     	; 0x10e6 <_Z21task_command_executorPv+0x46a>
                if(_other[i] == 0){
    10a0:	fc 01       	movw	r30, r24
    10a2:	e4 58       	subi	r30, 0x84	; 132
    10a4:	fe 4f       	sbci	r31, 0xFE	; 254
    10a6:	40 81       	ld	r20, Z
    10a8:	41 11       	cpse	r20, r1
    10aa:	0f c0       	rjmp	.+30     	; 0x10ca <_Z21task_command_executorPv+0x44e>
                    return _data[i] == 0;
    10ac:	cc 56       	subi	r28, 0x6C	; 108
    10ae:	df 4f       	sbci	r29, 0xFF	; 255
    10b0:	28 81       	ld	r18, Y
    10b2:	39 81       	ldd	r19, Y+1	; 0x01
    10b4:	c4 59       	subi	r28, 0x94	; 148
    10b6:	d0 40       	sbci	r29, 0x00	; 0
    10b8:	f9 01       	movw	r30, r18
    10ba:	e8 0f       	add	r30, r24
    10bc:	f9 1f       	adc	r31, r25
    10be:	80 81       	ld	r24, Z
    10c0:	11 e0       	ldi	r17, 0x01	; 1
    10c2:	88 23       	and	r24, r24
    10c4:	81 f0       	breq	.+32     	; 0x10e6 <_Z21task_command_executorPv+0x46a>
    10c6:	10 e0       	ldi	r17, 0x00	; 0
    10c8:	0e c0       	rjmp	.+28     	; 0x10e6 <_Z21task_command_executorPv+0x46a>
                }else if(_other[i] != _data[i]){
    10ca:	cc 56       	subi	r28, 0x6C	; 108
    10cc:	df 4f       	sbci	r29, 0xFF	; 255
    10ce:	e8 81       	ld	r30, Y
    10d0:	f9 81       	ldd	r31, Y+1	; 0x01
    10d2:	c4 59       	subi	r28, 0x94	; 148
    10d4:	d0 40       	sbci	r29, 0x00	; 0
    10d6:	e8 0f       	add	r30, r24
    10d8:	f9 1f       	adc	r31, r25
    10da:	50 81       	ld	r21, Z
    10dc:	45 13       	cpse	r20, r21
    10de:	02 c0       	rjmp	.+4      	; 0x10e4 <_Z21task_command_executorPv+0x468>
        constexpr  char back() const{
            return _data[_size-1];
        }

        constexpr bool operator == (const char * _other)const{
            for(size_t i=0;i<_size;++i){
    10e0:	01 96       	adiw	r24, 0x01	; 1
    10e2:	db cf       	rjmp	.-74     	; 0x109a <_Z21task_command_executorPv+0x41e>
                if(_other[i] == 0){
                    return _data[i] == 0;
                }else if(_other[i] != _data[i]){
                    return false;
    10e4:	16 2f       	mov	r17, r22
			}
			if(m_pname == "every"){
    10e6:	11 23       	and	r17, r17
    10e8:	19 f0       	breq	.+6      	; 0x10f0 <_Z21task_command_executorPv+0x474>
				print_every();
    10ea:	0e 94 c2 05 	call	0xb84	; 0xb84 <_Z11print_everyv>
				goto end_loop;
    10ee:	d1 cd       	rjmp	.-1118   	; 0xc92 <_Z21task_command_executorPv+0x16>
			}
			{
				char error_code[] = "unknown argument of command get";
    10f0:	80 e2       	ldi	r24, 0x20	; 32
    10f2:	e8 e9       	ldi	r30, 0x98	; 152
    10f4:	f1 e0       	ldi	r31, 0x01	; 1
    10f6:	de 01       	movw	r26, r28
    10f8:	ac 59       	subi	r26, 0x9C	; 156
    10fa:	bf 4f       	sbci	r27, 0xFF	; 255
    10fc:	01 90       	ld	r0, Z+
    10fe:	0d 92       	st	X+, r0
    1100:	8a 95       	dec	r24
    1102:	e1 f7       	brne	.-8      	; 0x10fc <_Z21task_command_executorPv+0x480>
				Serial.println(error_code);
    1104:	be 01       	movw	r22, r28
    1106:	6c 59       	subi	r22, 0x9C	; 156
    1108:	7f 4f       	sbci	r23, 0xFF	; 255
    110a:	80 e8       	ldi	r24, 0x80	; 128
    110c:	98 e0       	ldi	r25, 0x08	; 8
    110e:	0e 94 b6 18 	call	0x316c	; 0x316c <_ZN5Print7printlnEPKc>
void print_clock(hh_mm_ss_dd const & m_time);

void task_command_executor(void *){
	constexpr uint8_t max_buf_size = 64;
	char strbuf[max_buf_size];
	while(1){
    1112:	bf cd       	rjmp	.-1154   	; 0xc92 <_Z21task_command_executorPv+0x16>

00001114 <_Z18NextDayUpdatePlansv>:
#include "global.h"
#include "Pump.h"

void NextDayUpdatePlans(){
    1114:	cf 92       	push	r12
    1116:	df 92       	push	r13
    1118:	ef 92       	push	r14
    111a:	ff 92       	push	r15
    111c:	cf 93       	push	r28
    111e:	df 93       	push	r29
#include "../../FreeRTOS/semphr.h"

struct mutex{
	SemaphoreHandle_t xMutex;
	void lock(){
		xSemaphoreTake(xMutex, portMAX_DELAY);
    1120:	c1 e3       	ldi	r28, 0x31	; 49
    1122:	d2 e0       	ldi	r29, 0x02	; 2
    1124:	20 e0       	ldi	r18, 0x00	; 0
    1126:	4f ef       	ldi	r20, 0xFF	; 255
    1128:	5f ef       	ldi	r21, 0xFF	; 255
    112a:	60 e0       	ldi	r22, 0x00	; 0
    112c:	70 e0       	ldi	r23, 0x00	; 0
    112e:	8a 81       	ldd	r24, Y+2	; 0x02
    1130:	9b 81       	ldd	r25, Y+3	; 0x03
    1132:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <xQueueGenericReceive>
	template <typename Func_t,
		Std::enable_if_same_t<Std::invoke_result_t<Func_t,T &>,void,bool> = true>
	inline void apply(Func_t && F){
		//static_assert(Std::is_same_v<Std::invoke_result_t<Func_t,T &>,void>,"not void function in void spec");
		lock();
		F(value);
    1136:	48 81       	ld	r20, Y
    1138:	59 81       	ldd	r21, Y+1	; 0x01
	water_plan.apply([](water_plan_array_t & plan){
			for(uint_least8_t i=0;i<plan.size();++i){
    113a:	80 e0       	ldi	r24, 0x00	; 0
    113c:	88 30       	cpi	r24, 0x08	; 8
    113e:	80 f5       	brcc	.+96     	; 0x11a0 <_Z18NextDayUpdatePlansv+0x8c>
				if(plan[i].actual){
    1140:	28 2f       	mov	r18, r24
    1142:	30 e0       	ldi	r19, 0x00	; 0
    1144:	9d e0       	ldi	r25, 0x0D	; 13
    1146:	92 9f       	mul	r25, r18
    1148:	f0 01       	movw	r30, r0
    114a:	93 9f       	mul	r25, r19
    114c:	f0 0d       	add	r31, r0
    114e:	11 24       	eor	r1, r1
    1150:	e4 0f       	add	r30, r20
    1152:	f5 1f       	adc	r31, r21
    1154:	90 81       	ld	r25, Z
    1156:	99 23       	and	r25, r25
    1158:	09 f1       	breq	.+66     	; 0x119c <_Z18NextDayUpdatePlansv+0x88>
        ptime.mm=_mm;
        ptime.ss=_ss;
        ptime.days= _days_delay;
    }
    void next_day(){
        if(ptime.days > 0)
    115a:	9d e0       	ldi	r25, 0x0D	; 13
    115c:	92 9f       	mul	r25, r18
    115e:	f0 01       	movw	r30, r0
    1160:	93 9f       	mul	r25, r19
    1162:	f0 0d       	add	r31, r0
    1164:	11 24       	eor	r1, r1
    1166:	e4 0f       	add	r30, r20
    1168:	f5 1f       	adc	r31, r21
    116a:	c5 80       	ldd	r12, Z+5	; 0x05
    116c:	d6 80       	ldd	r13, Z+6	; 0x06
    116e:	e7 80       	ldd	r14, Z+7	; 0x07
    1170:	f0 84       	ldd	r15, Z+8	; 0x08
    1172:	c1 14       	cp	r12, r1
    1174:	d1 04       	cpc	r13, r1
    1176:	e1 04       	cpc	r14, r1
    1178:	f1 04       	cpc	r15, r1
    117a:	81 f0       	breq	.+32     	; 0x119c <_Z18NextDayUpdatePlansv+0x88>
            ptime.days--;
    117c:	92 9f       	mul	r25, r18
    117e:	f0 01       	movw	r30, r0
    1180:	93 9f       	mul	r25, r19
    1182:	f0 0d       	add	r31, r0
    1184:	11 24       	eor	r1, r1
    1186:	e4 0f       	add	r30, r20
    1188:	f5 1f       	adc	r31, r21
    118a:	91 e0       	ldi	r25, 0x01	; 1
    118c:	c9 1a       	sub	r12, r25
    118e:	d1 08       	sbc	r13, r1
    1190:	e1 08       	sbc	r14, r1
    1192:	f1 08       	sbc	r15, r1
    1194:	c5 82       	std	Z+5, r12	; 0x05
    1196:	d6 82       	std	Z+6, r13	; 0x06
    1198:	e7 82       	std	Z+7, r14	; 0x07
    119a:	f0 86       	std	Z+8, r15	; 0x08
#include "global.h"
#include "Pump.h"

void NextDayUpdatePlans(){
	water_plan.apply([](water_plan_array_t & plan){
			for(uint_least8_t i=0;i<plan.size();++i){
    119c:	8f 5f       	subi	r24, 0xFF	; 255
    119e:	ce cf       	rjmp	.-100    	; 0x113c <_Z18NextDayUpdatePlansv+0x28>
	SemaphoreHandle_t xMutex;
	void lock(){
		xSemaphoreTake(xMutex, portMAX_DELAY);
	};
	void unlock(){
		xSemaphoreGive(xMutex);
    11a0:	20 e0       	ldi	r18, 0x00	; 0
    11a2:	40 e0       	ldi	r20, 0x00	; 0
    11a4:	50 e0       	ldi	r21, 0x00	; 0
    11a6:	60 e0       	ldi	r22, 0x00	; 0
    11a8:	70 e0       	ldi	r23, 0x00	; 0
    11aa:	80 91 33 02 	lds	r24, 0x0233	; 0x800233 <water_plan+0x2>
    11ae:	90 91 34 02 	lds	r25, 0x0234	; 0x800234 <water_plan+0x3>
    11b2:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <xQueueGenericSend>
#include "../../FreeRTOS/semphr.h"

struct mutex{
	SemaphoreHandle_t xMutex;
	void lock(){
		xSemaphoreTake(xMutex, portMAX_DELAY);
    11b6:	cd e2       	ldi	r28, 0x2D	; 45
    11b8:	d2 e0       	ldi	r29, 0x02	; 2
    11ba:	20 e0       	ldi	r18, 0x00	; 0
    11bc:	4f ef       	ldi	r20, 0xFF	; 255
    11be:	5f ef       	ldi	r21, 0xFF	; 255
    11c0:	60 e0       	ldi	r22, 0x00	; 0
    11c2:	70 e0       	ldi	r23, 0x00	; 0
    11c4:	8a 81       	ldd	r24, Y+2	; 0x02
    11c6:	9b 81       	ldd	r25, Y+3	; 0x03
    11c8:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <xQueueGenericReceive>
	template <typename Func_t,
		Std::enable_if_same_t<Std::invoke_result_t<Func_t,T &>,void,bool> = true>
	inline void apply(Func_t && F){
		//static_assert(Std::is_same_v<Std::invoke_result_t<Func_t,T &>,void>,"not void function in void spec");
		lock();
		F(value);
    11cc:	68 81       	ld	r22, Y
    11ce:	79 81       	ldd	r23, Y+1	; 0x01
				}
			}
		});
	
	water_every.apply([](water_every_array_t & every){
		for(uint_least8_t i=0;i<every.size();++i){
    11d0:	40 e0       	ldi	r20, 0x00	; 0
    11d2:	44 30       	cpi	r20, 0x04	; 4
    11d4:	28 f5       	brcc	.+74     	; 0x1220 <_Z18NextDayUpdatePlansv+0x10c>
			if(every[i].exist_flag){
    11d6:	84 2f       	mov	r24, r20
    11d8:	90 e0       	ldi	r25, 0x00	; 0
    11da:	fc 01       	movw	r30, r24
    11dc:	ee 0f       	add	r30, r30
    11de:	ff 1f       	adc	r31, r31
    11e0:	9c 01       	movw	r18, r24
    11e2:	22 0f       	add	r18, r18
    11e4:	33 1f       	adc	r19, r19
    11e6:	22 0f       	add	r18, r18
    11e8:	33 1f       	adc	r19, r19
    11ea:	22 0f       	add	r18, r18
    11ec:	33 1f       	adc	r19, r19
    11ee:	e2 0f       	add	r30, r18
    11f0:	f3 1f       	adc	r31, r19
    11f2:	e6 0f       	add	r30, r22
    11f4:	f7 1f       	adc	r31, r23
    11f6:	20 81       	ld	r18, Z
    11f8:	22 23       	and	r18, r18
    11fa:	81 f0       	breq	.+32     	; 0x121c <_Z18NextDayUpdatePlansv+0x108>
        ss=_ss;
        days_delay = _days_delay > 0 ? _days_delay : 1;
        tmp_delayed_days = 0;
    }
    void next_day(){
        tmp_delayed_days++;
    11fc:	fc 01       	movw	r30, r24
    11fe:	ee 0f       	add	r30, r30
    1200:	ff 1f       	adc	r31, r31
    1202:	88 0f       	add	r24, r24
    1204:	99 1f       	adc	r25, r25
    1206:	88 0f       	add	r24, r24
    1208:	99 1f       	adc	r25, r25
    120a:	88 0f       	add	r24, r24
    120c:	99 1f       	adc	r25, r25
    120e:	e8 0f       	add	r30, r24
    1210:	f9 1f       	adc	r31, r25
    1212:	e6 0f       	add	r30, r22
    1214:	f7 1f       	adc	r31, r23
    1216:	82 81       	ldd	r24, Z+2	; 0x02
    1218:	8f 5f       	subi	r24, 0xFF	; 255
    121a:	82 83       	std	Z+2, r24	; 0x02
				}
			}
		});
	
	water_every.apply([](water_every_array_t & every){
		for(uint_least8_t i=0;i<every.size();++i){
    121c:	4f 5f       	subi	r20, 0xFF	; 255
    121e:	d9 cf       	rjmp	.-78     	; 0x11d2 <_Z18NextDayUpdatePlansv+0xbe>
	SemaphoreHandle_t xMutex;
	void lock(){
		xSemaphoreTake(xMutex, portMAX_DELAY);
	};
	void unlock(){
		xSemaphoreGive(xMutex);
    1220:	20 e0       	ldi	r18, 0x00	; 0
    1222:	40 e0       	ldi	r20, 0x00	; 0
    1224:	50 e0       	ldi	r21, 0x00	; 0
    1226:	60 e0       	ldi	r22, 0x00	; 0
    1228:	70 e0       	ldi	r23, 0x00	; 0
    122a:	80 91 2f 02 	lds	r24, 0x022F	; 0x80022f <water_every+0x2>
    122e:	90 91 30 02 	lds	r25, 0x0230	; 0x800230 <water_every+0x3>
    1232:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <xQueueGenericSend>
			if(every[i].exist_flag){
				every[i].next_day();
			}
		}
	});
}
    1236:	df 91       	pop	r29
    1238:	cf 91       	pop	r28
    123a:	ff 90       	pop	r15
    123c:	ef 90       	pop	r14
    123e:	df 90       	pop	r13
    1240:	cf 90       	pop	r12
    1242:	08 95       	ret

00001244 <_Z13water_processRK11hh_mm_ss_ddm>:

hh_mm_ss_dd water_process(hh_mm_ss_dd const &current,uint32_t water_seconds_duration){
    1244:	2f 92       	push	r2
    1246:	3f 92       	push	r3
    1248:	4f 92       	push	r4
    124a:	5f 92       	push	r5
    124c:	6f 92       	push	r6
    124e:	7f 92       	push	r7
    1250:	8f 92       	push	r8
    1252:	9f 92       	push	r9
    1254:	af 92       	push	r10
    1256:	bf 92       	push	r11
    1258:	cf 92       	push	r12
    125a:	df 92       	push	r13
    125c:	ef 92       	push	r14
    125e:	ff 92       	push	r15
    1260:	0f 93       	push	r16
    1262:	1f 93       	push	r17
    1264:	cf 93       	push	r28
    1266:	df 93       	push	r29
    1268:	cd b7       	in	r28, 0x3d	; 61
    126a:	de b7       	in	r29, 0x3e	; 62
    126c:	e1 97       	sbiw	r28, 0x31	; 49
    126e:	0f b6       	in	r0, 0x3f	; 63
    1270:	f8 94       	cli
    1272:	de bf       	out	0x3e, r29	; 62
    1274:	0f be       	out	0x3f, r0	; 63
    1276:	cd bf       	out	0x3d, r28	; 61
    1278:	fc 01       	movw	r30, r24
	hh_mm_ss_dd stop_time = current + water_seconds_duration;
    127a:	1a 01       	movw	r2, r20
    127c:	2b 01       	movw	r4, r22
		
		days += msecs;
		return *this;
	}
	inline hh_mm_ss_dd operator + (uint_least64_t msecs)const{
		hh_mm_ss_dd ret = *this;
    127e:	97 e0       	ldi	r25, 0x07	; 7
    1280:	de 01       	movw	r26, r28
    1282:	9b 96       	adiw	r26, 0x2b	; 43
    1284:	01 90       	ld	r0, Z+
    1286:	0d 92       	st	X+, r0
    1288:	9a 95       	dec	r25
    128a:	e1 f7       	brne	.-8      	; 0x1284 <_Z13water_processRK11hh_mm_ss_ddm+0x40>
	inline bool operator <=(hh_mm_ss_dd const & other) const{
		return other >= *this;
	}
	
	inline hh_mm_ss_dd & operator += (uint_least64_t msecs){
		msecs += ss;
    128c:	2d a5       	ldd	r18, Y+45	; 0x2d
    128e:	30 e0       	ldi	r19, 0x00	; 0
    1290:	40 e0       	ldi	r20, 0x00	; 0
    1292:	50 e0       	ldi	r21, 0x00	; 0
    1294:	60 e0       	ldi	r22, 0x00	; 0
    1296:	70 e0       	ldi	r23, 0x00	; 0
    1298:	80 e0       	ldi	r24, 0x00	; 0
    129a:	90 e0       	ldi	r25, 0x00	; 0
    129c:	a2 2c       	mov	r10, r2
    129e:	b3 2c       	mov	r11, r3
    12a0:	c4 2c       	mov	r12, r4
    12a2:	d5 2c       	mov	r13, r5
    12a4:	e1 2c       	mov	r14, r1
    12a6:	f1 2c       	mov	r15, r1
    12a8:	00 e0       	ldi	r16, 0x00	; 0
    12aa:	10 e0       	ldi	r17, 0x00	; 0
    12ac:	0e 94 de 1c 	call	0x39bc	; 0x39bc <__adddi3>
    12b0:	22 2e       	mov	r2, r18
    12b2:	33 2e       	mov	r3, r19
    12b4:	44 2e       	mov	r4, r20
    12b6:	55 2e       	mov	r5, r21
    12b8:	66 2e       	mov	r6, r22
    12ba:	77 2e       	mov	r7, r23
    12bc:	88 2e       	mov	r8, r24
    12be:	99 2e       	mov	r9, r25
		ss = msecs % 60;
    12c0:	0f 2e       	mov	r0, r31
    12c2:	fc e3       	ldi	r31, 0x3C	; 60
    12c4:	af 2e       	mov	r10, r31
    12c6:	f0 2d       	mov	r31, r0
    12c8:	b1 2c       	mov	r11, r1
    12ca:	c1 2c       	mov	r12, r1
    12cc:	d1 2c       	mov	r13, r1
    12ce:	0e 94 7f 1c 	call	0x38fe	; 0x38fe <__umoddi3>
    12d2:	2d a7       	std	Y+45, r18	; 0x2d
		msecs/=60;
    12d4:	22 2d       	mov	r18, r2
    12d6:	33 2d       	mov	r19, r3
    12d8:	44 2d       	mov	r20, r4
    12da:	55 2d       	mov	r21, r5
    12dc:	66 2d       	mov	r22, r6
    12de:	77 2d       	mov	r23, r7
    12e0:	88 2d       	mov	r24, r8
    12e2:	99 2d       	mov	r25, r9
    12e4:	0e 94 81 1c 	call	0x3902	; 0x3902 <__udivdi3>
    12e8:	a2 2e       	mov	r10, r18
    12ea:	b3 2e       	mov	r11, r19
    12ec:	c4 2e       	mov	r12, r20
    12ee:	d5 2e       	mov	r13, r21
    12f0:	e6 2e       	mov	r14, r22
    12f2:	f7 2e       	mov	r15, r23
    12f4:	08 2f       	mov	r16, r24
    12f6:	19 2f       	mov	r17, r25
		
		msecs += mm;
    12f8:	2c a5       	ldd	r18, Y+44	; 0x2c
    12fa:	30 e0       	ldi	r19, 0x00	; 0
    12fc:	40 e0       	ldi	r20, 0x00	; 0
    12fe:	50 e0       	ldi	r21, 0x00	; 0
    1300:	60 e0       	ldi	r22, 0x00	; 0
    1302:	70 e0       	ldi	r23, 0x00	; 0
    1304:	80 e0       	ldi	r24, 0x00	; 0
    1306:	90 e0       	ldi	r25, 0x00	; 0
    1308:	0e 94 de 1c 	call	0x39bc	; 0x39bc <__adddi3>
    130c:	22 2e       	mov	r2, r18
    130e:	33 2e       	mov	r3, r19
    1310:	44 2e       	mov	r4, r20
    1312:	55 2e       	mov	r5, r21
    1314:	66 2e       	mov	r6, r22
    1316:	77 2e       	mov	r7, r23
    1318:	88 2e       	mov	r8, r24
    131a:	99 2e       	mov	r9, r25
		mm = msecs % 60;
    131c:	0f 2e       	mov	r0, r31
    131e:	fc e3       	ldi	r31, 0x3C	; 60
    1320:	af 2e       	mov	r10, r31
    1322:	f0 2d       	mov	r31, r0
    1324:	b1 2c       	mov	r11, r1
    1326:	c1 2c       	mov	r12, r1
    1328:	d1 2c       	mov	r13, r1
    132a:	e1 2c       	mov	r14, r1
    132c:	f1 2c       	mov	r15, r1
    132e:	00 e0       	ldi	r16, 0x00	; 0
    1330:	10 e0       	ldi	r17, 0x00	; 0
    1332:	0e 94 7f 1c 	call	0x38fe	; 0x38fe <__umoddi3>
    1336:	2c a7       	std	Y+44, r18	; 0x2c
		msecs/=60;
    1338:	22 2d       	mov	r18, r2
    133a:	33 2d       	mov	r19, r3
    133c:	44 2d       	mov	r20, r4
    133e:	55 2d       	mov	r21, r5
    1340:	66 2d       	mov	r22, r6
    1342:	77 2d       	mov	r23, r7
    1344:	88 2d       	mov	r24, r8
    1346:	99 2d       	mov	r25, r9
    1348:	0e 94 81 1c 	call	0x3902	; 0x3902 <__udivdi3>
    134c:	a2 2e       	mov	r10, r18
    134e:	b3 2e       	mov	r11, r19
    1350:	c4 2e       	mov	r12, r20
    1352:	d5 2e       	mov	r13, r21
    1354:	e6 2e       	mov	r14, r22
    1356:	f7 2e       	mov	r15, r23
    1358:	08 2f       	mov	r16, r24
    135a:	19 2f       	mov	r17, r25
		
		msecs += hh;
    135c:	2b a5       	ldd	r18, Y+43	; 0x2b
    135e:	30 e0       	ldi	r19, 0x00	; 0
    1360:	40 e0       	ldi	r20, 0x00	; 0
    1362:	50 e0       	ldi	r21, 0x00	; 0
    1364:	60 e0       	ldi	r22, 0x00	; 0
    1366:	70 e0       	ldi	r23, 0x00	; 0
    1368:	80 e0       	ldi	r24, 0x00	; 0
    136a:	90 e0       	ldi	r25, 0x00	; 0
    136c:	0e 94 de 1c 	call	0x39bc	; 0x39bc <__adddi3>
    1370:	22 2e       	mov	r2, r18
    1372:	33 2e       	mov	r3, r19
    1374:	44 2e       	mov	r4, r20
    1376:	55 2e       	mov	r5, r21
    1378:	66 2e       	mov	r6, r22
    137a:	77 2e       	mov	r7, r23
    137c:	88 2e       	mov	r8, r24
    137e:	99 2e       	mov	r9, r25
		hh = msecs % 24;
    1380:	0f 2e       	mov	r0, r31
    1382:	f8 e1       	ldi	r31, 0x18	; 24
    1384:	af 2e       	mov	r10, r31
    1386:	f0 2d       	mov	r31, r0
    1388:	b1 2c       	mov	r11, r1
    138a:	c1 2c       	mov	r12, r1
    138c:	d1 2c       	mov	r13, r1
    138e:	e1 2c       	mov	r14, r1
    1390:	f1 2c       	mov	r15, r1
    1392:	00 e0       	ldi	r16, 0x00	; 0
    1394:	10 e0       	ldi	r17, 0x00	; 0
    1396:	0e 94 7f 1c 	call	0x38fe	; 0x38fe <__umoddi3>
    139a:	2b a7       	std	Y+43, r18	; 0x2b
		msecs/=24;
    139c:	22 2d       	mov	r18, r2
    139e:	33 2d       	mov	r19, r3
    13a0:	44 2d       	mov	r20, r4
    13a2:	55 2d       	mov	r21, r5
    13a4:	66 2d       	mov	r22, r6
    13a6:	77 2d       	mov	r23, r7
    13a8:	88 2d       	mov	r24, r8
    13aa:	99 2d       	mov	r25, r9
    13ac:	0e 94 81 1c 	call	0x3902	; 0x3902 <__udivdi3>
    13b0:	02 2f       	mov	r16, r18
    13b2:	13 2f       	mov	r17, r19
    13b4:	24 2f       	mov	r18, r20
    13b6:	35 2f       	mov	r19, r21
		
		days += msecs;
    13b8:	8e a5       	ldd	r24, Y+46	; 0x2e
    13ba:	9f a5       	ldd	r25, Y+47	; 0x2f
    13bc:	a8 a9       	ldd	r26, Y+48	; 0x30
    13be:	b9 a9       	ldd	r27, Y+49	; 0x31
    13c0:	08 0f       	add	r16, r24
    13c2:	19 1f       	adc	r17, r25
    13c4:	2a 1f       	adc	r18, r26
    13c6:	3b 1f       	adc	r19, r27
    13c8:	0e a7       	std	Y+46, r16	; 0x2e
    13ca:	1f a7       	std	Y+47, r17	; 0x2f
    13cc:	28 ab       	std	Y+48, r18	; 0x30
    13ce:	39 ab       	std	Y+49, r19	; 0x31
		return *this;
	}
	inline hh_mm_ss_dd operator + (uint_least64_t msecs)const{
		hh_mm_ss_dd ret = *this;
		ret+=msecs;
		return ret;
    13d0:	87 e0       	ldi	r24, 0x07	; 7
    13d2:	fe 01       	movw	r30, r28
    13d4:	bb 96       	adiw	r30, 0x2b	; 43
    13d6:	de 01       	movw	r26, r28
    13d8:	56 96       	adiw	r26, 0x16	; 22
    13da:	01 90       	ld	r0, Z+
    13dc:	0d 92       	st	X+, r0
    13de:	8a 95       	dec	r24
    13e0:	e1 f7       	brne	.-8      	; 0x13da <_Z13water_processRK11hh_mm_ss_ddm+0x196>
    13e2:	87 e0       	ldi	r24, 0x07	; 7
    13e4:	fe 01       	movw	r30, r28
    13e6:	76 96       	adiw	r30, 0x16	; 22
    13e8:	de 01       	movw	r26, r28
    13ea:	94 96       	adiw	r26, 0x24	; 36
    13ec:	01 90       	ld	r0, Z+
    13ee:	0d 92       	st	X+, r0
    13f0:	8a 95       	dec	r24
    13f2:	e1 f7       	brne	.-8      	; 0x13ec <_Z13water_processRK11hh_mm_ss_ddm+0x1a8>
#define PIN_MASK_12 0b00010000
#define PIN_MASK_13 0b00100000

inline void set_port_bit(volatile uint8_t & _port,uint8_t bit_num,uint8_t value){
	if(value){
		_port |= (1<<bit_num);
    13f4:	88 b1       	in	r24, 0x08	; 8
    13f6:	84 60       	ori	r24, 0x04	; 4
    13f8:	88 b9       	out	0x08, r24	; 8
	water_impl.water();
	while(1){
		vTaskDelay(1000);
    13fa:	88 ee       	ldi	r24, 0xE8	; 232
    13fc:	93 e0       	ldi	r25, 0x03	; 3
    13fe:	0e 94 fb 12 	call	0x25f6	; 0x25f6 <vTaskDelay>
struct guard_timer0{
	mutex m;
	inline guard_timer0(){}
	
	inline void lock(){
		TIMSK0 = 0;
    1402:	0e e6       	ldi	r16, 0x6E	; 110
    1404:	10 e0       	ldi	r17, 0x00	; 0
    1406:	f8 01       	movw	r30, r16
    1408:	10 82       	st	Z, r1
#include "../../FreeRTOS/semphr.h"

struct mutex{
	SemaphoreHandle_t xMutex;
	void lock(){
		xSemaphoreTake(xMutex, portMAX_DELAY);
    140a:	0f 2e       	mov	r0, r31
    140c:	fe ed       	ldi	r31, 0xDE	; 222
    140e:	ef 2e       	mov	r14, r31
    1410:	f1 e0       	ldi	r31, 0x01	; 1
    1412:	ff 2e       	mov	r15, r31
    1414:	f0 2d       	mov	r31, r0
    1416:	20 e0       	ldi	r18, 0x00	; 0
    1418:	4f ef       	ldi	r20, 0xFF	; 255
    141a:	5f ef       	ldi	r21, 0xFF	; 255
    141c:	60 e0       	ldi	r22, 0x00	; 0
    141e:	70 e0       	ldi	r23, 0x00	; 0
    1420:	f7 01       	movw	r30, r14
    1422:	87 a5       	ldd	r24, Z+47	; 0x2f
    1424:	90 a9       	ldd	r25, Z+48	; 0x30
    1426:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <xQueueGenericReceive>
		auto curr_time = clocks.get([](Clocks const & clk){return clk.current();});
    142a:	87 e0       	ldi	r24, 0x07	; 7
    142c:	f7 01       	movw	r30, r14
    142e:	de 01       	movw	r26, r28
    1430:	1f 96       	adiw	r26, 0x0f	; 15
    1432:	01 90       	ld	r0, Z+
    1434:	0d 92       	st	X+, r0
    1436:	8a 95       	dec	r24
    1438:	e1 f7       	brne	.-8      	; 0x1432 <_Z13water_processRK11hh_mm_ss_ddm+0x1ee>
    143a:	87 e0       	ldi	r24, 0x07	; 7
    143c:	fe 01       	movw	r30, r28
    143e:	3f 96       	adiw	r30, 0x0f	; 15
    1440:	de 01       	movw	r26, r28
    1442:	18 96       	adiw	r26, 0x08	; 8
    1444:	01 90       	ld	r0, Z+
    1446:	0d 92       	st	X+, r0
    1448:	8a 95       	dec	r24
    144a:	e1 f7       	brne	.-8      	; 0x1444 <_Z13water_processRK11hh_mm_ss_ddm+0x200>
	
	
	template <typename Func_t>
	inline auto get(Func_t && F) const{
		lock();
		auto m_value = F(value);
    144c:	87 e0       	ldi	r24, 0x07	; 7
    144e:	fe 01       	movw	r30, r28
    1450:	38 96       	adiw	r30, 0x08	; 8
    1452:	de 01       	movw	r26, r28
    1454:	9b 96       	adiw	r26, 0x2b	; 43
    1456:	01 90       	ld	r0, Z+
    1458:	0d 92       	st	X+, r0
    145a:	8a 95       	dec	r24
    145c:	e1 f7       	brne	.-8      	; 0x1456 <_Z13water_processRK11hh_mm_ss_ddm+0x212>
	SemaphoreHandle_t xMutex;
	void lock(){
		xSemaphoreTake(xMutex, portMAX_DELAY);
	};
	void unlock(){
		xSemaphoreGive(xMutex);
    145e:	20 e0       	ldi	r18, 0x00	; 0
    1460:	40 e0       	ldi	r20, 0x00	; 0
    1462:	50 e0       	ldi	r21, 0x00	; 0
    1464:	60 e0       	ldi	r22, 0x00	; 0
    1466:	70 e0       	ldi	r23, 0x00	; 0
    1468:	f7 01       	movw	r30, r14
    146a:	87 a5       	ldd	r24, Z+47	; 0x2f
    146c:	90 a9       	ldd	r25, Z+48	; 0x30
    146e:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <xQueueGenericSend>
		TIMSK0 = 0;
		m.lock();
	}
	inline void unlock(){
		m.unlock();
		TIMSK0 = 1<<TOIE0;
    1472:	81 e0       	ldi	r24, 0x01	; 1
    1474:	f8 01       	movw	r30, r16
    1476:	80 83       	st	Z, r24
	template <typename Func_t>
	inline auto get(Func_t && F) const{
		lock();
		auto m_value = F(value);
		unlock();
		return m_value;
    1478:	87 e0       	ldi	r24, 0x07	; 7
    147a:	fe 01       	movw	r30, r28
    147c:	bb 96       	adiw	r30, 0x2b	; 43
    147e:	de 01       	movw	r26, r28
    1480:	11 96       	adiw	r26, 0x01	; 1
    1482:	01 90       	ld	r0, Z+
    1484:	0d 92       	st	X+, r0
    1486:	8a 95       	dec	r24
    1488:	e1 f7       	brne	.-8      	; 0x1482 <_Z13water_processRK11hh_mm_ss_ddm+0x23e>
    148a:	87 e0       	ldi	r24, 0x07	; 7
    148c:	fe 01       	movw	r30, r28
    148e:	31 96       	adiw	r30, 0x01	; 1
    1490:	de 01       	movw	r26, r28
    1492:	9b 96       	adiw	r26, 0x2b	; 43
    1494:	01 90       	ld	r0, Z+
    1496:	0d 92       	st	X+, r0
    1498:	8a 95       	dec	r24
    149a:	e1 f7       	brne	.-8      	; 0x1494 <_Z13water_processRK11hh_mm_ss_ddm+0x250>
	inline void on_out_of_water(){
		stop();
	}
	
	bool is_out_of_water() const{
		if(m_manage.Read() && !m_out_of_water.Read()){
    149c:	42 9b       	sbis	0x08, 2	; 8
    149e:	04 c0       	rjmp	.+8      	; 0x14a8 <_Z13water_processRK11hh_mm_ss_ddm+0x264>
    14a0:	42 99       	sbic	0x08, 2	; 8
    14a2:	04 c0       	rjmp	.+8      	; 0x14ac <_Z13water_processRK11hh_mm_ss_ddm+0x268>
    14a4:	81 e0       	ldi	r24, 0x01	; 1
    14a6:	03 c0       	rjmp	.+6      	; 0x14ae <_Z13water_processRK11hh_mm_ss_ddm+0x26a>
    14a8:	80 e0       	ldi	r24, 0x00	; 0
    14aa:	01 c0       	rjmp	.+2      	; 0x14ae <_Z13water_processRK11hh_mm_ss_ddm+0x26a>
    14ac:	80 e0       	ldi	r24, 0x00	; 0
		if(water_impl.is_out_of_water() || curr_time >= stop_time){
    14ae:	81 11       	cpse	r24, r1
    14b0:	26 c0       	rjmp	.+76     	; 0x14fe <_Z13water_processRK11hh_mm_ss_ddm+0x2ba>
	}
	inline bool operator <(hh_mm_ss_dd const & other) const{
		return other > *this;
	}
	inline bool operator >=(hh_mm_ss_dd const & other) const{
		if(days > other.days){
    14b2:	0e a5       	ldd	r16, Y+46	; 0x2e
    14b4:	1f a5       	ldd	r17, Y+47	; 0x2f
    14b6:	28 a9       	ldd	r18, Y+48	; 0x30
    14b8:	39 a9       	ldd	r19, Y+49	; 0x31
    14ba:	4f a1       	ldd	r20, Y+39	; 0x27
    14bc:	58 a5       	ldd	r21, Y+40	; 0x28
    14be:	69 a5       	ldd	r22, Y+41	; 0x29
    14c0:	7a a5       	ldd	r23, Y+42	; 0x2a
    14c2:	40 17       	cp	r20, r16
    14c4:	51 07       	cpc	r21, r17
    14c6:	62 07       	cpc	r22, r18
    14c8:	73 07       	cpc	r23, r19
    14ca:	90 f0       	brcs	.+36     	; 0x14f0 <_Z13water_processRK11hh_mm_ss_ddm+0x2ac>
			return true;
		} else if (days < other.days) {
    14cc:	04 17       	cp	r16, r20
    14ce:	15 07       	cpc	r17, r21
    14d0:	26 07       	cpc	r18, r22
    14d2:	37 07       	cpc	r19, r23
    14d4:	a0 f0       	brcs	.+40     	; 0x14fe <_Z13water_processRK11hh_mm_ss_ddm+0x2ba>
			return false;
		}
		
		if(hh > other.hh){
    14d6:	2b a5       	ldd	r18, Y+43	; 0x2b
    14d8:	9c a1       	ldd	r25, Y+36	; 0x24
    14da:	92 17       	cp	r25, r18
    14dc:	58 f0       	brcs	.+22     	; 0x14f4 <_Z13water_processRK11hh_mm_ss_ddm+0x2b0>
			return true;
		} else if (hh < other.hh) {
    14de:	29 17       	cp	r18, r25
    14e0:	70 f0       	brcs	.+28     	; 0x14fe <_Z13water_processRK11hh_mm_ss_ddm+0x2ba>
			return false;
		}
		
		if(mm > other.mm){
    14e2:	2c a5       	ldd	r18, Y+44	; 0x2c
    14e4:	9d a1       	ldd	r25, Y+37	; 0x25
    14e6:	92 17       	cp	r25, r18
    14e8:	38 f0       	brcs	.+14     	; 0x14f8 <_Z13water_processRK11hh_mm_ss_ddm+0x2b4>
			return true;
		} else if (mm < other.mm) {
    14ea:	29 17       	cp	r18, r25
    14ec:	38 f4       	brcc	.+14     	; 0x14fc <_Z13water_processRK11hh_mm_ss_ddm+0x2b8>
    14ee:	07 c0       	rjmp	.+14     	; 0x14fe <_Z13water_processRK11hh_mm_ss_ddm+0x2ba>
	inline bool operator <(hh_mm_ss_dd const & other) const{
		return other > *this;
	}
	inline bool operator >=(hh_mm_ss_dd const & other) const{
		if(days > other.days){
			return true;
    14f0:	81 e0       	ldi	r24, 0x01	; 1
    14f2:	05 c0       	rjmp	.+10     	; 0x14fe <_Z13water_processRK11hh_mm_ss_ddm+0x2ba>
		} else if (days < other.days) {
			return false;
		}
		
		if(hh > other.hh){
			return true;
    14f4:	81 e0       	ldi	r24, 0x01	; 1
    14f6:	03 c0       	rjmp	.+6      	; 0x14fe <_Z13water_processRK11hh_mm_ss_ddm+0x2ba>
		} else if (hh < other.hh) {
			return false;
		}
		
		if(mm > other.mm){
			return true;
    14f8:	81 e0       	ldi	r24, 0x01	; 1
    14fa:	01 c0       	rjmp	.+2      	; 0x14fe <_Z13water_processRK11hh_mm_ss_ddm+0x2ba>
		} else if (mm < other.mm) {
			return false;
		}
		
		if(ss >= other.ss){
			return true;
    14fc:	81 e0       	ldi	r24, 0x01	; 1
    14fe:	88 23       	and	r24, r24
    1500:	09 f4       	brne	.+2      	; 0x1504 <_Z13water_processRK11hh_mm_ss_ddm+0x2c0>
    1502:	7b cf       	rjmp	.-266    	; 0x13fa <_Z13water_processRK11hh_mm_ss_ddm+0x1b6>
	} else {
		_port &= ~(1<<bit_num);
    1504:	88 b1       	in	r24, 0x08	; 8
    1506:	8b 7f       	andi	r24, 0xFB	; 251
    1508:	88 b9       	out	0x08, r24	; 8
			water_impl.stop();
			return curr_time;
    150a:	87 e0       	ldi	r24, 0x07	; 7
    150c:	fe 01       	movw	r30, r28
    150e:	bb 96       	adiw	r30, 0x2b	; 43
    1510:	de 01       	movw	r26, r28
    1512:	5d 96       	adiw	r26, 0x1d	; 29
    1514:	01 90       	ld	r0, Z+
    1516:	0d 92       	st	X+, r0
    1518:	8a 95       	dec	r24
    151a:	e1 f7       	brne	.-8      	; 0x1514 <_Z13water_processRK11hh_mm_ss_ddm+0x2d0>
    151c:	2d 8d       	ldd	r18, Y+29	; 0x1d
    151e:	3e 8d       	ldd	r19, Y+30	; 0x1e
    1520:	4f 8d       	ldd	r20, Y+31	; 0x1f
    1522:	58 a1       	ldd	r21, Y+32	; 0x20
    1524:	69 a1       	ldd	r22, Y+33	; 0x21
    1526:	7a a1       	ldd	r23, Y+34	; 0x22
		}
	}
}
    1528:	8b a1       	ldd	r24, Y+35	; 0x23
    152a:	90 e0       	ldi	r25, 0x00	; 0
    152c:	e1 96       	adiw	r28, 0x31	; 49
    152e:	0f b6       	in	r0, 0x3f	; 63
    1530:	f8 94       	cli
    1532:	de bf       	out	0x3e, r29	; 62
    1534:	0f be       	out	0x3f, r0	; 63
    1536:	cd bf       	out	0x3d, r28	; 61
    1538:	df 91       	pop	r29
    153a:	cf 91       	pop	r28
    153c:	1f 91       	pop	r17
    153e:	0f 91       	pop	r16
    1540:	ff 90       	pop	r15
    1542:	ef 90       	pop	r14
    1544:	df 90       	pop	r13
    1546:	cf 90       	pop	r12
    1548:	bf 90       	pop	r11
    154a:	af 90       	pop	r10
    154c:	9f 90       	pop	r9
    154e:	8f 90       	pop	r8
    1550:	7f 90       	pop	r7
    1552:	6f 90       	pop	r6
    1554:	5f 90       	pop	r5
    1556:	4f 90       	pop	r4
    1558:	3f 90       	pop	r3
    155a:	2f 90       	pop	r2
    155c:	08 95       	ret

0000155e <_Z13task_wateringPv>:

void task_watering(void *){
    155e:	cf 93       	push	r28
    1560:	df 93       	push	r29
    1562:	cd b7       	in	r28, 0x3d	; 61
    1564:	de b7       	in	r29, 0x3e	; 62
    1566:	ce 54       	subi	r28, 0x4E	; 78
    1568:	d1 09       	sbc	r29, r1
    156a:	0f b6       	in	r0, 0x3f	; 63
    156c:	f8 94       	cli
    156e:	de bf       	out	0x3e, r29	; 62
    1570:	0f be       	out	0x3f, r0	; 63
    1572:	cd bf       	out	0x3d, r28	; 61
struct guard_timer0{
	mutex m;
	inline guard_timer0(){}
	
	inline void lock(){
		TIMSK0 = 0;
    1574:	0f 2e       	mov	r0, r31
    1576:	fe e6       	ldi	r31, 0x6E	; 110
    1578:	ef 2e       	mov	r14, r31
    157a:	f1 2c       	mov	r15, r1
    157c:	f0 2d       	mov	r31, r0
    157e:	d7 01       	movw	r26, r14
    1580:	1c 92       	st	X, r1
#include "../../FreeRTOS/semphr.h"

struct mutex{
	SemaphoreHandle_t xMutex;
	void lock(){
		xSemaphoreTake(xMutex, portMAX_DELAY);
    1582:	0e ed       	ldi	r16, 0xDE	; 222
    1584:	11 e0       	ldi	r17, 0x01	; 1
    1586:	20 e0       	ldi	r18, 0x00	; 0
    1588:	4f ef       	ldi	r20, 0xFF	; 255
    158a:	5f ef       	ldi	r21, 0xFF	; 255
    158c:	60 e0       	ldi	r22, 0x00	; 0
    158e:	70 e0       	ldi	r23, 0x00	; 0
    1590:	f8 01       	movw	r30, r16
    1592:	87 a5       	ldd	r24, Z+47	; 0x2f
    1594:	90 a9       	ldd	r25, Z+48	; 0x30
    1596:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <xQueueGenericReceive>
	hh_mm_ss_dd last_water = clocks.get([](Clocks const & clk){return clk.current();});
    159a:	87 e0       	ldi	r24, 0x07	; 7
    159c:	f8 01       	movw	r30, r16
    159e:	de 01       	movw	r26, r28
    15a0:	9b 96       	adiw	r26, 0x2b	; 43
    15a2:	01 90       	ld	r0, Z+
    15a4:	0d 92       	st	X+, r0
    15a6:	8a 95       	dec	r24
    15a8:	e1 f7       	brne	.-8      	; 0x15a2 <_Z13task_wateringPv+0x44>
    15aa:	87 e0       	ldi	r24, 0x07	; 7
    15ac:	fe 01       	movw	r30, r28
    15ae:	bb 96       	adiw	r30, 0x2b	; 43
    15b0:	de 01       	movw	r26, r28
    15b2:	94 96       	adiw	r26, 0x24	; 36
    15b4:	01 90       	ld	r0, Z+
    15b6:	0d 92       	st	X+, r0
    15b8:	8a 95       	dec	r24
    15ba:	e1 f7       	brne	.-8      	; 0x15b4 <_Z13task_wateringPv+0x56>
	
	
	template <typename Func_t>
	inline auto get(Func_t && F) const{
		lock();
		auto m_value = F(value);
    15bc:	87 e0       	ldi	r24, 0x07	; 7
    15be:	fe 01       	movw	r30, r28
    15c0:	b4 96       	adiw	r30, 0x24	; 36
    15c2:	de 01       	movw	r26, r28
    15c4:	a0 5c       	subi	r26, 0xC0	; 192
    15c6:	bf 4f       	sbci	r27, 0xFF	; 255
    15c8:	01 90       	ld	r0, Z+
    15ca:	0d 92       	st	X+, r0
    15cc:	8a 95       	dec	r24
    15ce:	e1 f7       	brne	.-8      	; 0x15c8 <_Z13task_wateringPv+0x6a>
	SemaphoreHandle_t xMutex;
	void lock(){
		xSemaphoreTake(xMutex, portMAX_DELAY);
	};
	void unlock(){
		xSemaphoreGive(xMutex);
    15d0:	20 e0       	ldi	r18, 0x00	; 0
    15d2:	40 e0       	ldi	r20, 0x00	; 0
    15d4:	50 e0       	ldi	r21, 0x00	; 0
    15d6:	60 e0       	ldi	r22, 0x00	; 0
    15d8:	70 e0       	ldi	r23, 0x00	; 0
    15da:	d8 01       	movw	r26, r16
    15dc:	9f 96       	adiw	r26, 0x2f	; 47
    15de:	8d 91       	ld	r24, X+
    15e0:	9c 91       	ld	r25, X
    15e2:	d0 97       	sbiw	r26, 0x30	; 48
    15e4:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <xQueueGenericSend>
		TIMSK0 = 0;
		m.lock();
	}
	inline void unlock(){
		m.unlock();
		TIMSK0 = 1<<TOIE0;
    15e8:	81 e0       	ldi	r24, 0x01	; 1
    15ea:	f7 01       	movw	r30, r14
    15ec:	80 83       	st	Z, r24
	template <typename Func_t>
	inline auto get(Func_t && F) const{
		lock();
		auto m_value = F(value);
		unlock();
		return m_value;
    15ee:	87 e0       	ldi	r24, 0x07	; 7
    15f0:	fe 01       	movw	r30, r28
    15f2:	e0 5c       	subi	r30, 0xC0	; 192
    15f4:	ff 4f       	sbci	r31, 0xFF	; 255
    15f6:	de 01       	movw	r26, r28
    15f8:	5d 96       	adiw	r26, 0x1d	; 29
    15fa:	01 90       	ld	r0, Z+
    15fc:	0d 92       	st	X+, r0
    15fe:	8a 95       	dec	r24
    1600:	e1 f7       	brne	.-8      	; 0x15fa <_Z13task_wateringPv+0x9c>
    1602:	87 e0       	ldi	r24, 0x07	; 7
    1604:	fe 01       	movw	r30, r28
    1606:	7d 96       	adiw	r30, 0x1d	; 29
    1608:	de 01       	movw	r26, r28
    160a:	d2 96       	adiw	r26, 0x32	; 50
    160c:	01 90       	ld	r0, Z+
    160e:	0d 92       	st	X+, r0
    1610:	8a 95       	dec	r24
    1612:	e1 f7       	brne	.-8      	; 0x160c <_Z13task_wateringPv+0xae>
    1614:	87 e0       	ldi	r24, 0x07	; 7
    1616:	fe 01       	movw	r30, r28
    1618:	f2 96       	adiw	r30, 0x32	; 50
    161a:	de 01       	movw	r26, r28
    161c:	d9 96       	adiw	r26, 0x39	; 57
    161e:	01 90       	ld	r0, Z+
    1620:	0d 92       	st	X+, r0
    1622:	8a 95       	dec	r24
    1624:	e1 f7       	brne	.-8      	; 0x161e <_Z13task_wateringPv+0xc0>
	
	while(1){
		vTaskDelay(1000);
    1626:	88 ee       	ldi	r24, 0xE8	; 232
    1628:	93 e0       	ldi	r25, 0x03	; 3
    162a:	0e 94 fb 12 	call	0x25f6	; 0x25f6 <vTaskDelay>
struct guard_timer0{
	mutex m;
	inline guard_timer0(){}
	
	inline void lock(){
		TIMSK0 = 0;
    162e:	0f 2e       	mov	r0, r31
    1630:	fe e6       	ldi	r31, 0x6E	; 110
    1632:	ef 2e       	mov	r14, r31
    1634:	f1 2c       	mov	r15, r1
    1636:	f0 2d       	mov	r31, r0
    1638:	d7 01       	movw	r26, r14
    163a:	1c 92       	st	X, r1
#include "../../FreeRTOS/semphr.h"

struct mutex{
	SemaphoreHandle_t xMutex;
	void lock(){
		xSemaphoreTake(xMutex, portMAX_DELAY);
    163c:	0e ed       	ldi	r16, 0xDE	; 222
    163e:	11 e0       	ldi	r17, 0x01	; 1
    1640:	20 e0       	ldi	r18, 0x00	; 0
    1642:	4f ef       	ldi	r20, 0xFF	; 255
    1644:	5f ef       	ldi	r21, 0xFF	; 255
    1646:	60 e0       	ldi	r22, 0x00	; 0
    1648:	70 e0       	ldi	r23, 0x00	; 0
    164a:	f8 01       	movw	r30, r16
    164c:	87 a5       	ldd	r24, Z+47	; 0x2f
    164e:	90 a9       	ldd	r25, Z+48	; 0x30
    1650:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <xQueueGenericReceive>
		hh_mm_ss_dd current = clocks.get([](Clocks const & clk){return clk.current();});
    1654:	87 e0       	ldi	r24, 0x07	; 7
    1656:	f8 01       	movw	r30, r16
    1658:	de 01       	movw	r26, r28
    165a:	1f 96       	adiw	r26, 0x0f	; 15
    165c:	01 90       	ld	r0, Z+
    165e:	0d 92       	st	X+, r0
    1660:	8a 95       	dec	r24
    1662:	e1 f7       	brne	.-8      	; 0x165c <_Z13task_wateringPv+0xfe>
    1664:	87 e0       	ldi	r24, 0x07	; 7
    1666:	fe 01       	movw	r30, r28
    1668:	3f 96       	adiw	r30, 0x0f	; 15
    166a:	de 01       	movw	r26, r28
    166c:	18 96       	adiw	r26, 0x08	; 8
    166e:	01 90       	ld	r0, Z+
    1670:	0d 92       	st	X+, r0
    1672:	8a 95       	dec	r24
    1674:	e1 f7       	brne	.-8      	; 0x166e <_Z13task_wateringPv+0x110>
	
	
	template <typename Func_t>
	inline auto get(Func_t && F) const{
		lock();
		auto m_value = F(value);
    1676:	87 e0       	ldi	r24, 0x07	; 7
    1678:	fe 01       	movw	r30, r28
    167a:	38 96       	adiw	r30, 0x08	; 8
    167c:	de 01       	movw	r26, r28
    167e:	a0 5c       	subi	r26, 0xC0	; 192
    1680:	bf 4f       	sbci	r27, 0xFF	; 255
    1682:	01 90       	ld	r0, Z+
    1684:	0d 92       	st	X+, r0
    1686:	8a 95       	dec	r24
    1688:	e1 f7       	brne	.-8      	; 0x1682 <_Z13task_wateringPv+0x124>
	SemaphoreHandle_t xMutex;
	void lock(){
		xSemaphoreTake(xMutex, portMAX_DELAY);
	};
	void unlock(){
		xSemaphoreGive(xMutex);
    168a:	20 e0       	ldi	r18, 0x00	; 0
    168c:	40 e0       	ldi	r20, 0x00	; 0
    168e:	50 e0       	ldi	r21, 0x00	; 0
    1690:	60 e0       	ldi	r22, 0x00	; 0
    1692:	70 e0       	ldi	r23, 0x00	; 0
    1694:	d8 01       	movw	r26, r16
    1696:	9f 96       	adiw	r26, 0x2f	; 47
    1698:	8d 91       	ld	r24, X+
    169a:	9c 91       	ld	r25, X
    169c:	d0 97       	sbiw	r26, 0x30	; 48
    169e:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <xQueueGenericSend>
		TIMSK0 = 0;
		m.lock();
	}
	inline void unlock(){
		m.unlock();
		TIMSK0 = 1<<TOIE0;
    16a2:	81 e0       	ldi	r24, 0x01	; 1
    16a4:	f7 01       	movw	r30, r14
    16a6:	80 83       	st	Z, r24
	template <typename Func_t>
	inline auto get(Func_t && F) const{
		lock();
		auto m_value = F(value);
		unlock();
		return m_value;
    16a8:	87 e0       	ldi	r24, 0x07	; 7
    16aa:	fe 01       	movw	r30, r28
    16ac:	e0 5c       	subi	r30, 0xC0	; 192
    16ae:	ff 4f       	sbci	r31, 0xFF	; 255
    16b0:	de 01       	movw	r26, r28
    16b2:	11 96       	adiw	r26, 0x01	; 1
    16b4:	01 90       	ld	r0, Z+
    16b6:	0d 92       	st	X+, r0
    16b8:	8a 95       	dec	r24
    16ba:	e1 f7       	brne	.-8      	; 0x16b4 <_Z13task_wateringPv+0x156>
    16bc:	87 e0       	ldi	r24, 0x07	; 7
    16be:	fe 01       	movw	r30, r28
    16c0:	31 96       	adiw	r30, 0x01	; 1
    16c2:	de 01       	movw	r26, r28
    16c4:	56 96       	adiw	r26, 0x16	; 22
    16c6:	01 90       	ld	r0, Z+
    16c8:	0d 92       	st	X+, r0
    16ca:	8a 95       	dec	r24
    16cc:	e1 f7       	brne	.-8      	; 0x16c6 <_Z13task_wateringPv+0x168>
    16ce:	87 e0       	ldi	r24, 0x07	; 7
    16d0:	fe 01       	movw	r30, r28
    16d2:	76 96       	adiw	r30, 0x16	; 22
    16d4:	de 01       	movw	r26, r28
    16d6:	a0 5c       	subi	r26, 0xC0	; 192
    16d8:	bf 4f       	sbci	r27, 0xFF	; 255
    16da:	01 90       	ld	r0, Z+
    16dc:	0d 92       	st	X+, r0
    16de:	8a 95       	dec	r24
    16e0:	e1 f7       	brne	.-8      	; 0x16da <_Z13task_wateringPv+0x17c>
		water_plan.apply([&current,&last_water](water_plan_array_t & plan){
    16e2:	4e 01       	movw	r8, r28
    16e4:	f0 e4       	ldi	r31, 0x40	; 64
    16e6:	8f 0e       	add	r8, r31
    16e8:	91 1c       	adc	r9, r1
    16ea:	5e 01       	movw	r10, r28
    16ec:	89 e3       	ldi	r24, 0x39	; 57
    16ee:	a8 0e       	add	r10, r24
    16f0:	b1 1c       	adc	r11, r1
#include "../../FreeRTOS/semphr.h"

struct mutex{
	SemaphoreHandle_t xMutex;
	void lock(){
		xSemaphoreTake(xMutex, portMAX_DELAY);
    16f2:	01 e3       	ldi	r16, 0x31	; 49
    16f4:	12 e0       	ldi	r17, 0x02	; 2
    16f6:	20 e0       	ldi	r18, 0x00	; 0
    16f8:	4f ef       	ldi	r20, 0xFF	; 255
    16fa:	5f ef       	ldi	r21, 0xFF	; 255
    16fc:	60 e0       	ldi	r22, 0x00	; 0
    16fe:	70 e0       	ldi	r23, 0x00	; 0
    1700:	d8 01       	movw	r26, r16
    1702:	12 96       	adiw	r26, 0x02	; 2
    1704:	8d 91       	ld	r24, X+
    1706:	9c 91       	ld	r25, X
    1708:	13 97       	sbiw	r26, 0x03	; 3
    170a:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <xQueueGenericReceive>
	template <typename Func_t,
		Std::enable_if_same_t<Std::invoke_result_t<Func_t,T &>,void,bool> = true>
	inline void apply(Func_t && F){
		//static_assert(Std::is_same_v<Std::invoke_result_t<Func_t,T &>,void>,"not void function in void spec");
		lock();
		F(value);
    170e:	f8 01       	movw	r30, r16
    1710:	00 81       	ld	r16, Z
    1712:	11 81       	ldd	r17, Z+1	; 0x01
			for (uint_least8_t i=0;i<plan.size();++i){
    1714:	d1 2c       	mov	r13, r1
    1716:	f7 e0       	ldi	r31, 0x07	; 7
    1718:	fd 15       	cp	r31, r13
    171a:	08 f4       	brcc	.+2      	; 0x171e <_Z13task_wateringPv+0x1c0>
    171c:	b3 c0       	rjmp	.+358    	; 0x1884 <_Z13task_wateringPv+0x326>
				if(plan[i].actual){
    171e:	2d 2d       	mov	r18, r13
    1720:	30 e0       	ldi	r19, 0x00	; 0
    1722:	8d e0       	ldi	r24, 0x0D	; 13
    1724:	82 9f       	mul	r24, r18
    1726:	f0 01       	movw	r30, r0
    1728:	83 9f       	mul	r24, r19
    172a:	f0 0d       	add	r31, r0
    172c:	11 24       	eor	r1, r1
    172e:	e0 0f       	add	r30, r16
    1730:	f1 1f       	adc	r31, r17
    1732:	90 81       	ld	r25, Z
    1734:	99 23       	and	r25, r25
    1736:	09 f4       	brne	.+2      	; 0x173a <_Z13task_wateringPv+0x1dc>
    1738:	a3 c0       	rjmp	.+326    	; 0x1880 <_Z13task_wateringPv+0x322>
	hh_mm_ss_dd last_water = clocks.get([](Clocks const & clk){return clk.current();});
	
	while(1){
		vTaskDelay(1000);
		hh_mm_ss_dd current = clocks.get([](Clocks const & clk){return clk.current();});
		water_plan.apply([&current,&last_water](water_plan_array_t & plan){
    173a:	f4 01       	movw	r30, r8
			for (uint_least8_t i=0;i<plan.size();++i){
				if(plan[i].actual){
					if(plan[i].is_ready(current.hh,current.mm,current.ss)){
    173c:	42 81       	ldd	r20, Z+2	; 0x02
    173e:	81 81       	ldd	r24, Z+1	; 0x01
    1740:	50 81       	ld	r21, Z
    }

    bool is_ready(uint_least8_t tmp_hh,uint_least8_t tmp_mm,uint_least8_t tmp_ss){
        if(ptime.days > 0){
    1742:	6d e0       	ldi	r22, 0x0D	; 13
    1744:	62 9f       	mul	r22, r18
    1746:	d0 01       	movw	r26, r0
    1748:	63 9f       	mul	r22, r19
    174a:	b0 0d       	add	r27, r0
    174c:	11 24       	eor	r1, r1
    174e:	a0 0f       	add	r26, r16
    1750:	b1 1f       	adc	r27, r17
    1752:	15 96       	adiw	r26, 0x05	; 5
    1754:	4d 90       	ld	r4, X+
    1756:	5d 90       	ld	r5, X+
    1758:	6d 90       	ld	r6, X+
    175a:	7c 90       	ld	r7, X
    175c:	18 97       	sbiw	r26, 0x08	; 8
    175e:	45 28       	or	r4, r5
    1760:	46 28       	or	r4, r6
    1762:	47 28       	or	r4, r7
    1764:	51 f5       	brne	.+84     	; 0x17ba <_Z13task_wateringPv+0x25c>
            return false;
        }
        if(ptime.hh > tmp_hh){
    1766:	62 9f       	mul	r22, r18
    1768:	d0 01       	movw	r26, r0
    176a:	63 9f       	mul	r22, r19
    176c:	b0 0d       	add	r27, r0
    176e:	11 24       	eor	r1, r1
    1770:	a0 0f       	add	r26, r16
    1772:	b1 1f       	adc	r27, r17
    1774:	12 96       	adiw	r26, 0x02	; 2
    1776:	6c 91       	ld	r22, X
    1778:	56 17       	cp	r21, r22
    177a:	08 f1       	brcs	.+66     	; 0x17be <_Z13task_wateringPv+0x260>
            return false;
        } else if (ptime.hh < tmp_hh ) {
    177c:	65 17       	cp	r22, r21
    177e:	10 f1       	brcs	.+68     	; 0x17c4 <_Z13task_wateringPv+0x266>
            return true;
        }

        if(ptime.mm > tmp_mm){
    1780:	5d e0       	ldi	r21, 0x0D	; 13
    1782:	52 9f       	mul	r21, r18
    1784:	d0 01       	movw	r26, r0
    1786:	53 9f       	mul	r21, r19
    1788:	b0 0d       	add	r27, r0
    178a:	11 24       	eor	r1, r1
    178c:	a0 0f       	add	r26, r16
    178e:	b1 1f       	adc	r27, r17
    1790:	13 96       	adiw	r26, 0x03	; 3
    1792:	5c 91       	ld	r21, X
    1794:	85 17       	cp	r24, r21
    1796:	a8 f0       	brcs	.+42     	; 0x17c2 <_Z13task_wateringPv+0x264>
            return false;
        } else if (ptime.mm < tmp_mm) {
    1798:	58 17       	cp	r21, r24
    179a:	a0 f0       	brcs	.+40     	; 0x17c4 <_Z13task_wateringPv+0x266>
            return true;
        }
        return tmp_ss >= ptime.ss;
    179c:	8d e0       	ldi	r24, 0x0D	; 13
    179e:	82 9f       	mul	r24, r18
    17a0:	d0 01       	movw	r26, r0
    17a2:	83 9f       	mul	r24, r19
    17a4:	b0 0d       	add	r27, r0
    17a6:	11 24       	eor	r1, r1
    17a8:	a0 0f       	add	r26, r16
    17aa:	b1 1f       	adc	r27, r17
    17ac:	91 e0       	ldi	r25, 0x01	; 1
    17ae:	14 96       	adiw	r26, 0x04	; 4
    17b0:	8c 91       	ld	r24, X
    17b2:	48 17       	cp	r20, r24
    17b4:	38 f4       	brcc	.+14     	; 0x17c4 <_Z13task_wateringPv+0x266>
    17b6:	90 e0       	ldi	r25, 0x00	; 0
    17b8:	05 c0       	rjmp	.+10     	; 0x17c4 <_Z13task_wateringPv+0x266>
            ptime.days--;
    }

    bool is_ready(uint_least8_t tmp_hh,uint_least8_t tmp_mm,uint_least8_t tmp_ss){
        if(ptime.days > 0){
            return false;
    17ba:	90 e0       	ldi	r25, 0x00	; 0
    17bc:	03 c0       	rjmp	.+6      	; 0x17c4 <_Z13task_wateringPv+0x266>
        }
        if(ptime.hh > tmp_hh){
            return false;
    17be:	90 e0       	ldi	r25, 0x00	; 0
    17c0:	01 c0       	rjmp	.+2      	; 0x17c4 <_Z13task_wateringPv+0x266>
        } else if (ptime.hh < tmp_hh ) {
            return true;
        }

        if(ptime.mm > tmp_mm){
            return false;
    17c2:	90 e0       	ldi	r25, 0x00	; 0
    17c4:	99 23       	and	r25, r25
    17c6:	09 f4       	brne	.+2      	; 0x17ca <_Z13task_wateringPv+0x26c>
    17c8:	5b c0       	rjmp	.+182    	; 0x1880 <_Z13task_wateringPv+0x322>
	hh_mm_ss_dd last_water = clocks.get([](Clocks const & clk){return clk.current();});
	
	while(1){
		vTaskDelay(1000);
		hh_mm_ss_dd current = clocks.get([](Clocks const & clk){return clk.current();});
		water_plan.apply([&current,&last_water](water_plan_array_t & plan){
    17ca:	75 01       	movw	r14, r10
		
	}
	
		
	inline bool operator > (hh_mm_ss_dd const & other)const{
		if(days > other.days){
    17cc:	43 80       	ldd	r4, Z+3	; 0x03
    17ce:	54 80       	ldd	r5, Z+4	; 0x04
    17d0:	65 80       	ldd	r6, Z+5	; 0x05
    17d2:	76 80       	ldd	r7, Z+6	; 0x06
    17d4:	d5 01       	movw	r26, r10
    17d6:	13 96       	adiw	r26, 0x03	; 3
    17d8:	4d 91       	ld	r20, X+
    17da:	5d 91       	ld	r21, X+
    17dc:	6d 91       	ld	r22, X+
    17de:	7c 91       	ld	r23, X
    17e0:	16 97       	sbiw	r26, 0x06	; 6
    17e2:	44 15       	cp	r20, r4
    17e4:	55 05       	cpc	r21, r5
    17e6:	66 05       	cpc	r22, r6
    17e8:	77 05       	cpc	r23, r7
    17ea:	00 f1       	brcs	.+64     	; 0x182c <_Z13task_wateringPv+0x2ce>
			return true;
		} else if (days < other.days) {
    17ec:	44 16       	cp	r4, r20
    17ee:	55 06       	cpc	r5, r21
    17f0:	66 06       	cpc	r6, r22
    17f2:	77 06       	cpc	r7, r23
    17f4:	a0 f0       	brcs	.+40     	; 0x181e <_Z13task_wateringPv+0x2c0>
			return false;
		}
		
		if(hh > other.hh){
    17f6:	40 81       	ld	r20, Z
    17f8:	8c 91       	ld	r24, X
    17fa:	84 17       	cp	r24, r20
    17fc:	b8 f0       	brcs	.+46     	; 0x182c <_Z13task_wateringPv+0x2ce>
			return true;
		} else if (hh < other.hh) {
    17fe:	48 17       	cp	r20, r24
    1800:	80 f0       	brcs	.+32     	; 0x1822 <_Z13task_wateringPv+0x2c4>
			return false;
		}
		
		if(mm > other.mm){
    1802:	41 81       	ldd	r20, Z+1	; 0x01
    1804:	11 96       	adiw	r26, 0x01	; 1
    1806:	8c 91       	ld	r24, X
    1808:	11 97       	sbiw	r26, 0x01	; 1
    180a:	84 17       	cp	r24, r20
    180c:	78 f0       	brcs	.+30     	; 0x182c <_Z13task_wateringPv+0x2ce>
			return true;
		} else if (mm < other.mm) {
    180e:	48 17       	cp	r20, r24
    1810:	50 f0       	brcs	.+20     	; 0x1826 <_Z13task_wateringPv+0x2c8>
			return false;
		}
		
		if(ss > other.ss){
    1812:	42 81       	ldd	r20, Z+2	; 0x02
    1814:	12 96       	adiw	r26, 0x02	; 2
    1816:	8c 91       	ld	r24, X
    1818:	84 17       	cp	r24, r20
    181a:	38 f4       	brcc	.+14     	; 0x182a <_Z13task_wateringPv+0x2cc>
    181c:	07 c0       	rjmp	.+14     	; 0x182c <_Z13task_wateringPv+0x2ce>
		
	inline bool operator > (hh_mm_ss_dd const & other)const{
		if(days > other.days){
			return true;
		} else if (days < other.days) {
			return false;
    181e:	90 e0       	ldi	r25, 0x00	; 0
    1820:	05 c0       	rjmp	.+10     	; 0x182c <_Z13task_wateringPv+0x2ce>
		}
		
		if(hh > other.hh){
			return true;
		} else if (hh < other.hh) {
			return false;
    1822:	90 e0       	ldi	r25, 0x00	; 0
    1824:	03 c0       	rjmp	.+6      	; 0x182c <_Z13task_wateringPv+0x2ce>
		}
		
		if(mm > other.mm){
			return true;
		} else if (mm < other.mm) {
			return false;
    1826:	90 e0       	ldi	r25, 0x00	; 0
    1828:	01 c0       	rjmp	.+2      	; 0x182c <_Z13task_wateringPv+0x2ce>
		}
		
		if(ss > other.ss){
			return true;
		} else {
			return false;
    182a:	90 e0       	ldi	r25, 0x00	; 0
			for (uint_least8_t i=0;i<plan.size();++i){
				if(plan[i].actual){
					if(plan[i].is_ready(current.hh,current.mm,current.ss)){
						if(last_water < current || plan[i].force){
    182c:	91 11       	cpse	r25, r1
    182e:	0a c0       	rjmp	.+20     	; 0x1844 <_Z13task_wateringPv+0x2e6>
    1830:	8d e0       	ldi	r24, 0x0D	; 13
    1832:	82 9f       	mul	r24, r18
    1834:	d0 01       	movw	r26, r0
    1836:	83 9f       	mul	r24, r19
    1838:	b0 0d       	add	r27, r0
    183a:	11 24       	eor	r1, r1
    183c:	a0 0f       	add	r26, r16
    183e:	b1 1f       	adc	r27, r17
    1840:	11 96       	adiw	r26, 0x01	; 1
    1842:	9c 91       	ld	r25, X
    1844:	99 23       	and	r25, r25
    1846:	e1 f0       	breq	.+56     	; 0x1880 <_Z13task_wateringPv+0x322>
							last_water = water_process(current,plan[i].duration);
    1848:	8d e0       	ldi	r24, 0x0D	; 13
    184a:	82 9f       	mul	r24, r18
    184c:	10 01       	movw	r2, r0
    184e:	83 9f       	mul	r24, r19
    1850:	30 0c       	add	r3, r0
    1852:	11 24       	eor	r1, r1
    1854:	20 0e       	add	r2, r16
    1856:	31 1e       	adc	r3, r17
    1858:	d1 01       	movw	r26, r2
    185a:	19 96       	adiw	r26, 0x09	; 9
    185c:	4d 91       	ld	r20, X+
    185e:	5d 91       	ld	r21, X+
    1860:	6d 91       	ld	r22, X+
    1862:	7c 91       	ld	r23, X
    1864:	1c 97       	sbiw	r26, 0x0c	; 12
    1866:	cf 01       	movw	r24, r30
    1868:	0e 94 22 09 	call	0x1244	; 0x1244 <_Z13water_processRK11hh_mm_ss_ddm>
    186c:	f7 01       	movw	r30, r14
    186e:	20 83       	st	Z, r18
    1870:	31 83       	std	Z+1, r19	; 0x01
    1872:	42 83       	std	Z+2, r20	; 0x02
    1874:	53 83       	std	Z+3, r21	; 0x03
    1876:	64 83       	std	Z+4, r22	; 0x04
    1878:	75 83       	std	Z+5, r23	; 0x05
    187a:	86 83       	std	Z+6, r24	; 0x06
            return true;
        }
        return tmp_ss >= ptime.ss;
    }
    void after_water(){
        actual = false;
    187c:	d1 01       	movw	r26, r2
    187e:	1c 92       	st	X, r1
	
	while(1){
		vTaskDelay(1000);
		hh_mm_ss_dd current = clocks.get([](Clocks const & clk){return clk.current();});
		water_plan.apply([&current,&last_water](water_plan_array_t & plan){
			for (uint_least8_t i=0;i<plan.size();++i){
    1880:	d3 94       	inc	r13
    1882:	49 cf       	rjmp	.-366    	; 0x1716 <_Z13task_wateringPv+0x1b8>
	SemaphoreHandle_t xMutex;
	void lock(){
		xSemaphoreTake(xMutex, portMAX_DELAY);
	};
	void unlock(){
		xSemaphoreGive(xMutex);
    1884:	20 e0       	ldi	r18, 0x00	; 0
    1886:	40 e0       	ldi	r20, 0x00	; 0
    1888:	50 e0       	ldi	r21, 0x00	; 0
    188a:	60 e0       	ldi	r22, 0x00	; 0
    188c:	70 e0       	ldi	r23, 0x00	; 0
    188e:	80 91 33 02 	lds	r24, 0x0233	; 0x800233 <water_plan+0x2>
    1892:	90 91 34 02 	lds	r25, 0x0234	; 0x800234 <water_plan+0x3>
    1896:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <xQueueGenericSend>
						}
					}
				}
			}
		});
		water_every.apply([&current,&last_water](water_every_array_t & m_every){
    189a:	fe 01       	movw	r30, r28
    189c:	e0 5c       	subi	r30, 0xC0	; 192
    189e:	ff 4f       	sbci	r31, 0xFF	; 255
    18a0:	29 96       	adiw	r28, 0x09	; 9
    18a2:	ff af       	std	Y+63, r31	; 0x3f
    18a4:	ee af       	std	Y+62, r30	; 0x3e
    18a6:	29 97       	sbiw	r28, 0x09	; 9
    18a8:	ce 01       	movw	r24, r28
    18aa:	c9 96       	adiw	r24, 0x39	; 57
    18ac:	2b 96       	adiw	r28, 0x0b	; 11
    18ae:	9f af       	std	Y+63, r25	; 0x3f
    18b0:	8e af       	std	Y+62, r24	; 0x3e
    18b2:	2b 97       	sbiw	r28, 0x0b	; 11
#include "../../FreeRTOS/semphr.h"

struct mutex{
	SemaphoreHandle_t xMutex;
	void lock(){
		xSemaphoreTake(xMutex, portMAX_DELAY);
    18b4:	0d e2       	ldi	r16, 0x2D	; 45
    18b6:	12 e0       	ldi	r17, 0x02	; 2
    18b8:	20 e0       	ldi	r18, 0x00	; 0
    18ba:	4f ef       	ldi	r20, 0xFF	; 255
    18bc:	5f ef       	ldi	r21, 0xFF	; 255
    18be:	60 e0       	ldi	r22, 0x00	; 0
    18c0:	70 e0       	ldi	r23, 0x00	; 0
    18c2:	d8 01       	movw	r26, r16
    18c4:	12 96       	adiw	r26, 0x02	; 2
    18c6:	8d 91       	ld	r24, X+
    18c8:	9c 91       	ld	r25, X
    18ca:	13 97       	sbiw	r26, 0x03	; 3
    18cc:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <xQueueGenericReceive>
	template <typename Func_t,
		Std::enable_if_same_t<Std::invoke_result_t<Func_t,T &>,void,bool> = true>
	inline void apply(Func_t && F){
		//static_assert(Std::is_same_v<Std::invoke_result_t<Func_t,T &>,void>,"not void function in void spec");
		lock();
		F(value);
    18d0:	f8 01       	movw	r30, r16
    18d2:	00 81       	ld	r16, Z
    18d4:	11 81       	ldd	r17, Z+1	; 0x01
			for (uint_least8_t i=0;i<m_every.size();++i){
    18d6:	d1 2c       	mov	r13, r1
    18d8:	f3 e0       	ldi	r31, 0x03	; 3
    18da:	fd 15       	cp	r31, r13
    18dc:	08 f4       	brcc	.+2      	; 0x18e0 <_Z13task_wateringPv+0x382>
    18de:	c3 c0       	rjmp	.+390    	; 0x1a66 <_Z13task_wateringPv+0x508>
				if(m_every[i].exist_flag){
    18e0:	2d 2d       	mov	r18, r13
    18e2:	30 e0       	ldi	r19, 0x00	; 0
    18e4:	f9 01       	movw	r30, r18
    18e6:	ee 0f       	add	r30, r30
    18e8:	ff 1f       	adc	r31, r31
    18ea:	c9 01       	movw	r24, r18
    18ec:	88 0f       	add	r24, r24
    18ee:	99 1f       	adc	r25, r25
    18f0:	88 0f       	add	r24, r24
    18f2:	99 1f       	adc	r25, r25
    18f4:	88 0f       	add	r24, r24
    18f6:	99 1f       	adc	r25, r25
    18f8:	e8 0f       	add	r30, r24
    18fa:	f9 1f       	adc	r31, r25
    18fc:	e0 0f       	add	r30, r16
    18fe:	f1 1f       	adc	r31, r17
    1900:	60 81       	ld	r22, Z
    1902:	66 23       	and	r22, r22
    1904:	09 f4       	brne	.+2      	; 0x1908 <_Z13task_wateringPv+0x3aa>
    1906:	ad c0       	rjmp	.+346    	; 0x1a62 <_Z13task_wateringPv+0x504>
						}
					}
				}
			}
		});
		water_every.apply([&current,&last_water](water_every_array_t & m_every){
    1908:	29 96       	adiw	r28, 0x09	; 9
    190a:	ee ad       	ldd	r30, Y+62	; 0x3e
    190c:	ff ad       	ldd	r31, Y+63	; 0x3f
    190e:	29 97       	sbiw	r28, 0x09	; 9
			for (uint_least8_t i=0;i<m_every.size();++i){
				if(m_every[i].exist_flag){
					if(m_every[i].is_ready(current.hh,current.mm,current.ss)){
    1910:	f2 80       	ldd	r15, Z+2	; 0x02
    1912:	c1 80       	ldd	r12, Z+1	; 0x01
    1914:	70 81       	ld	r23, Z
    }
    bool is_ready(uint_least8_t tmp_hh,uint_least8_t tmp_mm,uint_least8_t tmp_ss){
        if(tmp_delayed_days < days_delay){
    1916:	ac 01       	movw	r20, r24
    1918:	c9 01       	movw	r24, r18
    191a:	88 0f       	add	r24, r24
    191c:	99 1f       	adc	r25, r25
    191e:	48 0f       	add	r20, r24
    1920:	59 1f       	adc	r21, r25
    1922:	d8 01       	movw	r26, r16
    1924:	a4 0f       	add	r26, r20
    1926:	b5 1f       	adc	r27, r21
    1928:	12 96       	adiw	r26, 0x02	; 2
    192a:	9c 91       	ld	r25, X
    192c:	12 97       	sbiw	r26, 0x02	; 2
    192e:	11 96       	adiw	r26, 0x01	; 1
    1930:	8c 91       	ld	r24, X
    1932:	98 17       	cp	r25, r24
    1934:	d0 f1       	brcs	.+116    	; 0x19aa <_Z13task_wateringPv+0x44c>
            return false;
        }
        if(hh > tmp_hh){
    1936:	c9 01       	movw	r24, r18
    1938:	88 0f       	add	r24, r24
    193a:	99 1f       	adc	r25, r25
    193c:	88 0f       	add	r24, r24
    193e:	99 1f       	adc	r25, r25
    1940:	88 0f       	add	r24, r24
    1942:	99 1f       	adc	r25, r25
    1944:	a9 01       	movw	r20, r18
    1946:	44 0f       	add	r20, r20
    1948:	55 1f       	adc	r21, r21
    194a:	84 0f       	add	r24, r20
    194c:	95 1f       	adc	r25, r21
    194e:	d8 01       	movw	r26, r16
    1950:	a8 0f       	add	r26, r24
    1952:	b9 1f       	adc	r27, r25
    1954:	13 96       	adiw	r26, 0x03	; 3
    1956:	8c 91       	ld	r24, X
    1958:	78 17       	cp	r23, r24
    195a:	48 f1       	brcs	.+82     	; 0x19ae <_Z13task_wateringPv+0x450>
            return false;
        } else if (hh < tmp_hh ) {
    195c:	87 17       	cp	r24, r23
    195e:	50 f1       	brcs	.+84     	; 0x19b4 <_Z13task_wateringPv+0x456>
            return true;
        }

        if(mm > tmp_mm){
    1960:	c9 01       	movw	r24, r18
    1962:	88 0f       	add	r24, r24
    1964:	99 1f       	adc	r25, r25
    1966:	88 0f       	add	r24, r24
    1968:	99 1f       	adc	r25, r25
    196a:	88 0f       	add	r24, r24
    196c:	99 1f       	adc	r25, r25
    196e:	da 01       	movw	r26, r20
    1970:	a8 0f       	add	r26, r24
    1972:	b9 1f       	adc	r27, r25
    1974:	a0 0f       	add	r26, r16
    1976:	b1 1f       	adc	r27, r17
    1978:	14 96       	adiw	r26, 0x04	; 4
    197a:	8c 91       	ld	r24, X
    197c:	c8 16       	cp	r12, r24
    197e:	c8 f0       	brcs	.+50     	; 0x19b2 <_Z13task_wateringPv+0x454>
            return false;
        } else if (mm < tmp_mm) {
    1980:	8c 15       	cp	r24, r12
    1982:	c0 f0       	brcs	.+48     	; 0x19b4 <_Z13task_wateringPv+0x456>
            return true;
        }
        return tmp_ss >= ss;
    1984:	c9 01       	movw	r24, r18
    1986:	88 0f       	add	r24, r24
    1988:	99 1f       	adc	r25, r25
    198a:	88 0f       	add	r24, r24
    198c:	99 1f       	adc	r25, r25
    198e:	88 0f       	add	r24, r24
    1990:	99 1f       	adc	r25, r25
    1992:	da 01       	movw	r26, r20
    1994:	a8 0f       	add	r26, r24
    1996:	b9 1f       	adc	r27, r25
    1998:	a0 0f       	add	r26, r16
    199a:	b1 1f       	adc	r27, r17
    199c:	61 e0       	ldi	r22, 0x01	; 1
    199e:	15 96       	adiw	r26, 0x05	; 5
    19a0:	8c 91       	ld	r24, X
    19a2:	f8 16       	cp	r15, r24
    19a4:	38 f4       	brcc	.+14     	; 0x19b4 <_Z13task_wateringPv+0x456>
    19a6:	60 e0       	ldi	r22, 0x00	; 0
    19a8:	05 c0       	rjmp	.+10     	; 0x19b4 <_Z13task_wateringPv+0x456>
    void next_day(){
        tmp_delayed_days++;
    }
    bool is_ready(uint_least8_t tmp_hh,uint_least8_t tmp_mm,uint_least8_t tmp_ss){
        if(tmp_delayed_days < days_delay){
            return false;
    19aa:	60 e0       	ldi	r22, 0x00	; 0
    19ac:	03 c0       	rjmp	.+6      	; 0x19b4 <_Z13task_wateringPv+0x456>
        }
        if(hh > tmp_hh){
            return false;
    19ae:	60 e0       	ldi	r22, 0x00	; 0
    19b0:	01 c0       	rjmp	.+2      	; 0x19b4 <_Z13task_wateringPv+0x456>
        } else if (hh < tmp_hh ) {
            return true;
        }

        if(mm > tmp_mm){
            return false;
    19b2:	60 e0       	ldi	r22, 0x00	; 0
    19b4:	66 23       	and	r22, r22
    19b6:	09 f4       	brne	.+2      	; 0x19ba <_Z13task_wateringPv+0x45c>
    19b8:	54 c0       	rjmp	.+168    	; 0x1a62 <_Z13task_wateringPv+0x504>
						}
					}
				}
			}
		});
		water_every.apply([&current,&last_water](water_every_array_t & m_every){
    19ba:	2b 96       	adiw	r28, 0x0b	; 11
    19bc:	ee ac       	ldd	r14, Y+62	; 0x3e
    19be:	ff ac       	ldd	r15, Y+63	; 0x3f
    19c0:	2b 97       	sbiw	r28, 0x0b	; 11
	}
	inline bool operator <(hh_mm_ss_dd const & other) const{
		return other > *this;
	}
	inline bool operator >=(hh_mm_ss_dd const & other) const{
		if(days > other.days){
    19c2:	43 80       	ldd	r4, Z+3	; 0x03
    19c4:	54 80       	ldd	r5, Z+4	; 0x04
    19c6:	65 80       	ldd	r6, Z+5	; 0x05
    19c8:	76 80       	ldd	r7, Z+6	; 0x06
    19ca:	d7 01       	movw	r26, r14
    19cc:	13 96       	adiw	r26, 0x03	; 3
    19ce:	8d 91       	ld	r24, X+
    19d0:	9d 91       	ld	r25, X+
    19d2:	0d 90       	ld	r0, X+
    19d4:	bc 91       	ld	r27, X
    19d6:	a0 2d       	mov	r26, r0
    19d8:	2f 96       	adiw	r28, 0x0f	; 15
    19da:	8c af       	std	Y+60, r24	; 0x3c
    19dc:	9d af       	std	Y+61, r25	; 0x3d
    19de:	ae af       	std	Y+62, r26	; 0x3e
    19e0:	bf af       	std	Y+63, r27	; 0x3f
    19e2:	2f 97       	sbiw	r28, 0x0f	; 15
    19e4:	84 15       	cp	r24, r4
    19e6:	95 05       	cpc	r25, r5
    19e8:	a6 05       	cpc	r26, r6
    19ea:	b7 05       	cpc	r27, r7
    19ec:	b0 f0       	brcs	.+44     	; 0x1a1a <_Z13task_wateringPv+0x4bc>
			return true;
		} else if (days < other.days) {
    19ee:	48 16       	cp	r4, r24
    19f0:	59 06       	cpc	r5, r25
    19f2:	6a 06       	cpc	r6, r26
    19f4:	7b 06       	cpc	r7, r27
    19f6:	70 f0       	brcs	.+28     	; 0x1a14 <_Z13task_wateringPv+0x4b6>
			return false;
		}
		
		if(hh > other.hh){
    19f8:	d7 01       	movw	r26, r14
    19fa:	8c 91       	ld	r24, X
    19fc:	87 17       	cp	r24, r23
    19fe:	68 f0       	brcs	.+26     	; 0x1a1a <_Z13task_wateringPv+0x4bc>
			return true;
		} else if (hh < other.hh) {
    1a00:	78 17       	cp	r23, r24
    1a02:	50 f0       	brcs	.+20     	; 0x1a18 <_Z13task_wateringPv+0x4ba>
			return false;
		}
		
		if(mm > other.mm){
    1a04:	11 96       	adiw	r26, 0x01	; 1
    1a06:	8c 91       	ld	r24, X
    1a08:	8c 15       	cp	r24, r12
    1a0a:	38 f0       	brcs	.+14     	; 0x1a1a <_Z13task_wateringPv+0x4bc>
			return true;
		} else if (mm < other.mm) {
    1a0c:	c8 16       	cp	r12, r24
    1a0e:	28 f4       	brcc	.+10     	; 0x1a1a <_Z13task_wateringPv+0x4bc>
			return false;
    1a10:	60 e0       	ldi	r22, 0x00	; 0
    1a12:	03 c0       	rjmp	.+6      	; 0x1a1a <_Z13task_wateringPv+0x4bc>
	}
	inline bool operator >=(hh_mm_ss_dd const & other) const{
		if(days > other.days){
			return true;
		} else if (days < other.days) {
			return false;
    1a14:	60 e0       	ldi	r22, 0x00	; 0
    1a16:	01 c0       	rjmp	.+2      	; 0x1a1a <_Z13task_wateringPv+0x4bc>
		}
		
		if(hh > other.hh){
			return true;
		} else if (hh < other.hh) {
			return false;
    1a18:	60 e0       	ldi	r22, 0x00	; 0
			for (uint_least8_t i=0;i<m_every.size();++i){
				if(m_every[i].exist_flag){
					if(m_every[i].is_ready(current.hh,current.mm,current.ss)){
						if(last_water <= current){
    1a1a:	66 23       	and	r22, r22
    1a1c:	11 f1       	breq	.+68     	; 0x1a62 <_Z13task_wateringPv+0x504>
							last_water = water_process(current,m_every[i].duration);
    1a1e:	19 01       	movw	r2, r18
    1a20:	22 0c       	add	r2, r2
    1a22:	33 1c       	adc	r3, r3
    1a24:	22 0f       	add	r18, r18
    1a26:	33 1f       	adc	r19, r19
    1a28:	22 0f       	add	r18, r18
    1a2a:	33 1f       	adc	r19, r19
    1a2c:	22 0f       	add	r18, r18
    1a2e:	33 1f       	adc	r19, r19
    1a30:	22 0e       	add	r2, r18
    1a32:	33 1e       	adc	r3, r19
    1a34:	20 0e       	add	r2, r16
    1a36:	31 1e       	adc	r3, r17
    1a38:	d1 01       	movw	r26, r2
    1a3a:	16 96       	adiw	r26, 0x06	; 6
    1a3c:	4d 91       	ld	r20, X+
    1a3e:	5d 91       	ld	r21, X+
    1a40:	6d 91       	ld	r22, X+
    1a42:	7c 91       	ld	r23, X
    1a44:	19 97       	sbiw	r26, 0x09	; 9
    1a46:	cf 01       	movw	r24, r30
    1a48:	0e 94 22 09 	call	0x1244	; 0x1244 <_Z13water_processRK11hh_mm_ss_ddm>
    1a4c:	f7 01       	movw	r30, r14
    1a4e:	20 83       	st	Z, r18
    1a50:	31 83       	std	Z+1, r19	; 0x01
    1a52:	42 83       	std	Z+2, r20	; 0x02
    1a54:	53 83       	std	Z+3, r21	; 0x03
    1a56:	64 83       	std	Z+4, r22	; 0x04
    1a58:	75 83       	std	Z+5, r23	; 0x05
    1a5a:	86 83       	std	Z+6, r24	; 0x06
            return true;
        }
        return tmp_ss >= ss;
    }
    void after_water(){
        tmp_delayed_days = 0;
    1a5c:	d1 01       	movw	r26, r2
    1a5e:	12 96       	adiw	r26, 0x02	; 2
    1a60:	1c 92       	st	X, r1
					}
				}
			}
		});
		water_every.apply([&current,&last_water](water_every_array_t & m_every){
			for (uint_least8_t i=0;i<m_every.size();++i){
    1a62:	d3 94       	inc	r13
    1a64:	39 cf       	rjmp	.-398    	; 0x18d8 <_Z13task_wateringPv+0x37a>
	SemaphoreHandle_t xMutex;
	void lock(){
		xSemaphoreTake(xMutex, portMAX_DELAY);
	};
	void unlock(){
		xSemaphoreGive(xMutex);
    1a66:	20 e0       	ldi	r18, 0x00	; 0
    1a68:	40 e0       	ldi	r20, 0x00	; 0
    1a6a:	50 e0       	ldi	r21, 0x00	; 0
    1a6c:	60 e0       	ldi	r22, 0x00	; 0
    1a6e:	70 e0       	ldi	r23, 0x00	; 0
    1a70:	80 91 2f 02 	lds	r24, 0x022F	; 0x80022f <water_every+0x2>
    1a74:	90 91 30 02 	lds	r25, 0x0230	; 0x800230 <water_every+0x3>
    1a78:	0e 94 b7 0e 	call	0x1d6e	; 0x1d6e <xQueueGenericSend>
}

void task_watering(void *){
	hh_mm_ss_dd last_water = clocks.get([](Clocks const & clk){return clk.current();});
	
	while(1){
    1a7c:	d4 cd       	rjmp	.-1112   	; 0x1626 <_Z13task_wateringPv+0xc8>

00001a7e <_Z11task_windowPv>:
#include "global.h"

void task_window(void *){
	while(1){
		vTaskDelay(1000);
    1a7e:	88 ee       	ldi	r24, 0xE8	; 232
    1a80:	93 e0       	ldi	r25, 0x03	; 3
    1a82:	0e 94 fb 12 	call	0x25f6	; 0x25f6 <vTaskDelay>
    1a86:	fb cf       	rjmp	.-10     	; 0x1a7e <_Z11task_windowPv>

00001a88 <__divsf3>:
    1a88:	0e 94 58 0d 	call	0x1ab0	; 0x1ab0 <__divsf3x>
    1a8c:	0c 94 cd 0d 	jmp	0x1b9a	; 0x1b9a <__fp_round>
    1a90:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <__fp_pscB>
    1a94:	58 f0       	brcs	.+22     	; 0x1aac <__divsf3+0x24>
    1a96:	0e 94 bf 0d 	call	0x1b7e	; 0x1b7e <__fp_pscA>
    1a9a:	40 f0       	brcs	.+16     	; 0x1aac <__divsf3+0x24>
    1a9c:	29 f4       	brne	.+10     	; 0x1aa8 <__divsf3+0x20>
    1a9e:	5f 3f       	cpi	r21, 0xFF	; 255
    1aa0:	29 f0       	breq	.+10     	; 0x1aac <__divsf3+0x24>
    1aa2:	0c 94 b6 0d 	jmp	0x1b6c	; 0x1b6c <__fp_inf>
    1aa6:	51 11       	cpse	r21, r1
    1aa8:	0c 94 01 0e 	jmp	0x1c02	; 0x1c02 <__fp_szero>
    1aac:	0c 94 bc 0d 	jmp	0x1b78	; 0x1b78 <__fp_nan>

00001ab0 <__divsf3x>:
    1ab0:	0e 94 de 0d 	call	0x1bbc	; 0x1bbc <__fp_split3>
    1ab4:	68 f3       	brcs	.-38     	; 0x1a90 <__divsf3+0x8>

00001ab6 <__divsf3_pse>:
    1ab6:	99 23       	and	r25, r25
    1ab8:	b1 f3       	breq	.-20     	; 0x1aa6 <__divsf3+0x1e>
    1aba:	55 23       	and	r21, r21
    1abc:	91 f3       	breq	.-28     	; 0x1aa2 <__divsf3+0x1a>
    1abe:	95 1b       	sub	r25, r21
    1ac0:	55 0b       	sbc	r21, r21
    1ac2:	bb 27       	eor	r27, r27
    1ac4:	aa 27       	eor	r26, r26
    1ac6:	62 17       	cp	r22, r18
    1ac8:	73 07       	cpc	r23, r19
    1aca:	84 07       	cpc	r24, r20
    1acc:	38 f0       	brcs	.+14     	; 0x1adc <__divsf3_pse+0x26>
    1ace:	9f 5f       	subi	r25, 0xFF	; 255
    1ad0:	5f 4f       	sbci	r21, 0xFF	; 255
    1ad2:	22 0f       	add	r18, r18
    1ad4:	33 1f       	adc	r19, r19
    1ad6:	44 1f       	adc	r20, r20
    1ad8:	aa 1f       	adc	r26, r26
    1ada:	a9 f3       	breq	.-22     	; 0x1ac6 <__divsf3_pse+0x10>
    1adc:	35 d0       	rcall	.+106    	; 0x1b48 <__divsf3_pse+0x92>
    1ade:	0e 2e       	mov	r0, r30
    1ae0:	3a f0       	brmi	.+14     	; 0x1af0 <__divsf3_pse+0x3a>
    1ae2:	e0 e8       	ldi	r30, 0x80	; 128
    1ae4:	32 d0       	rcall	.+100    	; 0x1b4a <__divsf3_pse+0x94>
    1ae6:	91 50       	subi	r25, 0x01	; 1
    1ae8:	50 40       	sbci	r21, 0x00	; 0
    1aea:	e6 95       	lsr	r30
    1aec:	00 1c       	adc	r0, r0
    1aee:	ca f7       	brpl	.-14     	; 0x1ae2 <__divsf3_pse+0x2c>
    1af0:	2b d0       	rcall	.+86     	; 0x1b48 <__divsf3_pse+0x92>
    1af2:	fe 2f       	mov	r31, r30
    1af4:	29 d0       	rcall	.+82     	; 0x1b48 <__divsf3_pse+0x92>
    1af6:	66 0f       	add	r22, r22
    1af8:	77 1f       	adc	r23, r23
    1afa:	88 1f       	adc	r24, r24
    1afc:	bb 1f       	adc	r27, r27
    1afe:	26 17       	cp	r18, r22
    1b00:	37 07       	cpc	r19, r23
    1b02:	48 07       	cpc	r20, r24
    1b04:	ab 07       	cpc	r26, r27
    1b06:	b0 e8       	ldi	r27, 0x80	; 128
    1b08:	09 f0       	breq	.+2      	; 0x1b0c <__divsf3_pse+0x56>
    1b0a:	bb 0b       	sbc	r27, r27
    1b0c:	80 2d       	mov	r24, r0
    1b0e:	bf 01       	movw	r22, r30
    1b10:	ff 27       	eor	r31, r31
    1b12:	93 58       	subi	r25, 0x83	; 131
    1b14:	5f 4f       	sbci	r21, 0xFF	; 255
    1b16:	3a f0       	brmi	.+14     	; 0x1b26 <__divsf3_pse+0x70>
    1b18:	9e 3f       	cpi	r25, 0xFE	; 254
    1b1a:	51 05       	cpc	r21, r1
    1b1c:	78 f0       	brcs	.+30     	; 0x1b3c <__divsf3_pse+0x86>
    1b1e:	0c 94 b6 0d 	jmp	0x1b6c	; 0x1b6c <__fp_inf>
    1b22:	0c 94 01 0e 	jmp	0x1c02	; 0x1c02 <__fp_szero>
    1b26:	5f 3f       	cpi	r21, 0xFF	; 255
    1b28:	e4 f3       	brlt	.-8      	; 0x1b22 <__divsf3_pse+0x6c>
    1b2a:	98 3e       	cpi	r25, 0xE8	; 232
    1b2c:	d4 f3       	brlt	.-12     	; 0x1b22 <__divsf3_pse+0x6c>
    1b2e:	86 95       	lsr	r24
    1b30:	77 95       	ror	r23
    1b32:	67 95       	ror	r22
    1b34:	b7 95       	ror	r27
    1b36:	f7 95       	ror	r31
    1b38:	9f 5f       	subi	r25, 0xFF	; 255
    1b3a:	c9 f7       	brne	.-14     	; 0x1b2e <__divsf3_pse+0x78>
    1b3c:	88 0f       	add	r24, r24
    1b3e:	91 1d       	adc	r25, r1
    1b40:	96 95       	lsr	r25
    1b42:	87 95       	ror	r24
    1b44:	97 f9       	bld	r25, 7
    1b46:	08 95       	ret
    1b48:	e1 e0       	ldi	r30, 0x01	; 1
    1b4a:	66 0f       	add	r22, r22
    1b4c:	77 1f       	adc	r23, r23
    1b4e:	88 1f       	adc	r24, r24
    1b50:	bb 1f       	adc	r27, r27
    1b52:	62 17       	cp	r22, r18
    1b54:	73 07       	cpc	r23, r19
    1b56:	84 07       	cpc	r24, r20
    1b58:	ba 07       	cpc	r27, r26
    1b5a:	20 f0       	brcs	.+8      	; 0x1b64 <__divsf3_pse+0xae>
    1b5c:	62 1b       	sub	r22, r18
    1b5e:	73 0b       	sbc	r23, r19
    1b60:	84 0b       	sbc	r24, r20
    1b62:	ba 0b       	sbc	r27, r26
    1b64:	ee 1f       	adc	r30, r30
    1b66:	88 f7       	brcc	.-30     	; 0x1b4a <__divsf3_pse+0x94>
    1b68:	e0 95       	com	r30
    1b6a:	08 95       	ret

00001b6c <__fp_inf>:
    1b6c:	97 f9       	bld	r25, 7
    1b6e:	9f 67       	ori	r25, 0x7F	; 127
    1b70:	80 e8       	ldi	r24, 0x80	; 128
    1b72:	70 e0       	ldi	r23, 0x00	; 0
    1b74:	60 e0       	ldi	r22, 0x00	; 0
    1b76:	08 95       	ret

00001b78 <__fp_nan>:
    1b78:	9f ef       	ldi	r25, 0xFF	; 255
    1b7a:	80 ec       	ldi	r24, 0xC0	; 192
    1b7c:	08 95       	ret

00001b7e <__fp_pscA>:
    1b7e:	00 24       	eor	r0, r0
    1b80:	0a 94       	dec	r0
    1b82:	16 16       	cp	r1, r22
    1b84:	17 06       	cpc	r1, r23
    1b86:	18 06       	cpc	r1, r24
    1b88:	09 06       	cpc	r0, r25
    1b8a:	08 95       	ret

00001b8c <__fp_pscB>:
    1b8c:	00 24       	eor	r0, r0
    1b8e:	0a 94       	dec	r0
    1b90:	12 16       	cp	r1, r18
    1b92:	13 06       	cpc	r1, r19
    1b94:	14 06       	cpc	r1, r20
    1b96:	05 06       	cpc	r0, r21
    1b98:	08 95       	ret

00001b9a <__fp_round>:
    1b9a:	09 2e       	mov	r0, r25
    1b9c:	03 94       	inc	r0
    1b9e:	00 0c       	add	r0, r0
    1ba0:	11 f4       	brne	.+4      	; 0x1ba6 <__fp_round+0xc>
    1ba2:	88 23       	and	r24, r24
    1ba4:	52 f0       	brmi	.+20     	; 0x1bba <__fp_round+0x20>
    1ba6:	bb 0f       	add	r27, r27
    1ba8:	40 f4       	brcc	.+16     	; 0x1bba <__fp_round+0x20>
    1baa:	bf 2b       	or	r27, r31
    1bac:	11 f4       	brne	.+4      	; 0x1bb2 <__fp_round+0x18>
    1bae:	60 ff       	sbrs	r22, 0
    1bb0:	04 c0       	rjmp	.+8      	; 0x1bba <__fp_round+0x20>
    1bb2:	6f 5f       	subi	r22, 0xFF	; 255
    1bb4:	7f 4f       	sbci	r23, 0xFF	; 255
    1bb6:	8f 4f       	sbci	r24, 0xFF	; 255
    1bb8:	9f 4f       	sbci	r25, 0xFF	; 255
    1bba:	08 95       	ret

00001bbc <__fp_split3>:
    1bbc:	57 fd       	sbrc	r21, 7
    1bbe:	90 58       	subi	r25, 0x80	; 128
    1bc0:	44 0f       	add	r20, r20
    1bc2:	55 1f       	adc	r21, r21
    1bc4:	59 f0       	breq	.+22     	; 0x1bdc <__fp_splitA+0x10>
    1bc6:	5f 3f       	cpi	r21, 0xFF	; 255
    1bc8:	71 f0       	breq	.+28     	; 0x1be6 <__fp_splitA+0x1a>
    1bca:	47 95       	ror	r20

00001bcc <__fp_splitA>:
    1bcc:	88 0f       	add	r24, r24
    1bce:	97 fb       	bst	r25, 7
    1bd0:	99 1f       	adc	r25, r25
    1bd2:	61 f0       	breq	.+24     	; 0x1bec <__fp_splitA+0x20>
    1bd4:	9f 3f       	cpi	r25, 0xFF	; 255
    1bd6:	79 f0       	breq	.+30     	; 0x1bf6 <__fp_splitA+0x2a>
    1bd8:	87 95       	ror	r24
    1bda:	08 95       	ret
    1bdc:	12 16       	cp	r1, r18
    1bde:	13 06       	cpc	r1, r19
    1be0:	14 06       	cpc	r1, r20
    1be2:	55 1f       	adc	r21, r21
    1be4:	f2 cf       	rjmp	.-28     	; 0x1bca <__fp_split3+0xe>
    1be6:	46 95       	lsr	r20
    1be8:	f1 df       	rcall	.-30     	; 0x1bcc <__fp_splitA>
    1bea:	08 c0       	rjmp	.+16     	; 0x1bfc <__fp_splitA+0x30>
    1bec:	16 16       	cp	r1, r22
    1bee:	17 06       	cpc	r1, r23
    1bf0:	18 06       	cpc	r1, r24
    1bf2:	99 1f       	adc	r25, r25
    1bf4:	f1 cf       	rjmp	.-30     	; 0x1bd8 <__fp_splitA+0xc>
    1bf6:	86 95       	lsr	r24
    1bf8:	71 05       	cpc	r23, r1
    1bfa:	61 05       	cpc	r22, r1
    1bfc:	08 94       	sec
    1bfe:	08 95       	ret

00001c00 <__fp_zero>:
    1c00:	e8 94       	clt

00001c02 <__fp_szero>:
    1c02:	bb 27       	eor	r27, r27
    1c04:	66 27       	eor	r22, r22
    1c06:	77 27       	eor	r23, r23
    1c08:	cb 01       	movw	r24, r22
    1c0a:	97 f9       	bld	r25, 7
    1c0c:	08 95       	ret

00001c0e <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1c0e:	0f 93       	push	r16
    1c10:	1f 93       	push	r17
    1c12:	cf 93       	push	r28
    1c14:	df 93       	push	r29
    1c16:	ec 01       	movw	r28, r24
    1c18:	04 2f       	mov	r16, r20
    1c1a:	1a 8d       	ldd	r17, Y+26	; 0x1a
    1c1c:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1c1e:	44 23       	and	r20, r20
    1c20:	b9 f1       	breq	.+110    	; 0x1c90 <prvCopyDataToQueue+0x82>
    1c22:	01 11       	cpse	r16, r1
    1c24:	16 c0       	rjmp	.+44     	; 0x1c52 <prvCopyDataToQueue+0x44>
    1c26:	50 e0       	ldi	r21, 0x00	; 0
    1c28:	8c 81       	ldd	r24, Y+4	; 0x04
    1c2a:	9d 81       	ldd	r25, Y+5	; 0x05
    1c2c:	0e 94 57 1e 	call	0x3cae	; 0x3cae <memcpy>
    1c30:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1c32:	8c 81       	ldd	r24, Y+4	; 0x04
    1c34:	9d 81       	ldd	r25, Y+5	; 0x05
    1c36:	82 0f       	add	r24, r18
    1c38:	91 1d       	adc	r25, r1
    1c3a:	9d 83       	std	Y+5, r25	; 0x05
    1c3c:	8c 83       	std	Y+4, r24	; 0x04
    1c3e:	2a 81       	ldd	r18, Y+2	; 0x02
    1c40:	3b 81       	ldd	r19, Y+3	; 0x03
    1c42:	82 17       	cp	r24, r18
    1c44:	93 07       	cpc	r25, r19
    1c46:	20 f1       	brcs	.+72     	; 0x1c90 <prvCopyDataToQueue+0x82>
    1c48:	88 81       	ld	r24, Y
    1c4a:	99 81       	ldd	r25, Y+1	; 0x01
    1c4c:	9d 83       	std	Y+5, r25	; 0x05
    1c4e:	8c 83       	std	Y+4, r24	; 0x04
    1c50:	1f c0       	rjmp	.+62     	; 0x1c90 <prvCopyDataToQueue+0x82>
    1c52:	50 e0       	ldi	r21, 0x00	; 0
    1c54:	8e 81       	ldd	r24, Y+6	; 0x06
    1c56:	9f 81       	ldd	r25, Y+7	; 0x07
    1c58:	0e 94 57 1e 	call	0x3cae	; 0x3cae <memcpy>
    1c5c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1c5e:	90 e0       	ldi	r25, 0x00	; 0
    1c60:	91 95       	neg	r25
    1c62:	81 95       	neg	r24
    1c64:	91 09       	sbc	r25, r1
    1c66:	2e 81       	ldd	r18, Y+6	; 0x06
    1c68:	3f 81       	ldd	r19, Y+7	; 0x07
    1c6a:	28 0f       	add	r18, r24
    1c6c:	39 1f       	adc	r19, r25
    1c6e:	3f 83       	std	Y+7, r19	; 0x07
    1c70:	2e 83       	std	Y+6, r18	; 0x06
    1c72:	48 81       	ld	r20, Y
    1c74:	59 81       	ldd	r21, Y+1	; 0x01
    1c76:	24 17       	cp	r18, r20
    1c78:	35 07       	cpc	r19, r21
    1c7a:	30 f4       	brcc	.+12     	; 0x1c88 <prvCopyDataToQueue+0x7a>
    1c7c:	2a 81       	ldd	r18, Y+2	; 0x02
    1c7e:	3b 81       	ldd	r19, Y+3	; 0x03
    1c80:	82 0f       	add	r24, r18
    1c82:	93 1f       	adc	r25, r19
    1c84:	9f 83       	std	Y+7, r25	; 0x07
    1c86:	8e 83       	std	Y+6, r24	; 0x06
    1c88:	02 30       	cpi	r16, 0x02	; 2
    1c8a:	11 f4       	brne	.+4      	; 0x1c90 <prvCopyDataToQueue+0x82>
    1c8c:	11 11       	cpse	r17, r1
    1c8e:	11 50       	subi	r17, 0x01	; 1
    1c90:	1f 5f       	subi	r17, 0xFF	; 255
    1c92:	1a 8f       	std	Y+26, r17	; 0x1a
    1c94:	80 e0       	ldi	r24, 0x00	; 0
    1c96:	df 91       	pop	r29
    1c98:	cf 91       	pop	r28
    1c9a:	1f 91       	pop	r17
    1c9c:	0f 91       	pop	r16
    1c9e:	08 95       	ret

00001ca0 <prvCopyDataFromQueue>:
    1ca0:	fc 01       	movw	r30, r24
    1ca2:	44 8d       	ldd	r20, Z+28	; 0x1c
    1ca4:	44 23       	and	r20, r20
    1ca6:	a9 f0       	breq	.+42     	; 0x1cd2 <prvCopyDataFromQueue+0x32>
    1ca8:	50 e0       	ldi	r21, 0x00	; 0
    1caa:	26 81       	ldd	r18, Z+6	; 0x06
    1cac:	37 81       	ldd	r19, Z+7	; 0x07
    1cae:	24 0f       	add	r18, r20
    1cb0:	35 1f       	adc	r19, r21
    1cb2:	37 83       	std	Z+7, r19	; 0x07
    1cb4:	26 83       	std	Z+6, r18	; 0x06
    1cb6:	82 81       	ldd	r24, Z+2	; 0x02
    1cb8:	93 81       	ldd	r25, Z+3	; 0x03
    1cba:	28 17       	cp	r18, r24
    1cbc:	39 07       	cpc	r19, r25
    1cbe:	20 f0       	brcs	.+8      	; 0x1cc8 <prvCopyDataFromQueue+0x28>
    1cc0:	80 81       	ld	r24, Z
    1cc2:	91 81       	ldd	r25, Z+1	; 0x01
    1cc4:	97 83       	std	Z+7, r25	; 0x07
    1cc6:	86 83       	std	Z+6, r24	; 0x06
    1cc8:	cb 01       	movw	r24, r22
    1cca:	66 81       	ldd	r22, Z+6	; 0x06
    1ccc:	77 81       	ldd	r23, Z+7	; 0x07
    1cce:	0e 94 57 1e 	call	0x3cae	; 0x3cae <memcpy>
    1cd2:	08 95       	ret

00001cd4 <prvUnlockQueue>:
    1cd4:	ef 92       	push	r14
    1cd6:	ff 92       	push	r15
    1cd8:	0f 93       	push	r16
    1cda:	1f 93       	push	r17
    1cdc:	cf 93       	push	r28
    1cde:	8c 01       	movw	r16, r24
    1ce0:	0f b6       	in	r0, 0x3f	; 63
    1ce2:	f8 94       	cli
    1ce4:	0f 92       	push	r0
    1ce6:	fc 01       	movw	r30, r24
    1ce8:	c6 8d       	ldd	r28, Z+30	; 0x1e
    1cea:	1c 16       	cp	r1, r28
    1cec:	ac f4       	brge	.+42     	; 0x1d18 <prvUnlockQueue+0x44>
    1cee:	81 89       	ldd	r24, Z+17	; 0x11
    1cf0:	81 11       	cpse	r24, r1
    1cf2:	06 c0       	rjmp	.+12     	; 0x1d00 <prvUnlockQueue+0x2c>
    1cf4:	11 c0       	rjmp	.+34     	; 0x1d18 <prvUnlockQueue+0x44>
    1cf6:	f8 01       	movw	r30, r16
    1cf8:	81 89       	ldd	r24, Z+17	; 0x11
    1cfa:	81 11       	cpse	r24, r1
    1cfc:	05 c0       	rjmp	.+10     	; 0x1d08 <prvUnlockQueue+0x34>
    1cfe:	0c c0       	rjmp	.+24     	; 0x1d18 <prvUnlockQueue+0x44>
    1d00:	78 01       	movw	r14, r16
    1d02:	f1 e1       	ldi	r31, 0x11	; 17
    1d04:	ef 0e       	add	r14, r31
    1d06:	f1 1c       	adc	r15, r1
    1d08:	c7 01       	movw	r24, r14
    1d0a:	0e 94 c4 13 	call	0x2788	; 0x2788 <xTaskRemoveFromEventList>
    1d0e:	81 11       	cpse	r24, r1
    1d10:	0e 94 50 14 	call	0x28a0	; 0x28a0 <vTaskMissedYield>
    1d14:	c1 50       	subi	r28, 0x01	; 1
    1d16:	79 f7       	brne	.-34     	; 0x1cf6 <prvUnlockQueue+0x22>
    1d18:	8f ef       	ldi	r24, 0xFF	; 255
    1d1a:	f8 01       	movw	r30, r16
    1d1c:	86 8f       	std	Z+30, r24	; 0x1e
    1d1e:	0f 90       	pop	r0
    1d20:	0f be       	out	0x3f, r0	; 63
    1d22:	0f b6       	in	r0, 0x3f	; 63
    1d24:	f8 94       	cli
    1d26:	0f 92       	push	r0
    1d28:	c5 8d       	ldd	r28, Z+29	; 0x1d
    1d2a:	1c 16       	cp	r1, r28
    1d2c:	ac f4       	brge	.+42     	; 0x1d58 <prvUnlockQueue+0x84>
    1d2e:	80 85       	ldd	r24, Z+8	; 0x08
    1d30:	81 11       	cpse	r24, r1
    1d32:	06 c0       	rjmp	.+12     	; 0x1d40 <prvUnlockQueue+0x6c>
    1d34:	11 c0       	rjmp	.+34     	; 0x1d58 <prvUnlockQueue+0x84>
    1d36:	f8 01       	movw	r30, r16
    1d38:	80 85       	ldd	r24, Z+8	; 0x08
    1d3a:	81 11       	cpse	r24, r1
    1d3c:	05 c0       	rjmp	.+10     	; 0x1d48 <prvUnlockQueue+0x74>
    1d3e:	0c c0       	rjmp	.+24     	; 0x1d58 <prvUnlockQueue+0x84>
    1d40:	78 01       	movw	r14, r16
    1d42:	f8 e0       	ldi	r31, 0x08	; 8
    1d44:	ef 0e       	add	r14, r31
    1d46:	f1 1c       	adc	r15, r1
    1d48:	c7 01       	movw	r24, r14
    1d4a:	0e 94 c4 13 	call	0x2788	; 0x2788 <xTaskRemoveFromEventList>
    1d4e:	81 11       	cpse	r24, r1
    1d50:	0e 94 50 14 	call	0x28a0	; 0x28a0 <vTaskMissedYield>
    1d54:	c1 50       	subi	r28, 0x01	; 1
    1d56:	79 f7       	brne	.-34     	; 0x1d36 <prvUnlockQueue+0x62>
    1d58:	8f ef       	ldi	r24, 0xFF	; 255
    1d5a:	f8 01       	movw	r30, r16
    1d5c:	85 8f       	std	Z+29, r24	; 0x1d
    1d5e:	0f 90       	pop	r0
    1d60:	0f be       	out	0x3f, r0	; 63
    1d62:	cf 91       	pop	r28
    1d64:	1f 91       	pop	r17
    1d66:	0f 91       	pop	r16
    1d68:	ff 90       	pop	r15
    1d6a:	ef 90       	pop	r14
    1d6c:	08 95       	ret

00001d6e <xQueueGenericSend>:
    1d6e:	9f 92       	push	r9
    1d70:	af 92       	push	r10
    1d72:	bf 92       	push	r11
    1d74:	cf 92       	push	r12
    1d76:	df 92       	push	r13
    1d78:	ef 92       	push	r14
    1d7a:	ff 92       	push	r15
    1d7c:	0f 93       	push	r16
    1d7e:	1f 93       	push	r17
    1d80:	cf 93       	push	r28
    1d82:	df 93       	push	r29
    1d84:	00 d0       	rcall	.+0      	; 0x1d86 <xQueueGenericSend+0x18>
    1d86:	00 d0       	rcall	.+0      	; 0x1d88 <xQueueGenericSend+0x1a>
    1d88:	1f 92       	push	r1
    1d8a:	cd b7       	in	r28, 0x3d	; 61
    1d8c:	de b7       	in	r29, 0x3e	; 62
    1d8e:	8c 01       	movw	r16, r24
    1d90:	6b 01       	movw	r12, r22
    1d92:	5d 83       	std	Y+5, r21	; 0x05
    1d94:	4c 83       	std	Y+4, r20	; 0x04
    1d96:	a2 2e       	mov	r10, r18
    1d98:	b1 2c       	mov	r11, r1
    1d9a:	99 24       	eor	r9, r9
    1d9c:	93 94       	inc	r9
    1d9e:	7c 01       	movw	r14, r24
    1da0:	88 e0       	ldi	r24, 0x08	; 8
    1da2:	e8 0e       	add	r14, r24
    1da4:	f1 1c       	adc	r15, r1
    1da6:	0f b6       	in	r0, 0x3f	; 63
    1da8:	f8 94       	cli
    1daa:	0f 92       	push	r0
    1dac:	f8 01       	movw	r30, r16
    1dae:	92 8d       	ldd	r25, Z+26	; 0x1a
    1db0:	83 8d       	ldd	r24, Z+27	; 0x1b
    1db2:	98 17       	cp	r25, r24
    1db4:	18 f0       	brcs	.+6      	; 0x1dbc <xQueueGenericSend+0x4e>
    1db6:	f2 e0       	ldi	r31, 0x02	; 2
    1db8:	af 12       	cpse	r10, r31
    1dba:	19 c0       	rjmp	.+50     	; 0x1dee <xQueueGenericSend+0x80>
    1dbc:	4a 2d       	mov	r20, r10
    1dbe:	b6 01       	movw	r22, r12
    1dc0:	c8 01       	movw	r24, r16
    1dc2:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <prvCopyDataToQueue>
    1dc6:	f8 01       	movw	r30, r16
    1dc8:	91 89       	ldd	r25, Z+17	; 0x11
    1dca:	99 23       	and	r25, r25
    1dcc:	49 f0       	breq	.+18     	; 0x1de0 <xQueueGenericSend+0x72>
    1dce:	c8 01       	movw	r24, r16
    1dd0:	41 96       	adiw	r24, 0x11	; 17
    1dd2:	0e 94 c4 13 	call	0x2788	; 0x2788 <xTaskRemoveFromEventList>
    1dd6:	88 23       	and	r24, r24
    1dd8:	31 f0       	breq	.+12     	; 0x1de6 <xQueueGenericSend+0x78>
    1dda:	0e 94 bc 15 	call	0x2b78	; 0x2b78 <vPortYield>
    1dde:	03 c0       	rjmp	.+6      	; 0x1de6 <xQueueGenericSend+0x78>
    1de0:	81 11       	cpse	r24, r1
    1de2:	0e 94 bc 15 	call	0x2b78	; 0x2b78 <vPortYield>
    1de6:	0f 90       	pop	r0
    1de8:	0f be       	out	0x3f, r0	; 63
    1dea:	81 e0       	ldi	r24, 0x01	; 1
    1dec:	50 c0       	rjmp	.+160    	; 0x1e8e <xQueueGenericSend+0x120>
    1dee:	8c 81       	ldd	r24, Y+4	; 0x04
    1df0:	9d 81       	ldd	r25, Y+5	; 0x05
    1df2:	89 2b       	or	r24, r25
    1df4:	21 f4       	brne	.+8      	; 0x1dfe <xQueueGenericSend+0x90>
    1df6:	0f 90       	pop	r0
    1df8:	0f be       	out	0x3f, r0	; 63
    1dfa:	80 e0       	ldi	r24, 0x00	; 0
    1dfc:	48 c0       	rjmp	.+144    	; 0x1e8e <xQueueGenericSend+0x120>
    1dfe:	b1 10       	cpse	r11, r1
    1e00:	05 c0       	rjmp	.+10     	; 0x1e0c <xQueueGenericSend+0x9e>
    1e02:	ce 01       	movw	r24, r28
    1e04:	01 96       	adiw	r24, 0x01	; 1
    1e06:	0e 94 0c 14 	call	0x2818	; 0x2818 <vTaskSetTimeOutState>
    1e0a:	b9 2c       	mov	r11, r9
    1e0c:	0f 90       	pop	r0
    1e0e:	0f be       	out	0x3f, r0	; 63
    1e10:	0e 94 bb 11 	call	0x2376	; 0x2376 <vTaskSuspendAll>
    1e14:	0f b6       	in	r0, 0x3f	; 63
    1e16:	f8 94       	cli
    1e18:	0f 92       	push	r0
    1e1a:	f8 01       	movw	r30, r16
    1e1c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1e1e:	8f 3f       	cpi	r24, 0xFF	; 255
    1e20:	09 f4       	brne	.+2      	; 0x1e24 <xQueueGenericSend+0xb6>
    1e22:	15 8e       	std	Z+29, r1	; 0x1d
    1e24:	f8 01       	movw	r30, r16
    1e26:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e28:	8f 3f       	cpi	r24, 0xFF	; 255
    1e2a:	09 f4       	brne	.+2      	; 0x1e2e <xQueueGenericSend+0xc0>
    1e2c:	16 8e       	std	Z+30, r1	; 0x1e
    1e2e:	0f 90       	pop	r0
    1e30:	0f be       	out	0x3f, r0	; 63
    1e32:	be 01       	movw	r22, r28
    1e34:	6c 5f       	subi	r22, 0xFC	; 252
    1e36:	7f 4f       	sbci	r23, 0xFF	; 255
    1e38:	ce 01       	movw	r24, r28
    1e3a:	01 96       	adiw	r24, 0x01	; 1
    1e3c:	0e 94 17 14 	call	0x282e	; 0x282e <xTaskCheckForTimeOut>
    1e40:	81 11       	cpse	r24, r1
    1e42:	1f c0       	rjmp	.+62     	; 0x1e82 <xQueueGenericSend+0x114>
    1e44:	0f b6       	in	r0, 0x3f	; 63
    1e46:	f8 94       	cli
    1e48:	0f 92       	push	r0
    1e4a:	f8 01       	movw	r30, r16
    1e4c:	92 8d       	ldd	r25, Z+26	; 0x1a
    1e4e:	0f 90       	pop	r0
    1e50:	0f be       	out	0x3f, r0	; 63
    1e52:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e54:	98 13       	cpse	r25, r24
    1e56:	0f c0       	rjmp	.+30     	; 0x1e76 <xQueueGenericSend+0x108>
    1e58:	6c 81       	ldd	r22, Y+4	; 0x04
    1e5a:	7d 81       	ldd	r23, Y+5	; 0x05
    1e5c:	c7 01       	movw	r24, r14
    1e5e:	0e 94 b2 13 	call	0x2764	; 0x2764 <vTaskPlaceOnEventList>
    1e62:	c8 01       	movw	r24, r16
    1e64:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <prvUnlockQueue>
    1e68:	0e 94 7c 12 	call	0x24f8	; 0x24f8 <xTaskResumeAll>
    1e6c:	81 11       	cpse	r24, r1
    1e6e:	9b cf       	rjmp	.-202    	; 0x1da6 <xQueueGenericSend+0x38>
    1e70:	0e 94 bc 15 	call	0x2b78	; 0x2b78 <vPortYield>
    1e74:	98 cf       	rjmp	.-208    	; 0x1da6 <xQueueGenericSend+0x38>
    1e76:	c8 01       	movw	r24, r16
    1e78:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <prvUnlockQueue>
    1e7c:	0e 94 7c 12 	call	0x24f8	; 0x24f8 <xTaskResumeAll>
    1e80:	92 cf       	rjmp	.-220    	; 0x1da6 <xQueueGenericSend+0x38>
    1e82:	c8 01       	movw	r24, r16
    1e84:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <prvUnlockQueue>
    1e88:	0e 94 7c 12 	call	0x24f8	; 0x24f8 <xTaskResumeAll>
    1e8c:	80 e0       	ldi	r24, 0x00	; 0
    1e8e:	0f 90       	pop	r0
    1e90:	0f 90       	pop	r0
    1e92:	0f 90       	pop	r0
    1e94:	0f 90       	pop	r0
    1e96:	0f 90       	pop	r0
    1e98:	df 91       	pop	r29
    1e9a:	cf 91       	pop	r28
    1e9c:	1f 91       	pop	r17
    1e9e:	0f 91       	pop	r16
    1ea0:	ff 90       	pop	r15
    1ea2:	ef 90       	pop	r14
    1ea4:	df 90       	pop	r13
    1ea6:	cf 90       	pop	r12
    1ea8:	bf 90       	pop	r11
    1eaa:	af 90       	pop	r10
    1eac:	9f 90       	pop	r9
    1eae:	08 95       	ret

00001eb0 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1eb0:	8f 92       	push	r8
    1eb2:	9f 92       	push	r9
    1eb4:	af 92       	push	r10
    1eb6:	bf 92       	push	r11
    1eb8:	cf 92       	push	r12
    1eba:	df 92       	push	r13
    1ebc:	ef 92       	push	r14
    1ebe:	ff 92       	push	r15
    1ec0:	0f 93       	push	r16
    1ec2:	1f 93       	push	r17
    1ec4:	cf 93       	push	r28
    1ec6:	df 93       	push	r29
    1ec8:	00 d0       	rcall	.+0      	; 0x1eca <xQueueGenericReceive+0x1a>
    1eca:	00 d0       	rcall	.+0      	; 0x1ecc <xQueueGenericReceive+0x1c>
    1ecc:	1f 92       	push	r1
    1ece:	cd b7       	in	r28, 0x3d	; 61
    1ed0:	de b7       	in	r29, 0x3e	; 62
    1ed2:	8c 01       	movw	r16, r24
    1ed4:	5b 01       	movw	r10, r22
    1ed6:	5d 83       	std	Y+5, r21	; 0x05
    1ed8:	4c 83       	std	Y+4, r20	; 0x04
    1eda:	82 2e       	mov	r8, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1edc:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1ede:	99 24       	eor	r9, r9
    1ee0:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1ee2:	6c 01       	movw	r12, r24
    1ee4:	81 e1       	ldi	r24, 0x11	; 17
    1ee6:	c8 0e       	add	r12, r24
    1ee8:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1eea:	0f b6       	in	r0, 0x3f	; 63
    1eec:	f8 94       	cli
    1eee:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1ef0:	f8 01       	movw	r30, r16
    1ef2:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1ef4:	ff 20       	and	r15, r15
    1ef6:	41 f1       	breq	.+80     	; 0x1f48 <xQueueGenericReceive+0x98>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1ef8:	c6 80       	ldd	r12, Z+6	; 0x06
    1efa:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1efc:	b5 01       	movw	r22, r10
    1efe:	c8 01       	movw	r24, r16
    1f00:	0e 94 50 0e 	call	0x1ca0	; 0x1ca0 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1f04:	81 10       	cpse	r8, r1
    1f06:	0f c0       	rjmp	.+30     	; 0x1f26 <xQueueGenericReceive+0x76>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    1f08:	fa 94       	dec	r15
    1f0a:	f8 01       	movw	r30, r16
    1f0c:	f2 8e       	std	Z+26, r15	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1f0e:	80 85       	ldd	r24, Z+8	; 0x08
    1f10:	88 23       	and	r24, r24
    1f12:	b1 f0       	breq	.+44     	; 0x1f40 <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1f14:	c8 01       	movw	r24, r16
    1f16:	08 96       	adiw	r24, 0x08	; 8
    1f18:	0e 94 c4 13 	call	0x2788	; 0x2788 <xTaskRemoveFromEventList>
    1f1c:	88 23       	and	r24, r24
    1f1e:	81 f0       	breq	.+32     	; 0x1f40 <xQueueGenericReceive+0x90>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1f20:	0e 94 bc 15 	call	0x2b78	; 0x2b78 <vPortYield>
    1f24:	0d c0       	rjmp	.+26     	; 0x1f40 <xQueueGenericReceive+0x90>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1f26:	f8 01       	movw	r30, r16
    1f28:	d7 82       	std	Z+7, r13	; 0x07
    1f2a:	c6 82       	std	Z+6, r12	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1f2c:	81 89       	ldd	r24, Z+17	; 0x11
    1f2e:	88 23       	and	r24, r24
    1f30:	39 f0       	breq	.+14     	; 0x1f40 <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1f32:	c8 01       	movw	r24, r16
    1f34:	41 96       	adiw	r24, 0x11	; 17
    1f36:	0e 94 c4 13 	call	0x2788	; 0x2788 <xTaskRemoveFromEventList>
    1f3a:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1f3c:	0e 94 bc 15 	call	0x2b78	; 0x2b78 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1f40:	0f 90       	pop	r0
    1f42:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1f44:	81 e0       	ldi	r24, 0x01	; 1
    1f46:	57 c0       	rjmp	.+174    	; 0x1ff6 <xQueueGenericReceive+0x146>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1f48:	8c 81       	ldd	r24, Y+4	; 0x04
    1f4a:	9d 81       	ldd	r25, Y+5	; 0x05
    1f4c:	89 2b       	or	r24, r25
    1f4e:	21 f4       	brne	.+8      	; 0x1f58 <xQueueGenericReceive+0xa8>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1f50:	0f 90       	pop	r0
    1f52:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1f54:	80 e0       	ldi	r24, 0x00	; 0
    1f56:	4f c0       	rjmp	.+158    	; 0x1ff6 <xQueueGenericReceive+0x146>
				}
				else if( xEntryTimeSet == pdFALSE )
    1f58:	e1 10       	cpse	r14, r1
    1f5a:	05 c0       	rjmp	.+10     	; 0x1f66 <xQueueGenericReceive+0xb6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1f5c:	ce 01       	movw	r24, r28
    1f5e:	01 96       	adiw	r24, 0x01	; 1
    1f60:	0e 94 0c 14 	call	0x2818	; 0x2818 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1f64:	e9 2c       	mov	r14, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1f66:	0f 90       	pop	r0
    1f68:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1f6a:	0e 94 bb 11 	call	0x2376	; 0x2376 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1f6e:	0f b6       	in	r0, 0x3f	; 63
    1f70:	f8 94       	cli
    1f72:	0f 92       	push	r0
    1f74:	f8 01       	movw	r30, r16
    1f76:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f78:	8f 3f       	cpi	r24, 0xFF	; 255
    1f7a:	09 f4       	brne	.+2      	; 0x1f7e <xQueueGenericReceive+0xce>
    1f7c:	15 8e       	std	Z+29, r1	; 0x1d
    1f7e:	f8 01       	movw	r30, r16
    1f80:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f82:	8f 3f       	cpi	r24, 0xFF	; 255
    1f84:	09 f4       	brne	.+2      	; 0x1f88 <xQueueGenericReceive+0xd8>
    1f86:	16 8e       	std	Z+30, r1	; 0x1e
    1f88:	0f 90       	pop	r0
    1f8a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1f8c:	be 01       	movw	r22, r28
    1f8e:	6c 5f       	subi	r22, 0xFC	; 252
    1f90:	7f 4f       	sbci	r23, 0xFF	; 255
    1f92:	ce 01       	movw	r24, r28
    1f94:	01 96       	adiw	r24, 0x01	; 1
    1f96:	0e 94 17 14 	call	0x282e	; 0x282e <xTaskCheckForTimeOut>
    1f9a:	81 11       	cpse	r24, r1
    1f9c:	1e c0       	rjmp	.+60     	; 0x1fda <xQueueGenericReceive+0x12a>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1f9e:	0f b6       	in	r0, 0x3f	; 63
    1fa0:	f8 94       	cli
    1fa2:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1fa4:	f8 01       	movw	r30, r16
    1fa6:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1fa8:	0f 90       	pop	r0
    1faa:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1fac:	81 11       	cpse	r24, r1
    1fae:	0f c0       	rjmp	.+30     	; 0x1fce <xQueueGenericReceive+0x11e>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1fb0:	6c 81       	ldd	r22, Y+4	; 0x04
    1fb2:	7d 81       	ldd	r23, Y+5	; 0x05
    1fb4:	c6 01       	movw	r24, r12
    1fb6:	0e 94 b2 13 	call	0x2764	; 0x2764 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1fba:	c8 01       	movw	r24, r16
    1fbc:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1fc0:	0e 94 7c 12 	call	0x24f8	; 0x24f8 <xTaskResumeAll>
    1fc4:	81 11       	cpse	r24, r1
    1fc6:	91 cf       	rjmp	.-222    	; 0x1eea <xQueueGenericReceive+0x3a>
				{
					portYIELD_WITHIN_API();
    1fc8:	0e 94 bc 15 	call	0x2b78	; 0x2b78 <vPortYield>
    1fcc:	8e cf       	rjmp	.-228    	; 0x1eea <xQueueGenericReceive+0x3a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1fce:	c8 01       	movw	r24, r16
    1fd0:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1fd4:	0e 94 7c 12 	call	0x24f8	; 0x24f8 <xTaskResumeAll>
    1fd8:	88 cf       	rjmp	.-240    	; 0x1eea <xQueueGenericReceive+0x3a>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1fda:	c8 01       	movw	r24, r16
    1fdc:	0e 94 6a 0e 	call	0x1cd4	; 0x1cd4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1fe0:	0e 94 7c 12 	call	0x24f8	; 0x24f8 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1fe4:	0f b6       	in	r0, 0x3f	; 63
    1fe6:	f8 94       	cli
    1fe8:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1fea:	f8 01       	movw	r30, r16
    1fec:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1fee:	0f 90       	pop	r0
    1ff0:	0f be       	out	0x3f, r0	; 63
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1ff2:	81 11       	cpse	r24, r1
    1ff4:	7a cf       	rjmp	.-268    	; 0x1eea <xQueueGenericReceive+0x3a>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    1ff6:	0f 90       	pop	r0
    1ff8:	0f 90       	pop	r0
    1ffa:	0f 90       	pop	r0
    1ffc:	0f 90       	pop	r0
    1ffe:	0f 90       	pop	r0
    2000:	df 91       	pop	r29
    2002:	cf 91       	pop	r28
    2004:	1f 91       	pop	r17
    2006:	0f 91       	pop	r16
    2008:	ff 90       	pop	r15
    200a:	ef 90       	pop	r14
    200c:	df 90       	pop	r13
    200e:	cf 90       	pop	r12
    2010:	bf 90       	pop	r11
    2012:	af 90       	pop	r10
    2014:	9f 90       	pop	r9
    2016:	8f 90       	pop	r8
    2018:	08 95       	ret

0000201a <prvResetNextTaskUnblockTime>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    201a:	e0 91 66 02 	lds	r30, 0x0266	; 0x800266 <pxDelayedTaskList>
    201e:	f0 91 67 02 	lds	r31, 0x0267	; 0x800267 <pxDelayedTaskList+0x1>
    2022:	80 81       	ld	r24, Z
    2024:	81 11       	cpse	r24, r1
    2026:	07 c0       	rjmp	.+14     	; 0x2036 <prvResetNextTaskUnblockTime+0x1c>
    2028:	8f ef       	ldi	r24, 0xFF	; 255
    202a:	9f ef       	ldi	r25, 0xFF	; 255
    202c:	90 93 3e 02 	sts	0x023E, r25	; 0x80023e <xNextTaskUnblockTime+0x1>
    2030:	80 93 3d 02 	sts	0x023D, r24	; 0x80023d <xNextTaskUnblockTime>
    2034:	08 95       	ret
    2036:	e0 91 66 02 	lds	r30, 0x0266	; 0x800266 <pxDelayedTaskList>
    203a:	f0 91 67 02 	lds	r31, 0x0267	; 0x800267 <pxDelayedTaskList+0x1>
    203e:	05 80       	ldd	r0, Z+5	; 0x05
    2040:	f6 81       	ldd	r31, Z+6	; 0x06
    2042:	e0 2d       	mov	r30, r0
    2044:	06 80       	ldd	r0, Z+6	; 0x06
    2046:	f7 81       	ldd	r31, Z+7	; 0x07
    2048:	e0 2d       	mov	r30, r0
    204a:	82 81       	ldd	r24, Z+2	; 0x02
    204c:	93 81       	ldd	r25, Z+3	; 0x03
    204e:	90 93 3e 02 	sts	0x023E, r25	; 0x80023e <xNextTaskUnblockTime+0x1>
    2052:	80 93 3d 02 	sts	0x023D, r24	; 0x80023d <xNextTaskUnblockTime>
    2056:	08 95       	ret

00002058 <prvAddCurrentTaskToDelayedList>:
    2058:	ff 92       	push	r15
    205a:	0f 93       	push	r16
    205c:	1f 93       	push	r17
    205e:	cf 93       	push	r28
    2060:	df 93       	push	r29
    2062:	ec 01       	movw	r28, r24
    2064:	f6 2e       	mov	r15, r22
    2066:	00 91 45 02 	lds	r16, 0x0245	; 0x800245 <xTickCount>
    206a:	10 91 46 02 	lds	r17, 0x0246	; 0x800246 <xTickCount+0x1>
    206e:	80 91 9e 02 	lds	r24, 0x029E	; 0x80029e <pxCurrentTCB>
    2072:	90 91 9f 02 	lds	r25, 0x029F	; 0x80029f <pxCurrentTCB+0x1>
    2076:	02 96       	adiw	r24, 0x02	; 2
    2078:	0e 94 ee 14 	call	0x29dc	; 0x29dc <uxListRemove>
    207c:	cf 3f       	cpi	r28, 0xFF	; 255
    207e:	8f ef       	ldi	r24, 0xFF	; 255
    2080:	d8 07       	cpc	r29, r24
    2082:	69 f4       	brne	.+26     	; 0x209e <prvAddCurrentTaskToDelayedList+0x46>
    2084:	ff 20       	and	r15, r15
    2086:	59 f0       	breq	.+22     	; 0x209e <prvAddCurrentTaskToDelayedList+0x46>
    2088:	60 91 9e 02 	lds	r22, 0x029E	; 0x80029e <pxCurrentTCB>
    208c:	70 91 9f 02 	lds	r23, 0x029F	; 0x80029f <pxCurrentTCB+0x1>
    2090:	6e 5f       	subi	r22, 0xFE	; 254
    2092:	7f 4f       	sbci	r23, 0xFF	; 255
    2094:	88 e4       	ldi	r24, 0x48	; 72
    2096:	92 e0       	ldi	r25, 0x02	; 2
    2098:	0e 94 9c 14 	call	0x2938	; 0x2938 <vListInsertEnd>
    209c:	2f c0       	rjmp	.+94     	; 0x20fc <prvAddCurrentTaskToDelayedList+0xa4>
    209e:	c0 0f       	add	r28, r16
    20a0:	d1 1f       	adc	r29, r17
    20a2:	e0 91 9e 02 	lds	r30, 0x029E	; 0x80029e <pxCurrentTCB>
    20a6:	f0 91 9f 02 	lds	r31, 0x029F	; 0x80029f <pxCurrentTCB+0x1>
    20aa:	d3 83       	std	Z+3, r29	; 0x03
    20ac:	c2 83       	std	Z+2, r28	; 0x02
    20ae:	c0 17       	cp	r28, r16
    20b0:	d1 07       	cpc	r29, r17
    20b2:	68 f4       	brcc	.+26     	; 0x20ce <prvAddCurrentTaskToDelayedList+0x76>
    20b4:	60 91 9e 02 	lds	r22, 0x029E	; 0x80029e <pxCurrentTCB>
    20b8:	70 91 9f 02 	lds	r23, 0x029F	; 0x80029f <pxCurrentTCB+0x1>
    20bc:	80 91 64 02 	lds	r24, 0x0264	; 0x800264 <pxOverflowDelayedTaskList>
    20c0:	90 91 65 02 	lds	r25, 0x0265	; 0x800265 <pxOverflowDelayedTaskList+0x1>
    20c4:	6e 5f       	subi	r22, 0xFE	; 254
    20c6:	7f 4f       	sbci	r23, 0xFF	; 255
    20c8:	0e 94 bd 14 	call	0x297a	; 0x297a <vListInsert>
    20cc:	17 c0       	rjmp	.+46     	; 0x20fc <prvAddCurrentTaskToDelayedList+0xa4>
    20ce:	60 91 9e 02 	lds	r22, 0x029E	; 0x80029e <pxCurrentTCB>
    20d2:	70 91 9f 02 	lds	r23, 0x029F	; 0x80029f <pxCurrentTCB+0x1>
    20d6:	80 91 66 02 	lds	r24, 0x0266	; 0x800266 <pxDelayedTaskList>
    20da:	90 91 67 02 	lds	r25, 0x0267	; 0x800267 <pxDelayedTaskList+0x1>
    20de:	6e 5f       	subi	r22, 0xFE	; 254
    20e0:	7f 4f       	sbci	r23, 0xFF	; 255
    20e2:	0e 94 bd 14 	call	0x297a	; 0x297a <vListInsert>
    20e6:	80 91 3d 02 	lds	r24, 0x023D	; 0x80023d <xNextTaskUnblockTime>
    20ea:	90 91 3e 02 	lds	r25, 0x023E	; 0x80023e <xNextTaskUnblockTime+0x1>
    20ee:	c8 17       	cp	r28, r24
    20f0:	d9 07       	cpc	r29, r25
    20f2:	20 f4       	brcc	.+8      	; 0x20fc <prvAddCurrentTaskToDelayedList+0xa4>
    20f4:	d0 93 3e 02 	sts	0x023E, r29	; 0x80023e <xNextTaskUnblockTime+0x1>
    20f8:	c0 93 3d 02 	sts	0x023D, r28	; 0x80023d <xNextTaskUnblockTime>
    20fc:	df 91       	pop	r29
    20fe:	cf 91       	pop	r28
    2100:	1f 91       	pop	r17
    2102:	0f 91       	pop	r16
    2104:	ff 90       	pop	r15
    2106:	08 95       	ret

00002108 <xTaskCreate>:
    2108:	4f 92       	push	r4
    210a:	5f 92       	push	r5
    210c:	6f 92       	push	r6
    210e:	7f 92       	push	r7
    2110:	8f 92       	push	r8
    2112:	9f 92       	push	r9
    2114:	af 92       	push	r10
    2116:	bf 92       	push	r11
    2118:	cf 92       	push	r12
    211a:	df 92       	push	r13
    211c:	ef 92       	push	r14
    211e:	ff 92       	push	r15
    2120:	0f 93       	push	r16
    2122:	cf 93       	push	r28
    2124:	df 93       	push	r29
    2126:	4c 01       	movw	r8, r24
    2128:	6b 01       	movw	r12, r22
    212a:	5a 01       	movw	r10, r20
    212c:	29 01       	movw	r4, r18
    212e:	ca 01       	movw	r24, r20
    2130:	0e 94 54 14 	call	0x28a8	; 0x28a8 <pvPortMalloc>
    2134:	3c 01       	movw	r6, r24
    2136:	89 2b       	or	r24, r25
    2138:	09 f4       	brne	.+2      	; 0x213c <xTaskCreate+0x34>
    213a:	e2 c0       	rjmp	.+452    	; 0x2300 <xTaskCreate+0x1f8>
    213c:	86 e2       	ldi	r24, 0x26	; 38
    213e:	90 e0       	ldi	r25, 0x00	; 0
    2140:	0e 94 54 14 	call	0x28a8	; 0x28a8 <pvPortMalloc>
    2144:	ec 01       	movw	r28, r24
    2146:	89 2b       	or	r24, r25
    2148:	71 f0       	breq	.+28     	; 0x2166 <xTaskCreate+0x5e>
    214a:	78 8e       	std	Y+24, r7	; 0x18
    214c:	6f 8a       	std	Y+23, r6	; 0x17
    214e:	81 e0       	ldi	r24, 0x01	; 1
    2150:	a8 1a       	sub	r10, r24
    2152:	b1 08       	sbc	r11, r1
    2154:	a6 0c       	add	r10, r6
    2156:	b7 1c       	adc	r11, r7
    2158:	d6 01       	movw	r26, r12
    215a:	8c 91       	ld	r24, X
    215c:	89 8f       	std	Y+25, r24	; 0x19
    215e:	8c 91       	ld	r24, X
    2160:	81 11       	cpse	r24, r1
    2162:	05 c0       	rjmp	.+10     	; 0x216e <xTaskCreate+0x66>
    2164:	18 c0       	rjmp	.+48     	; 0x2196 <xTaskCreate+0x8e>
    2166:	c3 01       	movw	r24, r6
    2168:	0e 94 89 14 	call	0x2912	; 0x2912 <vPortFree>
    216c:	c9 c0       	rjmp	.+402    	; 0x2300 <xTaskCreate+0x1f8>
    216e:	ae 01       	movw	r20, r28
    2170:	46 5e       	subi	r20, 0xE6	; 230
    2172:	5f 4f       	sbci	r21, 0xFF	; 255
    2174:	f6 01       	movw	r30, r12
    2176:	31 96       	adiw	r30, 0x01	; 1
    2178:	b8 e0       	ldi	r27, 0x08	; 8
    217a:	cb 0e       	add	r12, r27
    217c:	d1 1c       	adc	r13, r1
    217e:	cf 01       	movw	r24, r30
    2180:	21 91       	ld	r18, Z+
    2182:	da 01       	movw	r26, r20
    2184:	2d 93       	st	X+, r18
    2186:	ad 01       	movw	r20, r26
    2188:	dc 01       	movw	r26, r24
    218a:	8c 91       	ld	r24, X
    218c:	88 23       	and	r24, r24
    218e:	19 f0       	breq	.+6      	; 0x2196 <xTaskCreate+0x8e>
    2190:	ec 15       	cp	r30, r12
    2192:	fd 05       	cpc	r31, r13
    2194:	a1 f7       	brne	.-24     	; 0x217e <xTaskCreate+0x76>
    2196:	18 a2       	std	Y+32, r1	; 0x20
    2198:	04 30       	cpi	r16, 0x04	; 4
    219a:	08 f0       	brcs	.+2      	; 0x219e <xTaskCreate+0x96>
    219c:	03 e0       	ldi	r16, 0x03	; 3
    219e:	0e 8b       	std	Y+22, r16	; 0x16
    21a0:	6e 01       	movw	r12, r28
    21a2:	b2 e0       	ldi	r27, 0x02	; 2
    21a4:	cb 0e       	add	r12, r27
    21a6:	d1 1c       	adc	r13, r1
    21a8:	c6 01       	movw	r24, r12
    21aa:	0e 94 98 14 	call	0x2930	; 0x2930 <vListInitialiseItem>
    21ae:	ce 01       	movw	r24, r28
    21b0:	0c 96       	adiw	r24, 0x0c	; 12
    21b2:	0e 94 98 14 	call	0x2930	; 0x2930 <vListInitialiseItem>
    21b6:	d9 87       	std	Y+9, r29	; 0x09
    21b8:	c8 87       	std	Y+8, r28	; 0x08
    21ba:	84 e0       	ldi	r24, 0x04	; 4
    21bc:	90 e0       	ldi	r25, 0x00	; 0
    21be:	80 1b       	sub	r24, r16
    21c0:	91 09       	sbc	r25, r1
    21c2:	9d 87       	std	Y+13, r25	; 0x0d
    21c4:	8c 87       	std	Y+12, r24	; 0x0c
    21c6:	db 8b       	std	Y+19, r29	; 0x13
    21c8:	ca 8b       	std	Y+18, r28	; 0x12
    21ca:	19 a2       	std	Y+33, r1	; 0x21
    21cc:	1a a2       	std	Y+34, r1	; 0x22
    21ce:	1b a2       	std	Y+35, r1	; 0x23
    21d0:	1c a2       	std	Y+36, r1	; 0x24
    21d2:	1d a2       	std	Y+37, r1	; 0x25
    21d4:	a2 01       	movw	r20, r4
    21d6:	b4 01       	movw	r22, r8
    21d8:	c5 01       	movw	r24, r10
    21da:	0e 94 14 15 	call	0x2a28	; 0x2a28 <pxPortInitialiseStack>
    21de:	99 83       	std	Y+1, r25	; 0x01
    21e0:	88 83       	st	Y, r24
    21e2:	e1 14       	cp	r14, r1
    21e4:	f1 04       	cpc	r15, r1
    21e6:	19 f0       	breq	.+6      	; 0x21ee <xTaskCreate+0xe6>
    21e8:	f7 01       	movw	r30, r14
    21ea:	d1 83       	std	Z+1, r29	; 0x01
    21ec:	c0 83       	st	Z, r28
    21ee:	0f b6       	in	r0, 0x3f	; 63
    21f0:	f8 94       	cli
    21f2:	0f 92       	push	r0
    21f4:	80 91 47 02 	lds	r24, 0x0247	; 0x800247 <uxCurrentNumberOfTasks>
    21f8:	8f 5f       	subi	r24, 0xFF	; 255
    21fa:	80 93 47 02 	sts	0x0247, r24	; 0x800247 <uxCurrentNumberOfTasks>
    21fe:	80 91 9e 02 	lds	r24, 0x029E	; 0x80029e <pxCurrentTCB>
    2202:	90 91 9f 02 	lds	r25, 0x029F	; 0x80029f <pxCurrentTCB+0x1>
    2206:	89 2b       	or	r24, r25
    2208:	d1 f5       	brne	.+116    	; 0x227e <xTaskCreate+0x176>
    220a:	d0 93 9f 02 	sts	0x029F, r29	; 0x80029f <pxCurrentTCB+0x1>
    220e:	c0 93 9e 02 	sts	0x029E, r28	; 0x80029e <pxCurrentTCB>
    2212:	80 91 47 02 	lds	r24, 0x0247	; 0x800247 <uxCurrentNumberOfTasks>
    2216:	81 30       	cpi	r24, 0x01	; 1
    2218:	09 f0       	breq	.+2      	; 0x221c <xTaskCreate+0x114>
    221a:	41 c0       	rjmp	.+130    	; 0x229e <xTaskCreate+0x196>
    221c:	8a e7       	ldi	r24, 0x7A	; 122
    221e:	92 e0       	ldi	r25, 0x02	; 2
    2220:	0e 94 8a 14 	call	0x2914	; 0x2914 <vListInitialise>
    2224:	83 e8       	ldi	r24, 0x83	; 131
    2226:	92 e0       	ldi	r25, 0x02	; 2
    2228:	0e 94 8a 14 	call	0x2914	; 0x2914 <vListInitialise>
    222c:	8c e8       	ldi	r24, 0x8C	; 140
    222e:	92 e0       	ldi	r25, 0x02	; 2
    2230:	0e 94 8a 14 	call	0x2914	; 0x2914 <vListInitialise>
    2234:	85 e9       	ldi	r24, 0x95	; 149
    2236:	92 e0       	ldi	r25, 0x02	; 2
    2238:	0e 94 8a 14 	call	0x2914	; 0x2914 <vListInitialise>
    223c:	81 e7       	ldi	r24, 0x71	; 113
    223e:	92 e0       	ldi	r25, 0x02	; 2
    2240:	0e 94 8a 14 	call	0x2914	; 0x2914 <vListInitialise>
    2244:	88 e6       	ldi	r24, 0x68	; 104
    2246:	92 e0       	ldi	r25, 0x02	; 2
    2248:	0e 94 8a 14 	call	0x2914	; 0x2914 <vListInitialise>
    224c:	8b e5       	ldi	r24, 0x5B	; 91
    224e:	92 e0       	ldi	r25, 0x02	; 2
    2250:	0e 94 8a 14 	call	0x2914	; 0x2914 <vListInitialise>
    2254:	82 e5       	ldi	r24, 0x52	; 82
    2256:	92 e0       	ldi	r25, 0x02	; 2
    2258:	0e 94 8a 14 	call	0x2914	; 0x2914 <vListInitialise>
    225c:	88 e4       	ldi	r24, 0x48	; 72
    225e:	92 e0       	ldi	r25, 0x02	; 2
    2260:	0e 94 8a 14 	call	0x2914	; 0x2914 <vListInitialise>
    2264:	81 e7       	ldi	r24, 0x71	; 113
    2266:	92 e0       	ldi	r25, 0x02	; 2
    2268:	90 93 67 02 	sts	0x0267, r25	; 0x800267 <pxDelayedTaskList+0x1>
    226c:	80 93 66 02 	sts	0x0266, r24	; 0x800266 <pxDelayedTaskList>
    2270:	88 e6       	ldi	r24, 0x68	; 104
    2272:	92 e0       	ldi	r25, 0x02	; 2
    2274:	90 93 65 02 	sts	0x0265, r25	; 0x800265 <pxOverflowDelayedTaskList+0x1>
    2278:	80 93 64 02 	sts	0x0264, r24	; 0x800264 <pxOverflowDelayedTaskList>
    227c:	10 c0       	rjmp	.+32     	; 0x229e <xTaskCreate+0x196>
    227e:	80 91 43 02 	lds	r24, 0x0243	; 0x800243 <xSchedulerRunning>
    2282:	81 11       	cpse	r24, r1
    2284:	0c c0       	rjmp	.+24     	; 0x229e <xTaskCreate+0x196>
    2286:	e0 91 9e 02 	lds	r30, 0x029E	; 0x80029e <pxCurrentTCB>
    228a:	f0 91 9f 02 	lds	r31, 0x029F	; 0x80029f <pxCurrentTCB+0x1>
    228e:	96 89       	ldd	r25, Z+22	; 0x16
    2290:	8e 89       	ldd	r24, Y+22	; 0x16
    2292:	89 17       	cp	r24, r25
    2294:	20 f0       	brcs	.+8      	; 0x229e <xTaskCreate+0x196>
    2296:	d0 93 9f 02 	sts	0x029F, r29	; 0x80029f <pxCurrentTCB+0x1>
    229a:	c0 93 9e 02 	sts	0x029E, r28	; 0x80029e <pxCurrentTCB>
    229e:	80 91 3f 02 	lds	r24, 0x023F	; 0x80023f <uxTaskNumber>
    22a2:	8f 5f       	subi	r24, 0xFF	; 255
    22a4:	80 93 3f 02 	sts	0x023F, r24	; 0x80023f <uxTaskNumber>
    22a8:	8e 89       	ldd	r24, Y+22	; 0x16
    22aa:	90 91 44 02 	lds	r25, 0x0244	; 0x800244 <uxTopReadyPriority>
    22ae:	98 17       	cp	r25, r24
    22b0:	10 f4       	brcc	.+4      	; 0x22b6 <xTaskCreate+0x1ae>
    22b2:	80 93 44 02 	sts	0x0244, r24	; 0x800244 <uxTopReadyPriority>
    22b6:	90 e0       	ldi	r25, 0x00	; 0
    22b8:	9c 01       	movw	r18, r24
    22ba:	22 0f       	add	r18, r18
    22bc:	33 1f       	adc	r19, r19
    22be:	22 0f       	add	r18, r18
    22c0:	33 1f       	adc	r19, r19
    22c2:	22 0f       	add	r18, r18
    22c4:	33 1f       	adc	r19, r19
    22c6:	82 0f       	add	r24, r18
    22c8:	93 1f       	adc	r25, r19
    22ca:	b6 01       	movw	r22, r12
    22cc:	86 58       	subi	r24, 0x86	; 134
    22ce:	9d 4f       	sbci	r25, 0xFD	; 253
    22d0:	0e 94 9c 14 	call	0x2938	; 0x2938 <vListInsertEnd>
    22d4:	0f 90       	pop	r0
    22d6:	0f be       	out	0x3f, r0	; 63
    22d8:	80 91 43 02 	lds	r24, 0x0243	; 0x800243 <xSchedulerRunning>
    22dc:	88 23       	and	r24, r24
    22de:	61 f0       	breq	.+24     	; 0x22f8 <xTaskCreate+0x1f0>
    22e0:	e0 91 9e 02 	lds	r30, 0x029E	; 0x80029e <pxCurrentTCB>
    22e4:	f0 91 9f 02 	lds	r31, 0x029F	; 0x80029f <pxCurrentTCB+0x1>
    22e8:	96 89       	ldd	r25, Z+22	; 0x16
    22ea:	8e 89       	ldd	r24, Y+22	; 0x16
    22ec:	98 17       	cp	r25, r24
    22ee:	30 f4       	brcc	.+12     	; 0x22fc <xTaskCreate+0x1f4>
    22f0:	0e 94 bc 15 	call	0x2b78	; 0x2b78 <vPortYield>
    22f4:	81 e0       	ldi	r24, 0x01	; 1
    22f6:	05 c0       	rjmp	.+10     	; 0x2302 <xTaskCreate+0x1fa>
    22f8:	81 e0       	ldi	r24, 0x01	; 1
    22fa:	03 c0       	rjmp	.+6      	; 0x2302 <xTaskCreate+0x1fa>
    22fc:	81 e0       	ldi	r24, 0x01	; 1
    22fe:	01 c0       	rjmp	.+2      	; 0x2302 <xTaskCreate+0x1fa>
    2300:	8f ef       	ldi	r24, 0xFF	; 255
    2302:	df 91       	pop	r29
    2304:	cf 91       	pop	r28
    2306:	0f 91       	pop	r16
    2308:	ff 90       	pop	r15
    230a:	ef 90       	pop	r14
    230c:	df 90       	pop	r13
    230e:	cf 90       	pop	r12
    2310:	bf 90       	pop	r11
    2312:	af 90       	pop	r10
    2314:	9f 90       	pop	r9
    2316:	8f 90       	pop	r8
    2318:	7f 90       	pop	r7
    231a:	6f 90       	pop	r6
    231c:	5f 90       	pop	r5
    231e:	4f 90       	pop	r4
    2320:	08 95       	ret

00002322 <vTaskStartScheduler>:
    2322:	ef 92       	push	r14
    2324:	ff 92       	push	r15
    2326:	0f 93       	push	r16
    2328:	0f 2e       	mov	r0, r31
    232a:	fb e3       	ldi	r31, 0x3B	; 59
    232c:	ef 2e       	mov	r14, r31
    232e:	f2 e0       	ldi	r31, 0x02	; 2
    2330:	ff 2e       	mov	r15, r31
    2332:	f0 2d       	mov	r31, r0
    2334:	00 e0       	ldi	r16, 0x00	; 0
    2336:	20 e0       	ldi	r18, 0x00	; 0
    2338:	30 e0       	ldi	r19, 0x00	; 0
    233a:	45 e5       	ldi	r20, 0x55	; 85
    233c:	50 e0       	ldi	r21, 0x00	; 0
    233e:	68 eb       	ldi	r22, 0xB8	; 184
    2340:	71 e0       	ldi	r23, 0x01	; 1
    2342:	8f e0       	ldi	r24, 0x0F	; 15
    2344:	93 e1       	ldi	r25, 0x13	; 19
    2346:	0e 94 84 10 	call	0x2108	; 0x2108 <xTaskCreate>
    234a:	81 30       	cpi	r24, 0x01	; 1
    234c:	81 f4       	brne	.+32     	; 0x236e <vTaskStartScheduler+0x4c>
    234e:	f8 94       	cli
    2350:	8f ef       	ldi	r24, 0xFF	; 255
    2352:	9f ef       	ldi	r25, 0xFF	; 255
    2354:	90 93 3e 02 	sts	0x023E, r25	; 0x80023e <xNextTaskUnblockTime+0x1>
    2358:	80 93 3d 02 	sts	0x023D, r24	; 0x80023d <xNextTaskUnblockTime>
    235c:	81 e0       	ldi	r24, 0x01	; 1
    235e:	80 93 43 02 	sts	0x0243, r24	; 0x800243 <xSchedulerRunning>
    2362:	10 92 46 02 	sts	0x0246, r1	; 0x800246 <xTickCount+0x1>
    2366:	10 92 45 02 	sts	0x0245, r1	; 0x800245 <xTickCount>
    236a:	0e 94 80 15 	call	0x2b00	; 0x2b00 <xPortStartScheduler>
    236e:	0f 91       	pop	r16
    2370:	ff 90       	pop	r15
    2372:	ef 90       	pop	r14
    2374:	08 95       	ret

00002376 <vTaskSuspendAll>:
    2376:	80 91 3a 02 	lds	r24, 0x023A	; 0x80023a <uxSchedulerSuspended>
    237a:	8f 5f       	subi	r24, 0xFF	; 255
    237c:	80 93 3a 02 	sts	0x023A, r24	; 0x80023a <uxSchedulerSuspended>
    2380:	08 95       	ret

00002382 <xTaskIncrementTick>:
    2382:	cf 92       	push	r12
    2384:	df 92       	push	r13
    2386:	ef 92       	push	r14
    2388:	ff 92       	push	r15
    238a:	0f 93       	push	r16
    238c:	1f 93       	push	r17
    238e:	cf 93       	push	r28
    2390:	df 93       	push	r29
    2392:	80 91 3a 02 	lds	r24, 0x023A	; 0x80023a <uxSchedulerSuspended>
    2396:	81 11       	cpse	r24, r1
    2398:	99 c0       	rjmp	.+306    	; 0x24cc <xTaskIncrementTick+0x14a>
    239a:	e0 90 45 02 	lds	r14, 0x0245	; 0x800245 <xTickCount>
    239e:	f0 90 46 02 	lds	r15, 0x0246	; 0x800246 <xTickCount+0x1>
    23a2:	8f ef       	ldi	r24, 0xFF	; 255
    23a4:	e8 1a       	sub	r14, r24
    23a6:	f8 0a       	sbc	r15, r24
    23a8:	f0 92 46 02 	sts	0x0246, r15	; 0x800246 <xTickCount+0x1>
    23ac:	e0 92 45 02 	sts	0x0245, r14	; 0x800245 <xTickCount>
    23b0:	e1 14       	cp	r14, r1
    23b2:	f1 04       	cpc	r15, r1
    23b4:	b9 f4       	brne	.+46     	; 0x23e4 <xTaskIncrementTick+0x62>
    23b6:	80 91 66 02 	lds	r24, 0x0266	; 0x800266 <pxDelayedTaskList>
    23ba:	90 91 67 02 	lds	r25, 0x0267	; 0x800267 <pxDelayedTaskList+0x1>
    23be:	20 91 64 02 	lds	r18, 0x0264	; 0x800264 <pxOverflowDelayedTaskList>
    23c2:	30 91 65 02 	lds	r19, 0x0265	; 0x800265 <pxOverflowDelayedTaskList+0x1>
    23c6:	30 93 67 02 	sts	0x0267, r19	; 0x800267 <pxDelayedTaskList+0x1>
    23ca:	20 93 66 02 	sts	0x0266, r18	; 0x800266 <pxDelayedTaskList>
    23ce:	90 93 65 02 	sts	0x0265, r25	; 0x800265 <pxOverflowDelayedTaskList+0x1>
    23d2:	80 93 64 02 	sts	0x0264, r24	; 0x800264 <pxOverflowDelayedTaskList>
    23d6:	80 91 40 02 	lds	r24, 0x0240	; 0x800240 <xNumOfOverflows>
    23da:	8f 5f       	subi	r24, 0xFF	; 255
    23dc:	80 93 40 02 	sts	0x0240, r24	; 0x800240 <xNumOfOverflows>
    23e0:	0e 94 0d 10 	call	0x201a	; 0x201a <prvResetNextTaskUnblockTime>
    23e4:	80 91 3d 02 	lds	r24, 0x023D	; 0x80023d <xNextTaskUnblockTime>
    23e8:	90 91 3e 02 	lds	r25, 0x023E	; 0x80023e <xNextTaskUnblockTime+0x1>
    23ec:	e8 16       	cp	r14, r24
    23ee:	f9 06       	cpc	r15, r25
    23f0:	10 f4       	brcc	.+4      	; 0x23f6 <xTaskIncrementTick+0x74>
    23f2:	d1 2c       	mov	r13, r1
    23f4:	53 c0       	rjmp	.+166    	; 0x249c <xTaskIncrementTick+0x11a>
    23f6:	d1 2c       	mov	r13, r1
    23f8:	cc 24       	eor	r12, r12
    23fa:	c3 94       	inc	r12
    23fc:	e0 91 66 02 	lds	r30, 0x0266	; 0x800266 <pxDelayedTaskList>
    2400:	f0 91 67 02 	lds	r31, 0x0267	; 0x800267 <pxDelayedTaskList+0x1>
    2404:	80 81       	ld	r24, Z
    2406:	81 11       	cpse	r24, r1
    2408:	07 c0       	rjmp	.+14     	; 0x2418 <xTaskIncrementTick+0x96>
    240a:	8f ef       	ldi	r24, 0xFF	; 255
    240c:	9f ef       	ldi	r25, 0xFF	; 255
    240e:	90 93 3e 02 	sts	0x023E, r25	; 0x80023e <xNextTaskUnblockTime+0x1>
    2412:	80 93 3d 02 	sts	0x023D, r24	; 0x80023d <xNextTaskUnblockTime>
    2416:	42 c0       	rjmp	.+132    	; 0x249c <xTaskIncrementTick+0x11a>
    2418:	e0 91 66 02 	lds	r30, 0x0266	; 0x800266 <pxDelayedTaskList>
    241c:	f0 91 67 02 	lds	r31, 0x0267	; 0x800267 <pxDelayedTaskList+0x1>
    2420:	05 80       	ldd	r0, Z+5	; 0x05
    2422:	f6 81       	ldd	r31, Z+6	; 0x06
    2424:	e0 2d       	mov	r30, r0
    2426:	c6 81       	ldd	r28, Z+6	; 0x06
    2428:	d7 81       	ldd	r29, Z+7	; 0x07
    242a:	8a 81       	ldd	r24, Y+2	; 0x02
    242c:	9b 81       	ldd	r25, Y+3	; 0x03
    242e:	e8 16       	cp	r14, r24
    2430:	f9 06       	cpc	r15, r25
    2432:	28 f4       	brcc	.+10     	; 0x243e <xTaskIncrementTick+0xbc>
    2434:	90 93 3e 02 	sts	0x023E, r25	; 0x80023e <xNextTaskUnblockTime+0x1>
    2438:	80 93 3d 02 	sts	0x023D, r24	; 0x80023d <xNextTaskUnblockTime>
    243c:	2f c0       	rjmp	.+94     	; 0x249c <xTaskIncrementTick+0x11a>
    243e:	8e 01       	movw	r16, r28
    2440:	0e 5f       	subi	r16, 0xFE	; 254
    2442:	1f 4f       	sbci	r17, 0xFF	; 255
    2444:	c8 01       	movw	r24, r16
    2446:	0e 94 ee 14 	call	0x29dc	; 0x29dc <uxListRemove>
    244a:	8c 89       	ldd	r24, Y+20	; 0x14
    244c:	9d 89       	ldd	r25, Y+21	; 0x15
    244e:	89 2b       	or	r24, r25
    2450:	21 f0       	breq	.+8      	; 0x245a <xTaskIncrementTick+0xd8>
    2452:	ce 01       	movw	r24, r28
    2454:	0c 96       	adiw	r24, 0x0c	; 12
    2456:	0e 94 ee 14 	call	0x29dc	; 0x29dc <uxListRemove>
    245a:	8e 89       	ldd	r24, Y+22	; 0x16
    245c:	90 91 44 02 	lds	r25, 0x0244	; 0x800244 <uxTopReadyPriority>
    2460:	98 17       	cp	r25, r24
    2462:	10 f4       	brcc	.+4      	; 0x2468 <xTaskIncrementTick+0xe6>
    2464:	80 93 44 02 	sts	0x0244, r24	; 0x800244 <uxTopReadyPriority>
    2468:	90 e0       	ldi	r25, 0x00	; 0
    246a:	9c 01       	movw	r18, r24
    246c:	22 0f       	add	r18, r18
    246e:	33 1f       	adc	r19, r19
    2470:	22 0f       	add	r18, r18
    2472:	33 1f       	adc	r19, r19
    2474:	22 0f       	add	r18, r18
    2476:	33 1f       	adc	r19, r19
    2478:	82 0f       	add	r24, r18
    247a:	93 1f       	adc	r25, r19
    247c:	b8 01       	movw	r22, r16
    247e:	86 58       	subi	r24, 0x86	; 134
    2480:	9d 4f       	sbci	r25, 0xFD	; 253
    2482:	0e 94 9c 14 	call	0x2938	; 0x2938 <vListInsertEnd>
    2486:	e0 91 9e 02 	lds	r30, 0x029E	; 0x80029e <pxCurrentTCB>
    248a:	f0 91 9f 02 	lds	r31, 0x029F	; 0x80029f <pxCurrentTCB+0x1>
    248e:	9e 89       	ldd	r25, Y+22	; 0x16
    2490:	86 89       	ldd	r24, Z+22	; 0x16
    2492:	98 17       	cp	r25, r24
    2494:	08 f4       	brcc	.+2      	; 0x2498 <xTaskIncrementTick+0x116>
    2496:	b2 cf       	rjmp	.-156    	; 0x23fc <xTaskIncrementTick+0x7a>
    2498:	dc 2c       	mov	r13, r12
    249a:	b0 cf       	rjmp	.-160    	; 0x23fc <xTaskIncrementTick+0x7a>
    249c:	e0 91 9e 02 	lds	r30, 0x029E	; 0x80029e <pxCurrentTCB>
    24a0:	f0 91 9f 02 	lds	r31, 0x029F	; 0x80029f <pxCurrentTCB+0x1>
    24a4:	86 89       	ldd	r24, Z+22	; 0x16
    24a6:	90 e0       	ldi	r25, 0x00	; 0
    24a8:	fc 01       	movw	r30, r24
    24aa:	ee 0f       	add	r30, r30
    24ac:	ff 1f       	adc	r31, r31
    24ae:	ee 0f       	add	r30, r30
    24b0:	ff 1f       	adc	r31, r31
    24b2:	ee 0f       	add	r30, r30
    24b4:	ff 1f       	adc	r31, r31
    24b6:	8e 0f       	add	r24, r30
    24b8:	9f 1f       	adc	r25, r31
    24ba:	fc 01       	movw	r30, r24
    24bc:	e6 58       	subi	r30, 0x86	; 134
    24be:	fd 4f       	sbci	r31, 0xFD	; 253
    24c0:	80 81       	ld	r24, Z
    24c2:	82 30       	cpi	r24, 0x02	; 2
    24c4:	48 f0       	brcs	.+18     	; 0x24d8 <xTaskIncrementTick+0x156>
    24c6:	dd 24       	eor	r13, r13
    24c8:	d3 94       	inc	r13
    24ca:	06 c0       	rjmp	.+12     	; 0x24d8 <xTaskIncrementTick+0x156>
    24cc:	80 91 42 02 	lds	r24, 0x0242	; 0x800242 <uxPendedTicks>
    24d0:	8f 5f       	subi	r24, 0xFF	; 255
    24d2:	80 93 42 02 	sts	0x0242, r24	; 0x800242 <uxPendedTicks>
    24d6:	d1 2c       	mov	r13, r1
    24d8:	80 91 41 02 	lds	r24, 0x0241	; 0x800241 <xYieldPending>
    24dc:	88 23       	and	r24, r24
    24de:	11 f0       	breq	.+4      	; 0x24e4 <xTaskIncrementTick+0x162>
    24e0:	dd 24       	eor	r13, r13
    24e2:	d3 94       	inc	r13
    24e4:	8d 2d       	mov	r24, r13
    24e6:	df 91       	pop	r29
    24e8:	cf 91       	pop	r28
    24ea:	1f 91       	pop	r17
    24ec:	0f 91       	pop	r16
    24ee:	ff 90       	pop	r15
    24f0:	ef 90       	pop	r14
    24f2:	df 90       	pop	r13
    24f4:	cf 90       	pop	r12
    24f6:	08 95       	ret

000024f8 <xTaskResumeAll>:
    24f8:	df 92       	push	r13
    24fa:	ef 92       	push	r14
    24fc:	ff 92       	push	r15
    24fe:	0f 93       	push	r16
    2500:	1f 93       	push	r17
    2502:	cf 93       	push	r28
    2504:	df 93       	push	r29
    2506:	0f b6       	in	r0, 0x3f	; 63
    2508:	f8 94       	cli
    250a:	0f 92       	push	r0
    250c:	80 91 3a 02 	lds	r24, 0x023A	; 0x80023a <uxSchedulerSuspended>
    2510:	81 50       	subi	r24, 0x01	; 1
    2512:	80 93 3a 02 	sts	0x023A, r24	; 0x80023a <uxSchedulerSuspended>
    2516:	80 91 3a 02 	lds	r24, 0x023A	; 0x80023a <uxSchedulerSuspended>
    251a:	81 11       	cpse	r24, r1
    251c:	5f c0       	rjmp	.+190    	; 0x25dc <xTaskResumeAll+0xe4>
    251e:	80 91 47 02 	lds	r24, 0x0247	; 0x800247 <uxCurrentNumberOfTasks>
    2522:	81 11       	cpse	r24, r1
    2524:	33 c0       	rjmp	.+102    	; 0x258c <xTaskResumeAll+0x94>
    2526:	5d c0       	rjmp	.+186    	; 0x25e2 <xTaskResumeAll+0xea>
    2528:	d7 01       	movw	r26, r14
    252a:	15 96       	adiw	r26, 0x05	; 5
    252c:	ed 91       	ld	r30, X+
    252e:	fc 91       	ld	r31, X
    2530:	16 97       	sbiw	r26, 0x06	; 6
    2532:	c6 81       	ldd	r28, Z+6	; 0x06
    2534:	d7 81       	ldd	r29, Z+7	; 0x07
    2536:	ce 01       	movw	r24, r28
    2538:	0c 96       	adiw	r24, 0x0c	; 12
    253a:	0e 94 ee 14 	call	0x29dc	; 0x29dc <uxListRemove>
    253e:	8e 01       	movw	r16, r28
    2540:	0e 5f       	subi	r16, 0xFE	; 254
    2542:	1f 4f       	sbci	r17, 0xFF	; 255
    2544:	c8 01       	movw	r24, r16
    2546:	0e 94 ee 14 	call	0x29dc	; 0x29dc <uxListRemove>
    254a:	8e 89       	ldd	r24, Y+22	; 0x16
    254c:	90 91 44 02 	lds	r25, 0x0244	; 0x800244 <uxTopReadyPriority>
    2550:	98 17       	cp	r25, r24
    2552:	10 f4       	brcc	.+4      	; 0x2558 <xTaskResumeAll+0x60>
    2554:	80 93 44 02 	sts	0x0244, r24	; 0x800244 <uxTopReadyPriority>
    2558:	90 e0       	ldi	r25, 0x00	; 0
    255a:	9c 01       	movw	r18, r24
    255c:	22 0f       	add	r18, r18
    255e:	33 1f       	adc	r19, r19
    2560:	22 0f       	add	r18, r18
    2562:	33 1f       	adc	r19, r19
    2564:	22 0f       	add	r18, r18
    2566:	33 1f       	adc	r19, r19
    2568:	82 0f       	add	r24, r18
    256a:	93 1f       	adc	r25, r19
    256c:	b8 01       	movw	r22, r16
    256e:	86 58       	subi	r24, 0x86	; 134
    2570:	9d 4f       	sbci	r25, 0xFD	; 253
    2572:	0e 94 9c 14 	call	0x2938	; 0x2938 <vListInsertEnd>
    2576:	e0 91 9e 02 	lds	r30, 0x029E	; 0x80029e <pxCurrentTCB>
    257a:	f0 91 9f 02 	lds	r31, 0x029F	; 0x80029f <pxCurrentTCB+0x1>
    257e:	9e 89       	ldd	r25, Y+22	; 0x16
    2580:	86 89       	ldd	r24, Z+22	; 0x16
    2582:	98 17       	cp	r25, r24
    2584:	68 f0       	brcs	.+26     	; 0x25a0 <xTaskResumeAll+0xa8>
    2586:	d0 92 41 02 	sts	0x0241, r13	; 0x800241 <xYieldPending>
    258a:	0a c0       	rjmp	.+20     	; 0x25a0 <xTaskResumeAll+0xa8>
    258c:	c0 e0       	ldi	r28, 0x00	; 0
    258e:	d0 e0       	ldi	r29, 0x00	; 0
    2590:	0f 2e       	mov	r0, r31
    2592:	fb e5       	ldi	r31, 0x5B	; 91
    2594:	ef 2e       	mov	r14, r31
    2596:	f2 e0       	ldi	r31, 0x02	; 2
    2598:	ff 2e       	mov	r15, r31
    259a:	f0 2d       	mov	r31, r0
    259c:	dd 24       	eor	r13, r13
    259e:	d3 94       	inc	r13
    25a0:	f7 01       	movw	r30, r14
    25a2:	80 81       	ld	r24, Z
    25a4:	81 11       	cpse	r24, r1
    25a6:	c0 cf       	rjmp	.-128    	; 0x2528 <xTaskResumeAll+0x30>
    25a8:	cd 2b       	or	r28, r29
    25aa:	11 f0       	breq	.+4      	; 0x25b0 <xTaskResumeAll+0xb8>
    25ac:	0e 94 0d 10 	call	0x201a	; 0x201a <prvResetNextTaskUnblockTime>
    25b0:	c0 91 42 02 	lds	r28, 0x0242	; 0x800242 <uxPendedTicks>
    25b4:	cc 23       	and	r28, r28
    25b6:	51 f0       	breq	.+20     	; 0x25cc <xTaskResumeAll+0xd4>
    25b8:	d1 e0       	ldi	r29, 0x01	; 1
    25ba:	0e 94 c1 11 	call	0x2382	; 0x2382 <xTaskIncrementTick>
    25be:	81 11       	cpse	r24, r1
    25c0:	d0 93 41 02 	sts	0x0241, r29	; 0x800241 <xYieldPending>
    25c4:	c1 50       	subi	r28, 0x01	; 1
    25c6:	c9 f7       	brne	.-14     	; 0x25ba <xTaskResumeAll+0xc2>
    25c8:	10 92 42 02 	sts	0x0242, r1	; 0x800242 <uxPendedTicks>
    25cc:	80 91 41 02 	lds	r24, 0x0241	; 0x800241 <xYieldPending>
    25d0:	88 23       	and	r24, r24
    25d2:	31 f0       	breq	.+12     	; 0x25e0 <xTaskResumeAll+0xe8>
    25d4:	0e 94 bc 15 	call	0x2b78	; 0x2b78 <vPortYield>
    25d8:	81 e0       	ldi	r24, 0x01	; 1
    25da:	03 c0       	rjmp	.+6      	; 0x25e2 <xTaskResumeAll+0xea>
    25dc:	80 e0       	ldi	r24, 0x00	; 0
    25de:	01 c0       	rjmp	.+2      	; 0x25e2 <xTaskResumeAll+0xea>
    25e0:	80 e0       	ldi	r24, 0x00	; 0
    25e2:	0f 90       	pop	r0
    25e4:	0f be       	out	0x3f, r0	; 63
    25e6:	df 91       	pop	r29
    25e8:	cf 91       	pop	r28
    25ea:	1f 91       	pop	r17
    25ec:	0f 91       	pop	r16
    25ee:	ff 90       	pop	r15
    25f0:	ef 90       	pop	r14
    25f2:	df 90       	pop	r13
    25f4:	08 95       	ret

000025f6 <vTaskDelay>:
    25f6:	cf 93       	push	r28
    25f8:	df 93       	push	r29
    25fa:	ec 01       	movw	r28, r24
    25fc:	89 2b       	or	r24, r25
    25fe:	51 f0       	breq	.+20     	; 0x2614 <vTaskDelay+0x1e>
    2600:	0e 94 bb 11 	call	0x2376	; 0x2376 <vTaskSuspendAll>
    2604:	60 e0       	ldi	r22, 0x00	; 0
    2606:	ce 01       	movw	r24, r28
    2608:	0e 94 2c 10 	call	0x2058	; 0x2058 <prvAddCurrentTaskToDelayedList>
    260c:	0e 94 7c 12 	call	0x24f8	; 0x24f8 <xTaskResumeAll>
    2610:	81 11       	cpse	r24, r1
    2612:	02 c0       	rjmp	.+4      	; 0x2618 <vTaskDelay+0x22>
    2614:	0e 94 bc 15 	call	0x2b78	; 0x2b78 <vPortYield>
    2618:	df 91       	pop	r29
    261a:	cf 91       	pop	r28
    261c:	08 95       	ret

0000261e <prvIdleTask>:
    261e:	02 e5       	ldi	r16, 0x52	; 82
    2620:	12 e0       	ldi	r17, 0x02	; 2
    2622:	0f 2e       	mov	r0, r31
    2624:	fa e7       	ldi	r31, 0x7A	; 122
    2626:	ef 2e       	mov	r14, r31
    2628:	f2 e0       	ldi	r31, 0x02	; 2
    262a:	ff 2e       	mov	r15, r31
    262c:	f0 2d       	mov	r31, r0
    262e:	29 c0       	rjmp	.+82     	; 0x2682 <prvIdleTask+0x64>
    2630:	0e 94 bb 11 	call	0x2376	; 0x2376 <vTaskSuspendAll>
    2634:	d8 01       	movw	r26, r16
    2636:	cc 91       	ld	r28, X
    2638:	0e 94 7c 12 	call	0x24f8	; 0x24f8 <xTaskResumeAll>
    263c:	cc 23       	and	r28, r28
    263e:	09 f1       	breq	.+66     	; 0x2682 <prvIdleTask+0x64>
    2640:	0f b6       	in	r0, 0x3f	; 63
    2642:	f8 94       	cli
    2644:	0f 92       	push	r0
    2646:	d8 01       	movw	r26, r16
    2648:	15 96       	adiw	r26, 0x05	; 5
    264a:	ed 91       	ld	r30, X+
    264c:	fc 91       	ld	r31, X
    264e:	16 97       	sbiw	r26, 0x06	; 6
    2650:	c6 81       	ldd	r28, Z+6	; 0x06
    2652:	d7 81       	ldd	r29, Z+7	; 0x07
    2654:	ce 01       	movw	r24, r28
    2656:	02 96       	adiw	r24, 0x02	; 2
    2658:	0e 94 ee 14 	call	0x29dc	; 0x29dc <uxListRemove>
    265c:	80 91 47 02 	lds	r24, 0x0247	; 0x800247 <uxCurrentNumberOfTasks>
    2660:	81 50       	subi	r24, 0x01	; 1
    2662:	80 93 47 02 	sts	0x0247, r24	; 0x800247 <uxCurrentNumberOfTasks>
    2666:	80 91 51 02 	lds	r24, 0x0251	; 0x800251 <uxDeletedTasksWaitingCleanUp>
    266a:	81 50       	subi	r24, 0x01	; 1
    266c:	80 93 51 02 	sts	0x0251, r24	; 0x800251 <uxDeletedTasksWaitingCleanUp>
    2670:	0f 90       	pop	r0
    2672:	0f be       	out	0x3f, r0	; 63
    2674:	8f 89       	ldd	r24, Y+23	; 0x17
    2676:	98 8d       	ldd	r25, Y+24	; 0x18
    2678:	0e 94 89 14 	call	0x2912	; 0x2912 <vPortFree>
    267c:	ce 01       	movw	r24, r28
    267e:	0e 94 89 14 	call	0x2912	; 0x2912 <vPortFree>
    2682:	80 91 51 02 	lds	r24, 0x0251	; 0x800251 <uxDeletedTasksWaitingCleanUp>
    2686:	81 11       	cpse	r24, r1
    2688:	d3 cf       	rjmp	.-90     	; 0x2630 <prvIdleTask+0x12>
    268a:	f7 01       	movw	r30, r14
    268c:	80 81       	ld	r24, Z
    268e:	82 30       	cpi	r24, 0x02	; 2
    2690:	c0 f3       	brcs	.-16     	; 0x2682 <prvIdleTask+0x64>
    2692:	0e 94 bc 15 	call	0x2b78	; 0x2b78 <vPortYield>
    2696:	f5 cf       	rjmp	.-22     	; 0x2682 <prvIdleTask+0x64>

00002698 <vTaskSwitchContext>:
    2698:	80 91 3a 02 	lds	r24, 0x023A	; 0x80023a <uxSchedulerSuspended>
    269c:	88 23       	and	r24, r24
    269e:	21 f0       	breq	.+8      	; 0x26a8 <vTaskSwitchContext+0x10>
    26a0:	81 e0       	ldi	r24, 0x01	; 1
    26a2:	80 93 41 02 	sts	0x0241, r24	; 0x800241 <xYieldPending>
    26a6:	08 95       	ret
    26a8:	10 92 41 02 	sts	0x0241, r1	; 0x800241 <xYieldPending>
    26ac:	20 91 44 02 	lds	r18, 0x0244	; 0x800244 <uxTopReadyPriority>
    26b0:	82 2f       	mov	r24, r18
    26b2:	90 e0       	ldi	r25, 0x00	; 0
    26b4:	fc 01       	movw	r30, r24
    26b6:	ee 0f       	add	r30, r30
    26b8:	ff 1f       	adc	r31, r31
    26ba:	ee 0f       	add	r30, r30
    26bc:	ff 1f       	adc	r31, r31
    26be:	ee 0f       	add	r30, r30
    26c0:	ff 1f       	adc	r31, r31
    26c2:	e8 0f       	add	r30, r24
    26c4:	f9 1f       	adc	r31, r25
    26c6:	e6 58       	subi	r30, 0x86	; 134
    26c8:	fd 4f       	sbci	r31, 0xFD	; 253
    26ca:	30 81       	ld	r19, Z
    26cc:	31 11       	cpse	r19, r1
    26ce:	11 c0       	rjmp	.+34     	; 0x26f2 <vTaskSwitchContext+0x5a>
    26d0:	21 50       	subi	r18, 0x01	; 1
    26d2:	82 2f       	mov	r24, r18
    26d4:	90 e0       	ldi	r25, 0x00	; 0
    26d6:	fc 01       	movw	r30, r24
    26d8:	ee 0f       	add	r30, r30
    26da:	ff 1f       	adc	r31, r31
    26dc:	ee 0f       	add	r30, r30
    26de:	ff 1f       	adc	r31, r31
    26e0:	ee 0f       	add	r30, r30
    26e2:	ff 1f       	adc	r31, r31
    26e4:	e8 0f       	add	r30, r24
    26e6:	f9 1f       	adc	r31, r25
    26e8:	e6 58       	subi	r30, 0x86	; 134
    26ea:	fd 4f       	sbci	r31, 0xFD	; 253
    26ec:	30 81       	ld	r19, Z
    26ee:	33 23       	and	r19, r19
    26f0:	79 f3       	breq	.-34     	; 0x26d0 <vTaskSwitchContext+0x38>
    26f2:	ac 01       	movw	r20, r24
    26f4:	44 0f       	add	r20, r20
    26f6:	55 1f       	adc	r21, r21
    26f8:	44 0f       	add	r20, r20
    26fa:	55 1f       	adc	r21, r21
    26fc:	44 0f       	add	r20, r20
    26fe:	55 1f       	adc	r21, r21
    2700:	48 0f       	add	r20, r24
    2702:	59 1f       	adc	r21, r25
    2704:	da 01       	movw	r26, r20
    2706:	a6 58       	subi	r26, 0x86	; 134
    2708:	bd 4f       	sbci	r27, 0xFD	; 253
    270a:	11 96       	adiw	r26, 0x01	; 1
    270c:	ed 91       	ld	r30, X+
    270e:	fc 91       	ld	r31, X
    2710:	12 97       	sbiw	r26, 0x02	; 2
    2712:	02 80       	ldd	r0, Z+2	; 0x02
    2714:	f3 81       	ldd	r31, Z+3	; 0x03
    2716:	e0 2d       	mov	r30, r0
    2718:	12 96       	adiw	r26, 0x02	; 2
    271a:	fc 93       	st	X, r31
    271c:	ee 93       	st	-X, r30
    271e:	11 97       	sbiw	r26, 0x01	; 1
    2720:	43 58       	subi	r20, 0x83	; 131
    2722:	5d 4f       	sbci	r21, 0xFD	; 253
    2724:	e4 17       	cp	r30, r20
    2726:	f5 07       	cpc	r31, r21
    2728:	29 f4       	brne	.+10     	; 0x2734 <vTaskSwitchContext+0x9c>
    272a:	42 81       	ldd	r20, Z+2	; 0x02
    272c:	53 81       	ldd	r21, Z+3	; 0x03
    272e:	fd 01       	movw	r30, r26
    2730:	52 83       	std	Z+2, r21	; 0x02
    2732:	41 83       	std	Z+1, r20	; 0x01
    2734:	fc 01       	movw	r30, r24
    2736:	ee 0f       	add	r30, r30
    2738:	ff 1f       	adc	r31, r31
    273a:	ee 0f       	add	r30, r30
    273c:	ff 1f       	adc	r31, r31
    273e:	ee 0f       	add	r30, r30
    2740:	ff 1f       	adc	r31, r31
    2742:	8e 0f       	add	r24, r30
    2744:	9f 1f       	adc	r25, r31
    2746:	fc 01       	movw	r30, r24
    2748:	e6 58       	subi	r30, 0x86	; 134
    274a:	fd 4f       	sbci	r31, 0xFD	; 253
    274c:	01 80       	ldd	r0, Z+1	; 0x01
    274e:	f2 81       	ldd	r31, Z+2	; 0x02
    2750:	e0 2d       	mov	r30, r0
    2752:	86 81       	ldd	r24, Z+6	; 0x06
    2754:	97 81       	ldd	r25, Z+7	; 0x07
    2756:	90 93 9f 02 	sts	0x029F, r25	; 0x80029f <pxCurrentTCB+0x1>
    275a:	80 93 9e 02 	sts	0x029E, r24	; 0x80029e <pxCurrentTCB>
    275e:	20 93 44 02 	sts	0x0244, r18	; 0x800244 <uxTopReadyPriority>
    2762:	08 95       	ret

00002764 <vTaskPlaceOnEventList>:
    2764:	cf 93       	push	r28
    2766:	df 93       	push	r29
    2768:	eb 01       	movw	r28, r22
    276a:	60 91 9e 02 	lds	r22, 0x029E	; 0x80029e <pxCurrentTCB>
    276e:	70 91 9f 02 	lds	r23, 0x029F	; 0x80029f <pxCurrentTCB+0x1>
    2772:	64 5f       	subi	r22, 0xF4	; 244
    2774:	7f 4f       	sbci	r23, 0xFF	; 255
    2776:	0e 94 bd 14 	call	0x297a	; 0x297a <vListInsert>
    277a:	61 e0       	ldi	r22, 0x01	; 1
    277c:	ce 01       	movw	r24, r28
    277e:	0e 94 2c 10 	call	0x2058	; 0x2058 <prvAddCurrentTaskToDelayedList>
    2782:	df 91       	pop	r29
    2784:	cf 91       	pop	r28
    2786:	08 95       	ret

00002788 <xTaskRemoveFromEventList>:
    2788:	0f 93       	push	r16
    278a:	1f 93       	push	r17
    278c:	cf 93       	push	r28
    278e:	df 93       	push	r29
    2790:	dc 01       	movw	r26, r24
    2792:	15 96       	adiw	r26, 0x05	; 5
    2794:	ed 91       	ld	r30, X+
    2796:	fc 91       	ld	r31, X
    2798:	16 97       	sbiw	r26, 0x06	; 6
    279a:	c6 81       	ldd	r28, Z+6	; 0x06
    279c:	d7 81       	ldd	r29, Z+7	; 0x07
    279e:	8e 01       	movw	r16, r28
    27a0:	04 5f       	subi	r16, 0xF4	; 244
    27a2:	1f 4f       	sbci	r17, 0xFF	; 255
    27a4:	c8 01       	movw	r24, r16
    27a6:	0e 94 ee 14 	call	0x29dc	; 0x29dc <uxListRemove>
    27aa:	80 91 3a 02 	lds	r24, 0x023A	; 0x80023a <uxSchedulerSuspended>
    27ae:	81 11       	cpse	r24, r1
    27b0:	1c c0       	rjmp	.+56     	; 0x27ea <xTaskRemoveFromEventList+0x62>
    27b2:	0a 50       	subi	r16, 0x0A	; 10
    27b4:	11 09       	sbc	r17, r1
    27b6:	c8 01       	movw	r24, r16
    27b8:	0e 94 ee 14 	call	0x29dc	; 0x29dc <uxListRemove>
    27bc:	8e 89       	ldd	r24, Y+22	; 0x16
    27be:	90 91 44 02 	lds	r25, 0x0244	; 0x800244 <uxTopReadyPriority>
    27c2:	98 17       	cp	r25, r24
    27c4:	10 f4       	brcc	.+4      	; 0x27ca <xTaskRemoveFromEventList+0x42>
    27c6:	80 93 44 02 	sts	0x0244, r24	; 0x800244 <uxTopReadyPriority>
    27ca:	90 e0       	ldi	r25, 0x00	; 0
    27cc:	9c 01       	movw	r18, r24
    27ce:	22 0f       	add	r18, r18
    27d0:	33 1f       	adc	r19, r19
    27d2:	22 0f       	add	r18, r18
    27d4:	33 1f       	adc	r19, r19
    27d6:	22 0f       	add	r18, r18
    27d8:	33 1f       	adc	r19, r19
    27da:	82 0f       	add	r24, r18
    27dc:	93 1f       	adc	r25, r19
    27de:	b8 01       	movw	r22, r16
    27e0:	86 58       	subi	r24, 0x86	; 134
    27e2:	9d 4f       	sbci	r25, 0xFD	; 253
    27e4:	0e 94 9c 14 	call	0x2938	; 0x2938 <vListInsertEnd>
    27e8:	05 c0       	rjmp	.+10     	; 0x27f4 <xTaskRemoveFromEventList+0x6c>
    27ea:	b8 01       	movw	r22, r16
    27ec:	8b e5       	ldi	r24, 0x5B	; 91
    27ee:	92 e0       	ldi	r25, 0x02	; 2
    27f0:	0e 94 9c 14 	call	0x2938	; 0x2938 <vListInsertEnd>
    27f4:	e0 91 9e 02 	lds	r30, 0x029E	; 0x80029e <pxCurrentTCB>
    27f8:	f0 91 9f 02 	lds	r31, 0x029F	; 0x80029f <pxCurrentTCB+0x1>
    27fc:	9e 89       	ldd	r25, Y+22	; 0x16
    27fe:	86 89       	ldd	r24, Z+22	; 0x16
    2800:	89 17       	cp	r24, r25
    2802:	20 f4       	brcc	.+8      	; 0x280c <xTaskRemoveFromEventList+0x84>
    2804:	81 e0       	ldi	r24, 0x01	; 1
    2806:	80 93 41 02 	sts	0x0241, r24	; 0x800241 <xYieldPending>
    280a:	01 c0       	rjmp	.+2      	; 0x280e <xTaskRemoveFromEventList+0x86>
    280c:	80 e0       	ldi	r24, 0x00	; 0
    280e:	df 91       	pop	r29
    2810:	cf 91       	pop	r28
    2812:	1f 91       	pop	r17
    2814:	0f 91       	pop	r16
    2816:	08 95       	ret

00002818 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2818:	20 91 40 02 	lds	r18, 0x0240	; 0x800240 <xNumOfOverflows>
    281c:	fc 01       	movw	r30, r24
    281e:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2820:	20 91 45 02 	lds	r18, 0x0245	; 0x800245 <xTickCount>
    2824:	30 91 46 02 	lds	r19, 0x0246	; 0x800246 <xTickCount+0x1>
    2828:	32 83       	std	Z+2, r19	; 0x02
    282a:	21 83       	std	Z+1, r18	; 0x01
    282c:	08 95       	ret

0000282e <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    282e:	0f b6       	in	r0, 0x3f	; 63
    2830:	f8 94       	cli
    2832:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    2834:	40 91 45 02 	lds	r20, 0x0245	; 0x800245 <xTickCount>
    2838:	50 91 46 02 	lds	r21, 0x0246	; 0x800246 <xTickCount+0x1>
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    283c:	db 01       	movw	r26, r22
    283e:	2d 91       	ld	r18, X+
    2840:	3c 91       	ld	r19, X
    2842:	2f 3f       	cpi	r18, 0xFF	; 255
    2844:	bf ef       	ldi	r27, 0xFF	; 255
    2846:	3b 07       	cpc	r19, r27
    2848:	19 f1       	breq	.+70     	; 0x2890 <xTaskCheckForTimeOut+0x62>
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    284a:	e0 91 40 02 	lds	r30, 0x0240	; 0x800240 <xNumOfOverflows>
    284e:	dc 01       	movw	r26, r24
    2850:	fc 91       	ld	r31, X
    2852:	fe 17       	cp	r31, r30
    2854:	39 f0       	breq	.+14     	; 0x2864 <xTaskCheckForTimeOut+0x36>
    2856:	11 96       	adiw	r26, 0x01	; 1
    2858:	ed 91       	ld	r30, X+
    285a:	fc 91       	ld	r31, X
    285c:	12 97       	sbiw	r26, 0x02	; 2
    285e:	4e 17       	cp	r20, r30
    2860:	5f 07       	cpc	r21, r31
    2862:	c0 f4       	brcc	.+48     	; 0x2894 <xTaskCheckForTimeOut+0x66>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    2864:	dc 01       	movw	r26, r24
    2866:	11 96       	adiw	r26, 0x01	; 1
    2868:	ed 91       	ld	r30, X+
    286a:	fc 91       	ld	r31, X
    286c:	12 97       	sbiw	r26, 0x02	; 2
    286e:	da 01       	movw	r26, r20
    2870:	ae 1b       	sub	r26, r30
    2872:	bf 0b       	sbc	r27, r31
    2874:	a2 17       	cp	r26, r18
    2876:	b3 07       	cpc	r27, r19
    2878:	78 f4       	brcc	.+30     	; 0x2898 <xTaskCheckForTimeOut+0x6a>
    287a:	db 01       	movw	r26, r22
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    287c:	e4 1b       	sub	r30, r20
    287e:	f5 0b       	sbc	r31, r21
    2880:	2e 0f       	add	r18, r30
    2882:	3f 1f       	adc	r19, r31
    2884:	2d 93       	st	X+, r18
    2886:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    2888:	0e 94 0c 14 	call	0x2818	; 0x2818 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    288c:	80 e0       	ldi	r24, 0x00	; 0
    288e:	05 c0       	rjmp	.+10     	; 0x289a <xTaskCheckForTimeOut+0x6c>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    2890:	80 e0       	ldi	r24, 0x00	; 0
    2892:	03 c0       	rjmp	.+6      	; 0x289a <xTaskCheckForTimeOut+0x6c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    2894:	81 e0       	ldi	r24, 0x01	; 1
    2896:	01 c0       	rjmp	.+2      	; 0x289a <xTaskCheckForTimeOut+0x6c>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2898:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    289a:	0f 90       	pop	r0
    289c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    289e:	08 95       	ret

000028a0 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    28a0:	81 e0       	ldi	r24, 0x01	; 1
    28a2:	80 93 41 02 	sts	0x0241, r24	; 0x800241 <xYieldPending>
    28a6:	08 95       	ret

000028a8 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    28a8:	cf 93       	push	r28
    28aa:	df 93       	push	r29
    28ac:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    28ae:	0e 94 bb 11 	call	0x2376	; 0x2376 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    28b2:	80 91 a0 02 	lds	r24, 0x02A0	; 0x8002a0 <pucAlignedHeap.2068>
    28b6:	90 91 a1 02 	lds	r25, 0x02A1	; 0x8002a1 <pucAlignedHeap.2068+0x1>
    28ba:	89 2b       	or	r24, r25
    28bc:	31 f4       	brne	.+12     	; 0x28ca <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    28be:	85 ea       	ldi	r24, 0xA5	; 165
    28c0:	92 e0       	ldi	r25, 0x02	; 2
    28c2:	90 93 a1 02 	sts	0x02A1, r25	; 0x8002a1 <pucAlignedHeap.2068+0x1>
    28c6:	80 93 a0 02 	sts	0x02A0, r24	; 0x8002a0 <pucAlignedHeap.2068>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    28ca:	20 91 a2 02 	lds	r18, 0x02A2	; 0x8002a2 <xNextFreeByte>
    28ce:	30 91 a3 02 	lds	r19, 0x02A3	; 0x8002a3 <xNextFreeByte+0x1>
    28d2:	c9 01       	movw	r24, r18
    28d4:	8c 0f       	add	r24, r28
    28d6:	9d 1f       	adc	r25, r29
    28d8:	8b 3d       	cpi	r24, 0xDB	; 219
    28da:	45 e0       	ldi	r20, 0x05	; 5
    28dc:	94 07       	cpc	r25, r20
    28de:	70 f4       	brcc	.+28     	; 0x28fc <pvPortMalloc+0x54>
    28e0:	28 17       	cp	r18, r24
    28e2:	39 07       	cpc	r19, r25
    28e4:	70 f4       	brcc	.+28     	; 0x2902 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    28e6:	c0 91 a0 02 	lds	r28, 0x02A0	; 0x8002a0 <pucAlignedHeap.2068>
    28ea:	d0 91 a1 02 	lds	r29, 0x02A1	; 0x8002a1 <pucAlignedHeap.2068+0x1>
    28ee:	c2 0f       	add	r28, r18
    28f0:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    28f2:	90 93 a3 02 	sts	0x02A3, r25	; 0x8002a3 <xNextFreeByte+0x1>
    28f6:	80 93 a2 02 	sts	0x02A2, r24	; 0x8002a2 <xNextFreeByte>
    28fa:	05 c0       	rjmp	.+10     	; 0x2906 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    28fc:	c0 e0       	ldi	r28, 0x00	; 0
    28fe:	d0 e0       	ldi	r29, 0x00	; 0
    2900:	02 c0       	rjmp	.+4      	; 0x2906 <pvPortMalloc+0x5e>
    2902:	c0 e0       	ldi	r28, 0x00	; 0
    2904:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2906:	0e 94 7c 12 	call	0x24f8	; 0x24f8 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    290a:	ce 01       	movw	r24, r28
    290c:	df 91       	pop	r29
    290e:	cf 91       	pop	r28
    2910:	08 95       	ret

00002912 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2912:	08 95       	ret

00002914 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2914:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2916:	03 96       	adiw	r24, 0x03	; 3
    2918:	92 83       	std	Z+2, r25	; 0x02
    291a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    291c:	2f ef       	ldi	r18, 0xFF	; 255
    291e:	3f ef       	ldi	r19, 0xFF	; 255
    2920:	34 83       	std	Z+4, r19	; 0x04
    2922:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2924:	96 83       	std	Z+6, r25	; 0x06
    2926:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2928:	90 87       	std	Z+8, r25	; 0x08
    292a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    292c:	10 82       	st	Z, r1
    292e:	08 95       	ret

00002930 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    2930:	fc 01       	movw	r30, r24
    2932:	11 86       	std	Z+9, r1	; 0x09
    2934:	10 86       	std	Z+8, r1	; 0x08
    2936:	08 95       	ret

00002938 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2938:	cf 93       	push	r28
    293a:	df 93       	push	r29
    293c:	9c 01       	movw	r18, r24
    293e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    2940:	dc 01       	movw	r26, r24
    2942:	11 96       	adiw	r26, 0x01	; 1
    2944:	cd 91       	ld	r28, X+
    2946:	dc 91       	ld	r29, X
    2948:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    294a:	d3 83       	std	Z+3, r29	; 0x03
    294c:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    294e:	8c 81       	ldd	r24, Y+4	; 0x04
    2950:	9d 81       	ldd	r25, Y+5	; 0x05
    2952:	95 83       	std	Z+5, r25	; 0x05
    2954:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    2956:	8c 81       	ldd	r24, Y+4	; 0x04
    2958:	9d 81       	ldd	r25, Y+5	; 0x05
    295a:	dc 01       	movw	r26, r24
    295c:	13 96       	adiw	r26, 0x03	; 3
    295e:	7c 93       	st	X, r23
    2960:	6e 93       	st	-X, r22
    2962:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    2964:	7d 83       	std	Y+5, r23	; 0x05
    2966:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2968:	31 87       	std	Z+9, r19	; 0x09
    296a:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    296c:	f9 01       	movw	r30, r18
    296e:	80 81       	ld	r24, Z
    2970:	8f 5f       	subi	r24, 0xFF	; 255
    2972:	80 83       	st	Z, r24
}
    2974:	df 91       	pop	r29
    2976:	cf 91       	pop	r28
    2978:	08 95       	ret

0000297a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    297a:	cf 93       	push	r28
    297c:	df 93       	push	r29
    297e:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    2980:	48 81       	ld	r20, Y
    2982:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2984:	4f 3f       	cpi	r20, 0xFF	; 255
    2986:	2f ef       	ldi	r18, 0xFF	; 255
    2988:	52 07       	cpc	r21, r18
    298a:	21 f4       	brne	.+8      	; 0x2994 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    298c:	fc 01       	movw	r30, r24
    298e:	a7 81       	ldd	r26, Z+7	; 0x07
    2990:	b0 85       	ldd	r27, Z+8	; 0x08
    2992:	0d c0       	rjmp	.+26     	; 0x29ae <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2994:	dc 01       	movw	r26, r24
    2996:	13 96       	adiw	r26, 0x03	; 3
    2998:	01 c0       	rjmp	.+2      	; 0x299c <vListInsert+0x22>
    299a:	df 01       	movw	r26, r30
    299c:	12 96       	adiw	r26, 0x02	; 2
    299e:	ed 91       	ld	r30, X+
    29a0:	fc 91       	ld	r31, X
    29a2:	13 97       	sbiw	r26, 0x03	; 3
    29a4:	20 81       	ld	r18, Z
    29a6:	31 81       	ldd	r19, Z+1	; 0x01
    29a8:	42 17       	cp	r20, r18
    29aa:	53 07       	cpc	r21, r19
    29ac:	b0 f7       	brcc	.-20     	; 0x299a <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    29ae:	12 96       	adiw	r26, 0x02	; 2
    29b0:	ed 91       	ld	r30, X+
    29b2:	fc 91       	ld	r31, X
    29b4:	13 97       	sbiw	r26, 0x03	; 3
    29b6:	fb 83       	std	Y+3, r31	; 0x03
    29b8:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    29ba:	d5 83       	std	Z+5, r29	; 0x05
    29bc:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    29be:	bd 83       	std	Y+5, r27	; 0x05
    29c0:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    29c2:	13 96       	adiw	r26, 0x03	; 3
    29c4:	dc 93       	st	X, r29
    29c6:	ce 93       	st	-X, r28
    29c8:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    29ca:	99 87       	std	Y+9, r25	; 0x09
    29cc:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    29ce:	fc 01       	movw	r30, r24
    29d0:	20 81       	ld	r18, Z
    29d2:	2f 5f       	subi	r18, 0xFF	; 255
    29d4:	20 83       	st	Z, r18
}
    29d6:	df 91       	pop	r29
    29d8:	cf 91       	pop	r28
    29da:	08 95       	ret

000029dc <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    29dc:	cf 93       	push	r28
    29de:	df 93       	push	r29
    29e0:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    29e2:	a0 85       	ldd	r26, Z+8	; 0x08
    29e4:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    29e6:	c2 81       	ldd	r28, Z+2	; 0x02
    29e8:	d3 81       	ldd	r29, Z+3	; 0x03
    29ea:	84 81       	ldd	r24, Z+4	; 0x04
    29ec:	95 81       	ldd	r25, Z+5	; 0x05
    29ee:	9d 83       	std	Y+5, r25	; 0x05
    29f0:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    29f2:	c4 81       	ldd	r28, Z+4	; 0x04
    29f4:	d5 81       	ldd	r29, Z+5	; 0x05
    29f6:	82 81       	ldd	r24, Z+2	; 0x02
    29f8:	93 81       	ldd	r25, Z+3	; 0x03
    29fa:	9b 83       	std	Y+3, r25	; 0x03
    29fc:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    29fe:	11 96       	adiw	r26, 0x01	; 1
    2a00:	8d 91       	ld	r24, X+
    2a02:	9c 91       	ld	r25, X
    2a04:	12 97       	sbiw	r26, 0x02	; 2
    2a06:	e8 17       	cp	r30, r24
    2a08:	f9 07       	cpc	r31, r25
    2a0a:	31 f4       	brne	.+12     	; 0x2a18 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2a0c:	84 81       	ldd	r24, Z+4	; 0x04
    2a0e:	95 81       	ldd	r25, Z+5	; 0x05
    2a10:	12 96       	adiw	r26, 0x02	; 2
    2a12:	9c 93       	st	X, r25
    2a14:	8e 93       	st	-X, r24
    2a16:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    2a18:	11 86       	std	Z+9, r1	; 0x09
    2a1a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    2a1c:	8c 91       	ld	r24, X
    2a1e:	81 50       	subi	r24, 0x01	; 1
    2a20:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    2a22:	df 91       	pop	r29
    2a24:	cf 91       	pop	r28
    2a26:	08 95       	ret

00002a28 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2a28:	31 e1       	ldi	r19, 0x11	; 17
    2a2a:	fc 01       	movw	r30, r24
    2a2c:	30 83       	st	Z, r19
    2a2e:	31 97       	sbiw	r30, 0x01	; 1
    2a30:	22 e2       	ldi	r18, 0x22	; 34
    2a32:	20 83       	st	Z, r18
    2a34:	31 97       	sbiw	r30, 0x01	; 1
    2a36:	a3 e3       	ldi	r26, 0x33	; 51
    2a38:	a0 83       	st	Z, r26
    2a3a:	31 97       	sbiw	r30, 0x01	; 1
    2a3c:	60 83       	st	Z, r22
    2a3e:	31 97       	sbiw	r30, 0x01	; 1
    2a40:	70 83       	st	Z, r23
    2a42:	31 97       	sbiw	r30, 0x01	; 1
    2a44:	10 82       	st	Z, r1
    2a46:	31 97       	sbiw	r30, 0x01	; 1
    2a48:	60 e8       	ldi	r22, 0x80	; 128
    2a4a:	60 83       	st	Z, r22
    2a4c:	31 97       	sbiw	r30, 0x01	; 1
    2a4e:	10 82       	st	Z, r1
    2a50:	31 97       	sbiw	r30, 0x01	; 1
    2a52:	62 e0       	ldi	r22, 0x02	; 2
    2a54:	60 83       	st	Z, r22
    2a56:	31 97       	sbiw	r30, 0x01	; 1
    2a58:	63 e0       	ldi	r22, 0x03	; 3
    2a5a:	60 83       	st	Z, r22
    2a5c:	31 97       	sbiw	r30, 0x01	; 1
    2a5e:	64 e0       	ldi	r22, 0x04	; 4
    2a60:	60 83       	st	Z, r22
    2a62:	31 97       	sbiw	r30, 0x01	; 1
    2a64:	65 e0       	ldi	r22, 0x05	; 5
    2a66:	60 83       	st	Z, r22
    2a68:	31 97       	sbiw	r30, 0x01	; 1
    2a6a:	66 e0       	ldi	r22, 0x06	; 6
    2a6c:	60 83       	st	Z, r22
    2a6e:	31 97       	sbiw	r30, 0x01	; 1
    2a70:	67 e0       	ldi	r22, 0x07	; 7
    2a72:	60 83       	st	Z, r22
    2a74:	31 97       	sbiw	r30, 0x01	; 1
    2a76:	68 e0       	ldi	r22, 0x08	; 8
    2a78:	60 83       	st	Z, r22
    2a7a:	31 97       	sbiw	r30, 0x01	; 1
    2a7c:	69 e0       	ldi	r22, 0x09	; 9
    2a7e:	60 83       	st	Z, r22
    2a80:	31 97       	sbiw	r30, 0x01	; 1
    2a82:	60 e1       	ldi	r22, 0x10	; 16
    2a84:	60 83       	st	Z, r22
    2a86:	31 97       	sbiw	r30, 0x01	; 1
    2a88:	30 83       	st	Z, r19
    2a8a:	31 97       	sbiw	r30, 0x01	; 1
    2a8c:	32 e1       	ldi	r19, 0x12	; 18
    2a8e:	30 83       	st	Z, r19
    2a90:	31 97       	sbiw	r30, 0x01	; 1
    2a92:	33 e1       	ldi	r19, 0x13	; 19
    2a94:	30 83       	st	Z, r19
    2a96:	31 97       	sbiw	r30, 0x01	; 1
    2a98:	34 e1       	ldi	r19, 0x14	; 20
    2a9a:	30 83       	st	Z, r19
    2a9c:	31 97       	sbiw	r30, 0x01	; 1
    2a9e:	35 e1       	ldi	r19, 0x15	; 21
    2aa0:	30 83       	st	Z, r19
    2aa2:	31 97       	sbiw	r30, 0x01	; 1
    2aa4:	36 e1       	ldi	r19, 0x16	; 22
    2aa6:	30 83       	st	Z, r19
    2aa8:	31 97       	sbiw	r30, 0x01	; 1
    2aaa:	37 e1       	ldi	r19, 0x17	; 23
    2aac:	30 83       	st	Z, r19
    2aae:	31 97       	sbiw	r30, 0x01	; 1
    2ab0:	38 e1       	ldi	r19, 0x18	; 24
    2ab2:	30 83       	st	Z, r19
    2ab4:	31 97       	sbiw	r30, 0x01	; 1
    2ab6:	39 e1       	ldi	r19, 0x19	; 25
    2ab8:	30 83       	st	Z, r19
    2aba:	31 97       	sbiw	r30, 0x01	; 1
    2abc:	30 e2       	ldi	r19, 0x20	; 32
    2abe:	30 83       	st	Z, r19
    2ac0:	31 97       	sbiw	r30, 0x01	; 1
    2ac2:	31 e2       	ldi	r19, 0x21	; 33
    2ac4:	30 83       	st	Z, r19
    2ac6:	31 97       	sbiw	r30, 0x01	; 1
    2ac8:	20 83       	st	Z, r18
    2aca:	31 97       	sbiw	r30, 0x01	; 1
    2acc:	23 e2       	ldi	r18, 0x23	; 35
    2ace:	20 83       	st	Z, r18
    2ad0:	31 97       	sbiw	r30, 0x01	; 1
    2ad2:	40 83       	st	Z, r20
    2ad4:	31 97       	sbiw	r30, 0x01	; 1
    2ad6:	50 83       	st	Z, r21
    2ad8:	31 97       	sbiw	r30, 0x01	; 1
    2ada:	26 e2       	ldi	r18, 0x26	; 38
    2adc:	20 83       	st	Z, r18
    2ade:	31 97       	sbiw	r30, 0x01	; 1
    2ae0:	27 e2       	ldi	r18, 0x27	; 39
    2ae2:	20 83       	st	Z, r18
    2ae4:	31 97       	sbiw	r30, 0x01	; 1
    2ae6:	28 e2       	ldi	r18, 0x28	; 40
    2ae8:	20 83       	st	Z, r18
    2aea:	31 97       	sbiw	r30, 0x01	; 1
    2aec:	29 e2       	ldi	r18, 0x29	; 41
    2aee:	20 83       	st	Z, r18
    2af0:	31 97       	sbiw	r30, 0x01	; 1
    2af2:	20 e3       	ldi	r18, 0x30	; 48
    2af4:	20 83       	st	Z, r18
    2af6:	31 97       	sbiw	r30, 0x01	; 1
    2af8:	21 e3       	ldi	r18, 0x31	; 49
    2afa:	20 83       	st	Z, r18
    2afc:	86 97       	sbiw	r24, 0x26	; 38
    2afe:	08 95       	ret

00002b00 <xPortStartScheduler>:
    2b00:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
    2b04:	89 ef       	ldi	r24, 0xF9	; 249
    2b06:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
    2b0a:	e1 e8       	ldi	r30, 0x81	; 129
    2b0c:	f0 e0       	ldi	r31, 0x00	; 0
    2b0e:	80 81       	ld	r24, Z
    2b10:	8b 60       	ori	r24, 0x0B	; 11
    2b12:	80 83       	st	Z, r24
    2b14:	ef e6       	ldi	r30, 0x6F	; 111
    2b16:	f0 e0       	ldi	r31, 0x00	; 0
    2b18:	80 81       	ld	r24, Z
    2b1a:	82 60       	ori	r24, 0x02	; 2
    2b1c:	80 83       	st	Z, r24
    2b1e:	a0 91 9e 02 	lds	r26, 0x029E	; 0x80029e <pxCurrentTCB>
    2b22:	b0 91 9f 02 	lds	r27, 0x029F	; 0x80029f <pxCurrentTCB+0x1>
    2b26:	cd 91       	ld	r28, X+
    2b28:	cd bf       	out	0x3d, r28	; 61
    2b2a:	dd 91       	ld	r29, X+
    2b2c:	de bf       	out	0x3e, r29	; 62
    2b2e:	ff 91       	pop	r31
    2b30:	ef 91       	pop	r30
    2b32:	df 91       	pop	r29
    2b34:	cf 91       	pop	r28
    2b36:	bf 91       	pop	r27
    2b38:	af 91       	pop	r26
    2b3a:	9f 91       	pop	r25
    2b3c:	8f 91       	pop	r24
    2b3e:	7f 91       	pop	r23
    2b40:	6f 91       	pop	r22
    2b42:	5f 91       	pop	r21
    2b44:	4f 91       	pop	r20
    2b46:	3f 91       	pop	r19
    2b48:	2f 91       	pop	r18
    2b4a:	1f 91       	pop	r17
    2b4c:	0f 91       	pop	r16
    2b4e:	ff 90       	pop	r15
    2b50:	ef 90       	pop	r14
    2b52:	df 90       	pop	r13
    2b54:	cf 90       	pop	r12
    2b56:	bf 90       	pop	r11
    2b58:	af 90       	pop	r10
    2b5a:	9f 90       	pop	r9
    2b5c:	8f 90       	pop	r8
    2b5e:	7f 90       	pop	r7
    2b60:	6f 90       	pop	r6
    2b62:	5f 90       	pop	r5
    2b64:	4f 90       	pop	r4
    2b66:	3f 90       	pop	r3
    2b68:	2f 90       	pop	r2
    2b6a:	1f 90       	pop	r1
    2b6c:	0f 90       	pop	r0
    2b6e:	0f be       	out	0x3f, r0	; 63
    2b70:	0f 90       	pop	r0
    2b72:	08 95       	ret
    2b74:	81 e0       	ldi	r24, 0x01	; 1
    2b76:	08 95       	ret

00002b78 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2b78:	0f 92       	push	r0
    2b7a:	0f b6       	in	r0, 0x3f	; 63
    2b7c:	f8 94       	cli
    2b7e:	0f 92       	push	r0
    2b80:	1f 92       	push	r1
    2b82:	11 24       	eor	r1, r1
    2b84:	2f 92       	push	r2
    2b86:	3f 92       	push	r3
    2b88:	4f 92       	push	r4
    2b8a:	5f 92       	push	r5
    2b8c:	6f 92       	push	r6
    2b8e:	7f 92       	push	r7
    2b90:	8f 92       	push	r8
    2b92:	9f 92       	push	r9
    2b94:	af 92       	push	r10
    2b96:	bf 92       	push	r11
    2b98:	cf 92       	push	r12
    2b9a:	df 92       	push	r13
    2b9c:	ef 92       	push	r14
    2b9e:	ff 92       	push	r15
    2ba0:	0f 93       	push	r16
    2ba2:	1f 93       	push	r17
    2ba4:	2f 93       	push	r18
    2ba6:	3f 93       	push	r19
    2ba8:	4f 93       	push	r20
    2baa:	5f 93       	push	r21
    2bac:	6f 93       	push	r22
    2bae:	7f 93       	push	r23
    2bb0:	8f 93       	push	r24
    2bb2:	9f 93       	push	r25
    2bb4:	af 93       	push	r26
    2bb6:	bf 93       	push	r27
    2bb8:	cf 93       	push	r28
    2bba:	df 93       	push	r29
    2bbc:	ef 93       	push	r30
    2bbe:	ff 93       	push	r31
    2bc0:	a0 91 9e 02 	lds	r26, 0x029E	; 0x80029e <pxCurrentTCB>
    2bc4:	b0 91 9f 02 	lds	r27, 0x029F	; 0x80029f <pxCurrentTCB+0x1>
    2bc8:	0d b6       	in	r0, 0x3d	; 61
    2bca:	0d 92       	st	X+, r0
    2bcc:	0e b6       	in	r0, 0x3e	; 62
    2bce:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    2bd0:	0e 94 4c 13 	call	0x2698	; 0x2698 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2bd4:	a0 91 9e 02 	lds	r26, 0x029E	; 0x80029e <pxCurrentTCB>
    2bd8:	b0 91 9f 02 	lds	r27, 0x029F	; 0x80029f <pxCurrentTCB+0x1>
    2bdc:	cd 91       	ld	r28, X+
    2bde:	cd bf       	out	0x3d, r28	; 61
    2be0:	dd 91       	ld	r29, X+
    2be2:	de bf       	out	0x3e, r29	; 62
    2be4:	ff 91       	pop	r31
    2be6:	ef 91       	pop	r30
    2be8:	df 91       	pop	r29
    2bea:	cf 91       	pop	r28
    2bec:	bf 91       	pop	r27
    2bee:	af 91       	pop	r26
    2bf0:	9f 91       	pop	r25
    2bf2:	8f 91       	pop	r24
    2bf4:	7f 91       	pop	r23
    2bf6:	6f 91       	pop	r22
    2bf8:	5f 91       	pop	r21
    2bfa:	4f 91       	pop	r20
    2bfc:	3f 91       	pop	r19
    2bfe:	2f 91       	pop	r18
    2c00:	1f 91       	pop	r17
    2c02:	0f 91       	pop	r16
    2c04:	ff 90       	pop	r15
    2c06:	ef 90       	pop	r14
    2c08:	df 90       	pop	r13
    2c0a:	cf 90       	pop	r12
    2c0c:	bf 90       	pop	r11
    2c0e:	af 90       	pop	r10
    2c10:	9f 90       	pop	r9
    2c12:	8f 90       	pop	r8
    2c14:	7f 90       	pop	r7
    2c16:	6f 90       	pop	r6
    2c18:	5f 90       	pop	r5
    2c1a:	4f 90       	pop	r4
    2c1c:	3f 90       	pop	r3
    2c1e:	2f 90       	pop	r2
    2c20:	1f 90       	pop	r1
    2c22:	0f 90       	pop	r0
    2c24:	0f be       	out	0x3f, r0	; 63
    2c26:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2c28:	08 95       	ret

00002c2a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2c2a:	0f 92       	push	r0
    2c2c:	0f b6       	in	r0, 0x3f	; 63
    2c2e:	f8 94       	cli
    2c30:	0f 92       	push	r0
    2c32:	1f 92       	push	r1
    2c34:	11 24       	eor	r1, r1
    2c36:	2f 92       	push	r2
    2c38:	3f 92       	push	r3
    2c3a:	4f 92       	push	r4
    2c3c:	5f 92       	push	r5
    2c3e:	6f 92       	push	r6
    2c40:	7f 92       	push	r7
    2c42:	8f 92       	push	r8
    2c44:	9f 92       	push	r9
    2c46:	af 92       	push	r10
    2c48:	bf 92       	push	r11
    2c4a:	cf 92       	push	r12
    2c4c:	df 92       	push	r13
    2c4e:	ef 92       	push	r14
    2c50:	ff 92       	push	r15
    2c52:	0f 93       	push	r16
    2c54:	1f 93       	push	r17
    2c56:	2f 93       	push	r18
    2c58:	3f 93       	push	r19
    2c5a:	4f 93       	push	r20
    2c5c:	5f 93       	push	r21
    2c5e:	6f 93       	push	r22
    2c60:	7f 93       	push	r23
    2c62:	8f 93       	push	r24
    2c64:	9f 93       	push	r25
    2c66:	af 93       	push	r26
    2c68:	bf 93       	push	r27
    2c6a:	cf 93       	push	r28
    2c6c:	df 93       	push	r29
    2c6e:	ef 93       	push	r30
    2c70:	ff 93       	push	r31
    2c72:	a0 91 9e 02 	lds	r26, 0x029E	; 0x80029e <pxCurrentTCB>
    2c76:	b0 91 9f 02 	lds	r27, 0x029F	; 0x80029f <pxCurrentTCB+0x1>
    2c7a:	0d b6       	in	r0, 0x3d	; 61
    2c7c:	0d 92       	st	X+, r0
    2c7e:	0e b6       	in	r0, 0x3e	; 62
    2c80:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    2c82:	0e 94 c1 11 	call	0x2382	; 0x2382 <xTaskIncrementTick>
    2c86:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    2c88:	0e 94 4c 13 	call	0x2698	; 0x2698 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    2c8c:	a0 91 9e 02 	lds	r26, 0x029E	; 0x80029e <pxCurrentTCB>
    2c90:	b0 91 9f 02 	lds	r27, 0x029F	; 0x80029f <pxCurrentTCB+0x1>
    2c94:	cd 91       	ld	r28, X+
    2c96:	cd bf       	out	0x3d, r28	; 61
    2c98:	dd 91       	ld	r29, X+
    2c9a:	de bf       	out	0x3e, r29	; 62
    2c9c:	ff 91       	pop	r31
    2c9e:	ef 91       	pop	r30
    2ca0:	df 91       	pop	r29
    2ca2:	cf 91       	pop	r28
    2ca4:	bf 91       	pop	r27
    2ca6:	af 91       	pop	r26
    2ca8:	9f 91       	pop	r25
    2caa:	8f 91       	pop	r24
    2cac:	7f 91       	pop	r23
    2cae:	6f 91       	pop	r22
    2cb0:	5f 91       	pop	r21
    2cb2:	4f 91       	pop	r20
    2cb4:	3f 91       	pop	r19
    2cb6:	2f 91       	pop	r18
    2cb8:	1f 91       	pop	r17
    2cba:	0f 91       	pop	r16
    2cbc:	ff 90       	pop	r15
    2cbe:	ef 90       	pop	r14
    2cc0:	df 90       	pop	r13
    2cc2:	cf 90       	pop	r12
    2cc4:	bf 90       	pop	r11
    2cc6:	af 90       	pop	r10
    2cc8:	9f 90       	pop	r9
    2cca:	8f 90       	pop	r8
    2ccc:	7f 90       	pop	r7
    2cce:	6f 90       	pop	r6
    2cd0:	5f 90       	pop	r5
    2cd2:	4f 90       	pop	r4
    2cd4:	3f 90       	pop	r3
    2cd6:	2f 90       	pop	r2
    2cd8:	1f 90       	pop	r1
    2cda:	0f 90       	pop	r0
    2cdc:	0f be       	out	0x3f, r0	; 63
    2cde:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2ce0:	08 95       	ret

00002ce2 <__vector_11>:
	
	
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    2ce2:	0e 94 15 16 	call	0x2c2a	; 0x2c2a <vPortYieldFromTick>
		asm volatile ( "reti" );
    2ce6:	18 95       	reti

00002ce8 <_ZN14HardwareSerial9availableEv>:
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
    2ce8:	fc 01       	movw	r30, r24
    2cea:	21 8d       	ldd	r18, Z+25	; 0x19
    2cec:	30 e0       	ldi	r19, 0x00	; 0
    2cee:	20 5f       	subi	r18, 0xF0	; 240
    2cf0:	3f 4f       	sbci	r19, 0xFF	; 255
    2cf2:	82 8d       	ldd	r24, Z+26	; 0x1a
    2cf4:	a9 01       	movw	r20, r18
    2cf6:	48 1b       	sub	r20, r24
    2cf8:	51 09       	sbc	r21, r1
    2cfa:	ca 01       	movw	r24, r20
}
    2cfc:	8f 70       	andi	r24, 0x0F	; 15
    2cfe:	99 27       	eor	r25, r25
    2d00:	08 95       	ret

00002d02 <_ZN14HardwareSerial4peekEv>:

int HardwareSerial::peek(void)
{
    2d02:	fc 01       	movw	r30, r24
  if (_rx_buffer_head == _rx_buffer_tail) {
    2d04:	91 8d       	ldd	r25, Z+25	; 0x19
    2d06:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d08:	98 17       	cp	r25, r24
    2d0a:	31 f0       	breq	.+12     	; 0x2d18 <_ZN14HardwareSerial4peekEv+0x16>
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
    2d0c:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d0e:	e8 0f       	add	r30, r24
    2d10:	f1 1d       	adc	r31, r1
    2d12:	85 8d       	ldd	r24, Z+29	; 0x1d
    2d14:	90 e0       	ldi	r25, 0x00	; 0
    2d16:	08 95       	ret
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
    2d18:	8f ef       	ldi	r24, 0xFF	; 255
    2d1a:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
    2d1c:	08 95       	ret

00002d1e <_ZN14HardwareSerial4readEv>:

int HardwareSerial::read(void)
{
    2d1e:	fc 01       	movw	r30, r24
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    2d20:	91 8d       	ldd	r25, Z+25	; 0x19
    2d22:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d24:	98 17       	cp	r25, r24
    2d26:	61 f0       	breq	.+24     	; 0x2d40 <_ZN14HardwareSerial4readEv+0x22>
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    2d28:	82 8d       	ldd	r24, Z+26	; 0x1a
    2d2a:	df 01       	movw	r26, r30
    2d2c:	a8 0f       	add	r26, r24
    2d2e:	b1 1d       	adc	r27, r1
    2d30:	5d 96       	adiw	r26, 0x1d	; 29
    2d32:	8c 91       	ld	r24, X
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    2d34:	92 8d       	ldd	r25, Z+26	; 0x1a
    2d36:	9f 5f       	subi	r25, 0xFF	; 255
    2d38:	9f 70       	andi	r25, 0x0F	; 15
    2d3a:	92 8f       	std	Z+26, r25	; 0x1a
    return c;
    2d3c:	90 e0       	ldi	r25, 0x00	; 0
    2d3e:	08 95       	ret

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
    2d40:	8f ef       	ldi	r24, 0xFF	; 255
    2d42:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
    2d44:	08 95       	ret

00002d46 <_ZN14HardwareSerial17availableForWriteEv>:
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
    2d46:	fc 01       	movw	r30, r24
    2d48:	23 8d       	ldd	r18, Z+27	; 0x1b
    tail = _tx_buffer_tail;
    2d4a:	34 8d       	ldd	r19, Z+28	; 0x1c
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
    2d4c:	23 17       	cp	r18, r19
    2d4e:	38 f0       	brcs	.+14     	; 0x2d5e <_ZN14HardwareSerial17availableForWriteEv+0x18>
    2d50:	8f e0       	ldi	r24, 0x0F	; 15
    2d52:	90 e0       	ldi	r25, 0x00	; 0
    2d54:	82 1b       	sub	r24, r18
    2d56:	91 09       	sbc	r25, r1
    2d58:	83 0f       	add	r24, r19
    2d5a:	91 1d       	adc	r25, r1
    2d5c:	08 95       	ret
  return tail - head - 1;
    2d5e:	83 2f       	mov	r24, r19
    2d60:	90 e0       	ldi	r25, 0x00	; 0
    2d62:	82 1b       	sub	r24, r18
    2d64:	91 09       	sbc	r25, r1
    2d66:	01 97       	sbiw	r24, 0x01	; 1
}
    2d68:	08 95       	ret

00002d6a <_ZN14HardwareSerial5writeEh>:
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished transmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
    2d6a:	fc 01       	movw	r30, r24
  _written = true;
    2d6c:	81 e0       	ldi	r24, 0x01	; 1
    2d6e:	80 8f       	std	Z+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    2d70:	93 8d       	ldd	r25, Z+27	; 0x1b
    2d72:	84 8d       	ldd	r24, Z+28	; 0x1c
    2d74:	98 13       	cpse	r25, r24
    2d76:	07 c0       	rjmp	.+14     	; 0x2d86 <_ZN14HardwareSerial5writeEh+0x1c>
    2d78:	a0 89       	ldd	r26, Z+16	; 0x10
    2d7a:	b1 89       	ldd	r27, Z+17	; 0x11
    2d7c:	8c 91       	ld	r24, X
    2d7e:	85 fd       	sbrc	r24, 5
    2d80:	04 c0       	rjmp	.+8      	; 0x2d8a <_ZN14HardwareSerial5writeEh+0x20>
    2d82:	80 e0       	ldi	r24, 0x00	; 0
    2d84:	03 c0       	rjmp	.+6      	; 0x2d8c <_ZN14HardwareSerial5writeEh+0x22>
    2d86:	80 e0       	ldi	r24, 0x00	; 0
    2d88:	01 c0       	rjmp	.+2      	; 0x2d8c <_ZN14HardwareSerial5writeEh+0x22>
    2d8a:	81 e0       	ldi	r24, 0x01	; 1
    2d8c:	88 23       	and	r24, r24
    2d8e:	91 f0       	breq	.+36     	; 0x2db4 <_ZN14HardwareSerial5writeEh+0x4a>
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    2d90:	9f b7       	in	r25, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    2d92:	f8 94       	cli
    2d94:	81 e0       	ldi	r24, 0x01	; 1
    2d96:	88 23       	and	r24, r24
    2d98:	59 f0       	breq	.+22     	; 0x2db0 <_ZN14HardwareSerial5writeEh+0x46>
      *_udr = c;
    2d9a:	a6 89       	ldd	r26, Z+22	; 0x16
    2d9c:	b7 89       	ldd	r27, Z+23	; 0x17
    2d9e:	6c 93       	st	X, r22
#ifdef MPCM0
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
    2da0:	a0 89       	ldd	r26, Z+16	; 0x10
    2da2:	b1 89       	ldd	r27, Z+17	; 0x11
    2da4:	8c 91       	ld	r24, X
    2da6:	83 70       	andi	r24, 0x03	; 3
    2da8:	80 64       	ori	r24, 0x40	; 64
    2daa:	8c 93       	st	X, r24
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    2dac:	80 e0       	ldi	r24, 0x00	; 0
    2dae:	f3 cf       	rjmp	.-26     	; 0x2d96 <_ZN14HardwareSerial5writeEh+0x2c>
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    2db0:	9f bf       	out	0x3f, r25	; 63
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
#else
      *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
#endif
    }
    return 1;
    2db2:	53 c0       	rjmp	.+166    	; 0x2e5a <_ZN14HardwareSerial5writeEh+0xf0>
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
    2db4:	83 8d       	ldd	r24, Z+27	; 0x1b
    2db6:	90 e0       	ldi	r25, 0x00	; 0
    2db8:	01 96       	adiw	r24, 0x01	; 1
    2dba:	8f 70       	andi	r24, 0x0F	; 15
    2dbc:	90 78       	andi	r25, 0x80	; 128
    2dbe:	99 23       	and	r25, r25
    2dc0:	24 f4       	brge	.+8      	; 0x2dca <_ZN14HardwareSerial5writeEh+0x60>
    2dc2:	01 97       	sbiw	r24, 0x01	; 1
    2dc4:	80 6f       	ori	r24, 0xF0	; 240
    2dc6:	9f 6f       	ori	r25, 0xFF	; 255
    2dc8:	01 96       	adiw	r24, 0x01	; 1
    2dca:	98 2f       	mov	r25, r24
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
    2dcc:	84 8d       	ldd	r24, Z+28	; 0x1c
    2dce:	98 13       	cpse	r25, r24
    2dd0:	30 c0       	rjmp	.+96     	; 0x2e32 <_ZN14HardwareSerial5writeEh+0xc8>
    if (bit_is_clear(SREG, SREG_I)) {
    2dd2:	0f b6       	in	r0, 0x3f	; 63
    2dd4:	07 fc       	sbrc	r0, 7
    2dd6:	fa cf       	rjmp	.-12     	; 0x2dcc <_ZN14HardwareSerial5writeEh+0x62>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
    2dd8:	a0 89       	ldd	r26, Z+16	; 0x10
    2dda:	b1 89       	ldd	r27, Z+17	; 0x11
    2ddc:	8c 91       	ld	r24, X
    2dde:	85 ff       	sbrs	r24, 5
    2de0:	f5 cf       	rjmp	.-22     	; 0x2dcc <_ZN14HardwareSerial5writeEh+0x62>
	    };
    }
    inline void _tx_udr_empty_irq(void){
	    // If interrupts are enabled, there must be more data in the output
	    // buffer. Send the next byte
	    unsigned char c = _tx_buffer[_tx_buffer_tail];
    2de2:	84 8d       	ldd	r24, Z+28	; 0x1c
    2de4:	df 01       	movw	r26, r30
    2de6:	a8 0f       	add	r26, r24
    2de8:	b1 1d       	adc	r27, r1
    2dea:	9d 96       	adiw	r26, 0x2d	; 45
    2dec:	8c 91       	ld	r24, X
	    _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
    2dee:	24 8d       	ldd	r18, Z+28	; 0x1c
    2df0:	30 e0       	ldi	r19, 0x00	; 0
    2df2:	2f 5f       	subi	r18, 0xFF	; 255
    2df4:	3f 4f       	sbci	r19, 0xFF	; 255
    2df6:	2f 70       	andi	r18, 0x0F	; 15
    2df8:	30 78       	andi	r19, 0x80	; 128
    2dfa:	33 23       	and	r19, r19
    2dfc:	34 f4       	brge	.+12     	; 0x2e0a <_ZN14HardwareSerial5writeEh+0xa0>
    2dfe:	21 50       	subi	r18, 0x01	; 1
    2e00:	31 09       	sbc	r19, r1
    2e02:	20 6f       	ori	r18, 0xF0	; 240
    2e04:	3f 6f       	ori	r19, 0xFF	; 255
    2e06:	2f 5f       	subi	r18, 0xFF	; 255
    2e08:	3f 4f       	sbci	r19, 0xFF	; 255
    2e0a:	24 8f       	std	Z+28, r18	; 0x1c

	    *_udr = c;
    2e0c:	a6 89       	ldd	r26, Z+22	; 0x16
    2e0e:	b7 89       	ldd	r27, Z+23	; 0x17
    2e10:	8c 93       	st	X, r24
	    // location". This makes sure flush() won't return until the bytes
	    // actually got written. Other r/w bits are preserved, and zeroes
	    // written to the rest.

	    #ifdef MPCM0
	    *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
    2e12:	a0 89       	ldd	r26, Z+16	; 0x10
    2e14:	b1 89       	ldd	r27, Z+17	; 0x11
    2e16:	8c 91       	ld	r24, X
    2e18:	83 70       	andi	r24, 0x03	; 3
    2e1a:	80 64       	ori	r24, 0x40	; 64
    2e1c:	8c 93       	st	X, r24
	    #else
	    *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
	    #endif

	    if (_tx_buffer_head == _tx_buffer_tail) {
    2e1e:	23 8d       	ldd	r18, Z+27	; 0x1b
    2e20:	84 8d       	ldd	r24, Z+28	; 0x1c
    2e22:	28 13       	cpse	r18, r24
    2e24:	d3 cf       	rjmp	.-90     	; 0x2dcc <_ZN14HardwareSerial5writeEh+0x62>
		    // Buffer empty, so disable interrupts
		    cbi(*_ucsrb, UDRIE0);
    2e26:	a2 89       	ldd	r26, Z+18	; 0x12
    2e28:	b3 89       	ldd	r27, Z+19	; 0x13
    2e2a:	8c 91       	ld	r24, X
    2e2c:	8f 7d       	andi	r24, 0xDF	; 223
    2e2e:	8c 93       	st	X, r24
    2e30:	cd cf       	rjmp	.-102    	; 0x2dcc <_ZN14HardwareSerial5writeEh+0x62>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
    2e32:	83 8d       	ldd	r24, Z+27	; 0x1b
    2e34:	df 01       	movw	r26, r30
    2e36:	a8 0f       	add	r26, r24
    2e38:	b1 1d       	adc	r27, r1
    2e3a:	9d 96       	adiw	r26, 0x2d	; 45
    2e3c:	6c 93       	st	X, r22

  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    2e3e:	2f b7       	in	r18, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    2e40:	f8 94       	cli
    2e42:	81 e0       	ldi	r24, 0x01	; 1
    2e44:	88 23       	and	r24, r24
    2e46:	41 f0       	breq	.+16     	; 0x2e58 <_ZN14HardwareSerial5writeEh+0xee>
    _tx_buffer_head = i;
    2e48:	93 8f       	std	Z+27, r25	; 0x1b
    sbi(*_ucsrb, UDRIE0);
    2e4a:	a2 89       	ldd	r26, Z+18	; 0x12
    2e4c:	b3 89       	ldd	r27, Z+19	; 0x13
    2e4e:	8c 91       	ld	r24, X
    2e50:	80 62       	ori	r24, 0x20	; 32
    2e52:	8c 93       	st	X, r24
  _tx_buffer[_tx_buffer_head] = c;

  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    2e54:	80 e0       	ldi	r24, 0x00	; 0
    2e56:	f6 cf       	rjmp	.-20     	; 0x2e44 <_ZN14HardwareSerial5writeEh+0xda>
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    2e58:	2f bf       	out	0x3f, r18	; 63
    _tx_buffer_head = i;
    sbi(*_ucsrb, UDRIE0);
  }
  
  return 1;
}
    2e5a:	81 e0       	ldi	r24, 0x01	; 1
    2e5c:	90 e0       	ldi	r25, 0x00	; 0
    2e5e:	08 95       	ret

00002e60 <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
    2e60:	cf 93       	push	r28
    2e62:	df 93       	push	r29
    2e64:	dc 01       	movw	r26, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
    2e66:	58 96       	adiw	r26, 0x18	; 24
    2e68:	8c 91       	ld	r24, X
    2e6a:	58 97       	sbiw	r26, 0x18	; 24
    2e6c:	88 23       	and	r24, r24
    2e6e:	09 f4       	brne	.+2      	; 0x2e72 <_ZN14HardwareSerial5flushEv+0x12>
    2e70:	5f c0       	rjmp	.+190    	; 0x2f30 <_ZN14HardwareSerial5flushEv+0xd0>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    2e72:	52 96       	adiw	r26, 0x12	; 18
    2e74:	ed 91       	ld	r30, X+
    2e76:	fc 91       	ld	r31, X
    2e78:	53 97       	sbiw	r26, 0x13	; 19
    2e7a:	90 81       	ld	r25, Z
    2e7c:	95 fd       	sbrc	r25, 5
    2e7e:	09 c0       	rjmp	.+18     	; 0x2e92 <_ZN14HardwareSerial5flushEv+0x32>
    2e80:	50 96       	adiw	r26, 0x10	; 16
    2e82:	cd 91       	ld	r28, X+
    2e84:	dc 91       	ld	r29, X
    2e86:	51 97       	sbiw	r26, 0x11	; 17
    2e88:	98 81       	ld	r25, Y
    2e8a:	96 fd       	sbrc	r25, 6
    2e8c:	04 c0       	rjmp	.+8      	; 0x2e96 <_ZN14HardwareSerial5flushEv+0x36>
    2e8e:	98 2f       	mov	r25, r24
    2e90:	03 c0       	rjmp	.+6      	; 0x2e98 <_ZN14HardwareSerial5flushEv+0x38>
    2e92:	98 2f       	mov	r25, r24
    2e94:	01 c0       	rjmp	.+2      	; 0x2e98 <_ZN14HardwareSerial5flushEv+0x38>
    2e96:	90 e0       	ldi	r25, 0x00	; 0
    2e98:	99 23       	and	r25, r25
    2e9a:	09 f4       	brne	.+2      	; 0x2e9e <_ZN14HardwareSerial5flushEv+0x3e>
    2e9c:	49 c0       	rjmp	.+146    	; 0x2f30 <_ZN14HardwareSerial5flushEv+0xd0>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
    2e9e:	0f b6       	in	r0, 0x3f	; 63
    2ea0:	07 fc       	sbrc	r0, 7
    2ea2:	05 c0       	rjmp	.+10     	; 0x2eae <_ZN14HardwareSerial5flushEv+0x4e>
    2ea4:	20 81       	ld	r18, Z
    2ea6:	25 fd       	sbrc	r18, 5
    2ea8:	03 c0       	rjmp	.+6      	; 0x2eb0 <_ZN14HardwareSerial5flushEv+0x50>
    2eaa:	90 e0       	ldi	r25, 0x00	; 0
    2eac:	01 c0       	rjmp	.+2      	; 0x2eb0 <_ZN14HardwareSerial5flushEv+0x50>
    2eae:	90 e0       	ldi	r25, 0x00	; 0
    2eb0:	99 23       	and	r25, r25
    2eb2:	f9 f2       	breq	.-66     	; 0x2e72 <_ZN14HardwareSerial5flushEv+0x12>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
    2eb4:	50 96       	adiw	r26, 0x10	; 16
    2eb6:	ed 91       	ld	r30, X+
    2eb8:	fc 91       	ld	r31, X
    2eba:	51 97       	sbiw	r26, 0x11	; 17
    2ebc:	90 81       	ld	r25, Z
    2ebe:	95 ff       	sbrs	r25, 5
    2ec0:	d8 cf       	rjmp	.-80     	; 0x2e72 <_ZN14HardwareSerial5flushEv+0x12>
	    };
    }
    inline void _tx_udr_empty_irq(void){
	    // If interrupts are enabled, there must be more data in the output
	    // buffer. Send the next byte
	    unsigned char c = _tx_buffer[_tx_buffer_tail];
    2ec2:	5c 96       	adiw	r26, 0x1c	; 28
    2ec4:	9c 91       	ld	r25, X
    2ec6:	5c 97       	sbiw	r26, 0x1c	; 28
    2ec8:	fd 01       	movw	r30, r26
    2eca:	e9 0f       	add	r30, r25
    2ecc:	f1 1d       	adc	r31, r1
    2ece:	95 a5       	ldd	r25, Z+45	; 0x2d
	    _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
    2ed0:	5c 96       	adiw	r26, 0x1c	; 28
    2ed2:	2c 91       	ld	r18, X
    2ed4:	5c 97       	sbiw	r26, 0x1c	; 28
    2ed6:	30 e0       	ldi	r19, 0x00	; 0
    2ed8:	2f 5f       	subi	r18, 0xFF	; 255
    2eda:	3f 4f       	sbci	r19, 0xFF	; 255
    2edc:	2f 70       	andi	r18, 0x0F	; 15
    2ede:	30 78       	andi	r19, 0x80	; 128
    2ee0:	33 23       	and	r19, r19
    2ee2:	34 f4       	brge	.+12     	; 0x2ef0 <_ZN14HardwareSerial5flushEv+0x90>
    2ee4:	21 50       	subi	r18, 0x01	; 1
    2ee6:	31 09       	sbc	r19, r1
    2ee8:	20 6f       	ori	r18, 0xF0	; 240
    2eea:	3f 6f       	ori	r19, 0xFF	; 255
    2eec:	2f 5f       	subi	r18, 0xFF	; 255
    2eee:	3f 4f       	sbci	r19, 0xFF	; 255
    2ef0:	5c 96       	adiw	r26, 0x1c	; 28
    2ef2:	2c 93       	st	X, r18
    2ef4:	5c 97       	sbiw	r26, 0x1c	; 28

	    *_udr = c;
    2ef6:	56 96       	adiw	r26, 0x16	; 22
    2ef8:	ed 91       	ld	r30, X+
    2efa:	fc 91       	ld	r31, X
    2efc:	57 97       	sbiw	r26, 0x17	; 23
    2efe:	90 83       	st	Z, r25
	    // location". This makes sure flush() won't return until the bytes
	    // actually got written. Other r/w bits are preserved, and zeroes
	    // written to the rest.

	    #ifdef MPCM0
	    *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
    2f00:	50 96       	adiw	r26, 0x10	; 16
    2f02:	ed 91       	ld	r30, X+
    2f04:	fc 91       	ld	r31, X
    2f06:	51 97       	sbiw	r26, 0x11	; 17
    2f08:	90 81       	ld	r25, Z
    2f0a:	93 70       	andi	r25, 0x03	; 3
    2f0c:	90 64       	ori	r25, 0x40	; 64
    2f0e:	90 83       	st	Z, r25
	    #else
	    *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
	    #endif

	    if (_tx_buffer_head == _tx_buffer_tail) {
    2f10:	5b 96       	adiw	r26, 0x1b	; 27
    2f12:	2c 91       	ld	r18, X
    2f14:	5b 97       	sbiw	r26, 0x1b	; 27
    2f16:	5c 96       	adiw	r26, 0x1c	; 28
    2f18:	9c 91       	ld	r25, X
    2f1a:	5c 97       	sbiw	r26, 0x1c	; 28
    2f1c:	29 13       	cpse	r18, r25
    2f1e:	a9 cf       	rjmp	.-174    	; 0x2e72 <_ZN14HardwareSerial5flushEv+0x12>
		    // Buffer empty, so disable interrupts
		    cbi(*_ucsrb, UDRIE0);
    2f20:	52 96       	adiw	r26, 0x12	; 18
    2f22:	ed 91       	ld	r30, X+
    2f24:	fc 91       	ld	r31, X
    2f26:	53 97       	sbiw	r26, 0x13	; 19
    2f28:	90 81       	ld	r25, Z
    2f2a:	9f 7d       	andi	r25, 0xDF	; 223
    2f2c:	90 83       	st	Z, r25
    2f2e:	a1 cf       	rjmp	.-190    	; 0x2e72 <_ZN14HardwareSerial5flushEv+0x12>
	  _tx_udr_empty_irq();
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished transmission (TXC is set).
}
    2f30:	df 91       	pop	r29
    2f32:	cf 91       	pop	r28
    2f34:	08 95       	ret

00002f36 <_Z41__static_initialization_and_destruction_0ii>:

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
}
    2f36:	01 97       	sbiw	r24, 0x01	; 1
    2f38:	d9 f5       	brne	.+118    	; 0x2fb0 <_Z41__static_initialization_and_destruction_0ii+0x7a>
    2f3a:	6f 3f       	cpi	r22, 0xFF	; 255
    2f3c:	7f 4f       	sbci	r23, 0xFF	; 255
    2f3e:	c1 f5       	brne	.+112    	; 0x2fb0 <_Z41__static_initialization_and_destruction_0ii+0x7a>
    2f40:	e0 e8       	ldi	r30, 0x80	; 128
    2f42:	f8 e0       	ldi	r31, 0x08	; 8
    2f44:	13 82       	std	Z+3, r1	; 0x03
    2f46:	12 82       	std	Z+2, r1	; 0x02
    2f48:	88 ee       	ldi	r24, 0xE8	; 232
    2f4a:	93 e0       	ldi	r25, 0x03	; 3
    2f4c:	a0 e0       	ldi	r26, 0x00	; 0
    2f4e:	b0 e0       	ldi	r27, 0x00	; 0
    2f50:	84 83       	std	Z+4, r24	; 0x04
    2f52:	95 83       	std	Z+5, r25	; 0x05
    2f54:	a6 83       	std	Z+6, r26	; 0x06
    2f56:	b7 83       	std	Z+7, r27	; 0x07
    2f58:	81 ec       	ldi	r24, 0xC1	; 193
    2f5a:	91 e0       	ldi	r25, 0x01	; 1
    2f5c:	91 83       	std	Z+1, r25	; 0x01
    2f5e:	80 83       	st	Z, r24
    2f60:	85 ec       	ldi	r24, 0xC5	; 197
    2f62:	90 e0       	ldi	r25, 0x00	; 0
    2f64:	95 87       	std	Z+13, r25	; 0x0d
    2f66:	84 87       	std	Z+12, r24	; 0x0c
    2f68:	84 ec       	ldi	r24, 0xC4	; 196
    2f6a:	90 e0       	ldi	r25, 0x00	; 0
    2f6c:	97 87       	std	Z+15, r25	; 0x0f
    2f6e:	86 87       	std	Z+14, r24	; 0x0e
    2f70:	80 ec       	ldi	r24, 0xC0	; 192
    2f72:	90 e0       	ldi	r25, 0x00	; 0
    2f74:	91 8b       	std	Z+17, r25	; 0x11
    2f76:	80 8b       	std	Z+16, r24	; 0x10
    2f78:	81 ec       	ldi	r24, 0xC1	; 193
    2f7a:	90 e0       	ldi	r25, 0x00	; 0
    2f7c:	93 8b       	std	Z+19, r25	; 0x13
    2f7e:	82 8b       	std	Z+18, r24	; 0x12
    2f80:	82 ec       	ldi	r24, 0xC2	; 194
    2f82:	90 e0       	ldi	r25, 0x00	; 0
    2f84:	95 8b       	std	Z+21, r25	; 0x15
    2f86:	84 8b       	std	Z+20, r24	; 0x14
    2f88:	86 ec       	ldi	r24, 0xC6	; 198
    2f8a:	90 e0       	ldi	r25, 0x00	; 0
    2f8c:	97 8b       	std	Z+23, r25	; 0x17
    2f8e:	86 8b       	std	Z+22, r24	; 0x16
    2f90:	11 8e       	std	Z+25, r1	; 0x19
    2f92:	12 8e       	std	Z+26, r1	; 0x1a
    2f94:	13 8e       	std	Z+27, r1	; 0x1b
    2f96:	14 8e       	std	Z+28, r1	; 0x1c
    2f98:	80 e0       	ldi	r24, 0x00	; 0
    2f9a:	94 e2       	ldi	r25, 0x24	; 36
    2f9c:	a4 ef       	ldi	r26, 0xF4	; 244
    2f9e:	b0 e0       	ldi	r27, 0x00	; 0
    2fa0:	80 93 bd 08 	sts	0x08BD, r24	; 0x8008bd <Serial+0x3d>
    2fa4:	90 93 be 08 	sts	0x08BE, r25	; 0x8008be <Serial+0x3e>
    2fa8:	a0 93 bf 08 	sts	0x08BF, r26	; 0x8008bf <Serial+0x3f>
    2fac:	b0 93 c0 08 	sts	0x08C0, r27	; 0x8008c0 <Serial+0x40>
    2fb0:	08 95       	ret

00002fb2 <__vector_18>:
    2fb2:	1f 92       	push	r1
    2fb4:	0f 92       	push	r0
    2fb6:	0f b6       	in	r0, 0x3f	; 63
    2fb8:	0f 92       	push	r0
    2fba:	11 24       	eor	r1, r1
    2fbc:	2f 93       	push	r18
    2fbe:	8f 93       	push	r24
    2fc0:	9f 93       	push	r25
    2fc2:	af 93       	push	r26
    2fc4:	bf 93       	push	r27
    2fc6:	ef 93       	push	r30
    2fc8:	ff 93       	push	r31
    2fca:	e0 91 90 08 	lds	r30, 0x0890	; 0x800890 <Serial+0x10>
    2fce:	f0 91 91 08 	lds	r31, 0x0891	; 0x800891 <Serial+0x11>
    2fd2:	80 81       	ld	r24, Z
    2fd4:	82 fd       	sbrc	r24, 2
    2fd6:	14 c0       	rjmp	.+40     	; 0x3000 <__vector_18+0x4e>
    2fd8:	e0 e8       	ldi	r30, 0x80	; 128
    2fda:	f8 e0       	ldi	r31, 0x08	; 8
    2fdc:	a6 89       	ldd	r26, Z+22	; 0x16
    2fde:	b7 89       	ldd	r27, Z+23	; 0x17
    2fe0:	2c 91       	ld	r18, X
    2fe2:	81 8d       	ldd	r24, Z+25	; 0x19
    2fe4:	8f 5f       	subi	r24, 0xFF	; 255
    2fe6:	8f 70       	andi	r24, 0x0F	; 15
    2fe8:	92 8d       	ldd	r25, Z+26	; 0x1a
    2fea:	89 17       	cp	r24, r25
    2fec:	71 f0       	breq	.+28     	; 0x300a <__vector_18+0x58>
    2fee:	df 01       	movw	r26, r30
    2ff0:	e1 8d       	ldd	r30, Z+25	; 0x19
    2ff2:	f0 e0       	ldi	r31, 0x00	; 0
    2ff4:	e0 58       	subi	r30, 0x80	; 128
    2ff6:	f7 4f       	sbci	r31, 0xF7	; 247
    2ff8:	25 8f       	std	Z+29, r18	; 0x1d
    2ffa:	59 96       	adiw	r26, 0x19	; 25
    2ffc:	8c 93       	st	X, r24
    2ffe:	05 c0       	rjmp	.+10     	; 0x300a <__vector_18+0x58>
    3000:	e0 91 96 08 	lds	r30, 0x0896	; 0x800896 <Serial+0x16>
    3004:	f0 91 97 08 	lds	r31, 0x0897	; 0x800897 <Serial+0x17>
    3008:	80 81       	ld	r24, Z
    300a:	ff 91       	pop	r31
    300c:	ef 91       	pop	r30
    300e:	bf 91       	pop	r27
    3010:	af 91       	pop	r26
    3012:	9f 91       	pop	r25
    3014:	8f 91       	pop	r24
    3016:	2f 91       	pop	r18
    3018:	0f 90       	pop	r0
    301a:	0f be       	out	0x3f, r0	; 63
    301c:	0f 90       	pop	r0
    301e:	1f 90       	pop	r1
    3020:	18 95       	reti

00003022 <__vector_19>:
    3022:	1f 92       	push	r1
    3024:	0f 92       	push	r0
    3026:	0f b6       	in	r0, 0x3f	; 63
    3028:	0f 92       	push	r0
    302a:	11 24       	eor	r1, r1
    302c:	2f 93       	push	r18
    302e:	8f 93       	push	r24
    3030:	9f 93       	push	r25
    3032:	af 93       	push	r26
    3034:	bf 93       	push	r27
    3036:	ef 93       	push	r30
    3038:	ff 93       	push	r31
    303a:	a0 e8       	ldi	r26, 0x80	; 128
    303c:	b8 e0       	ldi	r27, 0x08	; 8
    303e:	5c 96       	adiw	r26, 0x1c	; 28
    3040:	ec 91       	ld	r30, X
    3042:	5c 97       	sbiw	r26, 0x1c	; 28
    3044:	f0 e0       	ldi	r31, 0x00	; 0
    3046:	e0 58       	subi	r30, 0x80	; 128
    3048:	f7 4f       	sbci	r31, 0xF7	; 247
    304a:	25 a5       	ldd	r18, Z+45	; 0x2d
    304c:	5c 96       	adiw	r26, 0x1c	; 28
    304e:	8c 91       	ld	r24, X
    3050:	90 e0       	ldi	r25, 0x00	; 0
    3052:	01 96       	adiw	r24, 0x01	; 1
    3054:	8f 70       	andi	r24, 0x0F	; 15
    3056:	90 78       	andi	r25, 0x80	; 128
    3058:	99 23       	and	r25, r25
    305a:	24 f4       	brge	.+8      	; 0x3064 <__vector_19+0x42>
    305c:	01 97       	sbiw	r24, 0x01	; 1
    305e:	80 6f       	ori	r24, 0xF0	; 240
    3060:	9f 6f       	ori	r25, 0xFF	; 255
    3062:	01 96       	adiw	r24, 0x01	; 1
    3064:	e0 e8       	ldi	r30, 0x80	; 128
    3066:	f8 e0       	ldi	r31, 0x08	; 8
    3068:	84 8f       	std	Z+28, r24	; 0x1c
    306a:	a6 89       	ldd	r26, Z+22	; 0x16
    306c:	b7 89       	ldd	r27, Z+23	; 0x17
    306e:	2c 93       	st	X, r18
    3070:	a0 89       	ldd	r26, Z+16	; 0x10
    3072:	b1 89       	ldd	r27, Z+17	; 0x11
    3074:	8c 91       	ld	r24, X
    3076:	83 70       	andi	r24, 0x03	; 3
    3078:	80 64       	ori	r24, 0x40	; 64
    307a:	8c 93       	st	X, r24
    307c:	93 8d       	ldd	r25, Z+27	; 0x1b
    307e:	84 8d       	ldd	r24, Z+28	; 0x1c
    3080:	98 13       	cpse	r25, r24
    3082:	07 c0       	rjmp	.+14     	; 0x3092 <__vector_19+0x70>
    3084:	e0 91 92 08 	lds	r30, 0x0892	; 0x800892 <Serial+0x12>
    3088:	f0 91 93 08 	lds	r31, 0x0893	; 0x800893 <Serial+0x13>
    308c:	80 81       	ld	r24, Z
    308e:	8f 7d       	andi	r24, 0xDF	; 223
    3090:	80 83       	st	Z, r24
    3092:	ff 91       	pop	r31
    3094:	ef 91       	pop	r30
    3096:	bf 91       	pop	r27
    3098:	af 91       	pop	r26
    309a:	9f 91       	pop	r25
    309c:	8f 91       	pop	r24
    309e:	2f 91       	pop	r18
    30a0:	0f 90       	pop	r0
    30a2:	0f be       	out	0x3f, r0	; 63
    30a4:	0f 90       	pop	r0
    30a6:	1f 90       	pop	r1
    30a8:	18 95       	reti

000030aa <_GLOBAL__sub_I___vector_18>:
    30aa:	6f ef       	ldi	r22, 0xFF	; 255
    30ac:	7f ef       	ldi	r23, 0xFF	; 255
    30ae:	81 e0       	ldi	r24, 0x01	; 1
    30b0:	90 e0       	ldi	r25, 0x00	; 0
    30b2:	0e 94 9b 17 	call	0x2f36	; 0x2f36 <_Z41__static_initialization_and_destruction_0ii>
    30b6:	08 95       	ret

000030b8 <_ZN5Print5writeEPKhj>:
size_t Print::println(unsigned int num, int base)
{
  size_t n = print(num, base);
  n += println();
  return n;
}
    30b8:	cf 92       	push	r12
    30ba:	df 92       	push	r13
    30bc:	ef 92       	push	r14
    30be:	ff 92       	push	r15
    30c0:	0f 93       	push	r16
    30c2:	1f 93       	push	r17
    30c4:	cf 93       	push	r28
    30c6:	df 93       	push	r29
    30c8:	8c 01       	movw	r16, r24
    30ca:	db 01       	movw	r26, r22
    30cc:	c0 e0       	ldi	r28, 0x00	; 0
    30ce:	d0 e0       	ldi	r29, 0x00	; 0
    30d0:	7a 01       	movw	r14, r20
    30d2:	81 e0       	ldi	r24, 0x01	; 1
    30d4:	e8 1a       	sub	r14, r24
    30d6:	f1 08       	sbc	r15, r1
    30d8:	45 2b       	or	r20, r21
    30da:	a1 f0       	breq	.+40     	; 0x3104 <_ZN5Print5writeEPKhj+0x4c>
    30dc:	f8 01       	movw	r30, r16
    30de:	80 81       	ld	r24, Z
    30e0:	91 81       	ldd	r25, Z+1	; 0x01
    30e2:	fc 01       	movw	r30, r24
    30e4:	20 81       	ld	r18, Z
    30e6:	31 81       	ldd	r19, Z+1	; 0x01
    30e8:	6d 01       	movw	r12, r26
    30ea:	ff ef       	ldi	r31, 0xFF	; 255
    30ec:	cf 1a       	sub	r12, r31
    30ee:	df 0a       	sbc	r13, r31
    30f0:	6c 91       	ld	r22, X
    30f2:	c8 01       	movw	r24, r16
    30f4:	f9 01       	movw	r30, r18
    30f6:	09 95       	icall
    30f8:	89 2b       	or	r24, r25
    30fa:	21 f0       	breq	.+8      	; 0x3104 <_ZN5Print5writeEPKhj+0x4c>
    30fc:	21 96       	adiw	r28, 0x01	; 1
    30fe:	a7 01       	movw	r20, r14
    3100:	d6 01       	movw	r26, r12
    3102:	e6 cf       	rjmp	.-52     	; 0x30d0 <_ZN5Print5writeEPKhj+0x18>
    3104:	ce 01       	movw	r24, r28
    3106:	df 91       	pop	r29
    3108:	cf 91       	pop	r28
    310a:	1f 91       	pop	r17
    310c:	0f 91       	pop	r16
    310e:	ff 90       	pop	r15
    3110:	ef 90       	pop	r14
    3112:	df 90       	pop	r13
    3114:	cf 90       	pop	r12
    3116:	08 95       	ret

00003118 <_ZN5Print5printEPKc>:
    3118:	61 15       	cp	r22, r1
    311a:	71 05       	cpc	r23, r1
    311c:	81 f0       	breq	.+32     	; 0x313e <_ZN5Print5printEPKc+0x26>
    311e:	fb 01       	movw	r30, r22
    3120:	01 90       	ld	r0, Z+
    3122:	00 20       	and	r0, r0
    3124:	e9 f7       	brne	.-6      	; 0x3120 <_ZN5Print5printEPKc+0x8>
    3126:	31 97       	sbiw	r30, 0x01	; 1
    3128:	af 01       	movw	r20, r30
    312a:	46 1b       	sub	r20, r22
    312c:	57 0b       	sbc	r21, r23
    312e:	dc 01       	movw	r26, r24
    3130:	ed 91       	ld	r30, X+
    3132:	fc 91       	ld	r31, X
    3134:	02 80       	ldd	r0, Z+2	; 0x02
    3136:	f3 81       	ldd	r31, Z+3	; 0x03
    3138:	e0 2d       	mov	r30, r0
    313a:	09 95       	icall
    313c:	08 95       	ret
    313e:	80 e0       	ldi	r24, 0x00	; 0
    3140:	90 e0       	ldi	r25, 0x00	; 0
    3142:	08 95       	ret

00003144 <_ZN5Print5printEc>:
    3144:	dc 01       	movw	r26, r24
    3146:	ed 91       	ld	r30, X+
    3148:	fc 91       	ld	r31, X
    314a:	01 90       	ld	r0, Z+
    314c:	f0 81       	ld	r31, Z
    314e:	e0 2d       	mov	r30, r0
    3150:	09 95       	icall
    3152:	08 95       	ret

00003154 <_ZN5Print7printlnEv>:
    3154:	dc 01       	movw	r26, r24
    3156:	ed 91       	ld	r30, X+
    3158:	fc 91       	ld	r31, X
    315a:	02 80       	ldd	r0, Z+2	; 0x02
    315c:	f3 81       	ldd	r31, Z+3	; 0x03
    315e:	e0 2d       	mov	r30, r0
    3160:	42 e0       	ldi	r20, 0x02	; 2
    3162:	50 e0       	ldi	r21, 0x00	; 0
    3164:	6f ec       	ldi	r22, 0xCF	; 207
    3166:	71 e0       	ldi	r23, 0x01	; 1
    3168:	09 95       	icall
    316a:	08 95       	ret

0000316c <_ZN5Print7printlnEPKc>:
    316c:	0f 93       	push	r16
    316e:	1f 93       	push	r17
    3170:	cf 93       	push	r28
    3172:	df 93       	push	r29
    3174:	ec 01       	movw	r28, r24
    3176:	0e 94 8c 18 	call	0x3118	; 0x3118 <_ZN5Print5printEPKc>
    317a:	8c 01       	movw	r16, r24
    317c:	ce 01       	movw	r24, r28
    317e:	0e 94 aa 18 	call	0x3154	; 0x3154 <_ZN5Print7printlnEv>
    3182:	80 0f       	add	r24, r16
    3184:	91 1f       	adc	r25, r17
    3186:	df 91       	pop	r29
    3188:	cf 91       	pop	r28
    318a:	1f 91       	pop	r17
    318c:	0f 91       	pop	r16
    318e:	08 95       	ret

00003190 <_ZN5Print11printNumberEmh>:
    3190:	8f 92       	push	r8
    3192:	9f 92       	push	r9
    3194:	af 92       	push	r10
    3196:	bf 92       	push	r11
    3198:	df 92       	push	r13
    319a:	ef 92       	push	r14
    319c:	ff 92       	push	r15
    319e:	0f 93       	push	r16
    31a0:	1f 93       	push	r17
    31a2:	cf 93       	push	r28
    31a4:	df 93       	push	r29
    31a6:	cd b7       	in	r28, 0x3d	; 61
    31a8:	de b7       	in	r29, 0x3e	; 62
    31aa:	a1 97       	sbiw	r28, 0x21	; 33
    31ac:	0f b6       	in	r0, 0x3f	; 63
    31ae:	f8 94       	cli
    31b0:	de bf       	out	0x3e, r29	; 62
    31b2:	0f be       	out	0x3f, r0	; 63
    31b4:	cd bf       	out	0x3d, r28	; 61
    31b6:	7c 01       	movw	r14, r24
    31b8:	cb 01       	movw	r24, r22
    31ba:	ba 01       	movw	r22, r20
    31bc:	d2 2e       	mov	r13, r18
    31be:	19 a2       	std	Y+33, r1	; 0x21
    31c0:	21 e0       	ldi	r18, 0x01	; 1
    31c2:	2d 15       	cp	r18, r13
    31c4:	20 f0       	brcs	.+8      	; 0x31ce <_ZN5Print11printNumberEmh+0x3e>
    31c6:	0f 2e       	mov	r0, r31
    31c8:	fa e0       	ldi	r31, 0x0A	; 10
    31ca:	df 2e       	mov	r13, r31
    31cc:	f0 2d       	mov	r31, r0
    31ce:	8e 01       	movw	r16, r28
    31d0:	0f 5d       	subi	r16, 0xDF	; 223
    31d2:	1f 4f       	sbci	r17, 0xFF	; 255
    31d4:	8d 2c       	mov	r8, r13
    31d6:	91 2c       	mov	r9, r1
    31d8:	a1 2c       	mov	r10, r1
    31da:	b1 2c       	mov	r11, r1
    31dc:	a5 01       	movw	r20, r10
    31de:	94 01       	movw	r18, r8
    31e0:	0e 94 52 1c 	call	0x38a4	; 0x38a4 <__udivmodsi4>
    31e4:	e6 2f       	mov	r30, r22
    31e6:	62 2f       	mov	r22, r18
    31e8:	73 2f       	mov	r23, r19
    31ea:	84 2f       	mov	r24, r20
    31ec:	95 2f       	mov	r25, r21
    31ee:	01 50       	subi	r16, 0x01	; 1
    31f0:	11 09       	sbc	r17, r1
    31f2:	ea 30       	cpi	r30, 0x0A	; 10
    31f4:	10 f4       	brcc	.+4      	; 0x31fa <_ZN5Print11printNumberEmh+0x6a>
    31f6:	e0 5d       	subi	r30, 0xD0	; 208
    31f8:	01 c0       	rjmp	.+2      	; 0x31fc <_ZN5Print11printNumberEmh+0x6c>
    31fa:	e9 5c       	subi	r30, 0xC9	; 201
    31fc:	d8 01       	movw	r26, r16
    31fe:	ec 93       	st	X, r30
    3200:	61 15       	cp	r22, r1
    3202:	71 05       	cpc	r23, r1
    3204:	81 05       	cpc	r24, r1
    3206:	91 05       	cpc	r25, r1
    3208:	29 f7       	brne	.-54     	; 0x31d4 <_ZN5Print11printNumberEmh+0x44>
    320a:	01 15       	cp	r16, r1
    320c:	11 05       	cpc	r17, r1
    320e:	91 f0       	breq	.+36     	; 0x3234 <_ZN5Print11printNumberEmh+0xa4>
    3210:	f8 01       	movw	r30, r16
    3212:	01 90       	ld	r0, Z+
    3214:	00 20       	and	r0, r0
    3216:	e9 f7       	brne	.-6      	; 0x3212 <_ZN5Print11printNumberEmh+0x82>
    3218:	31 97       	sbiw	r30, 0x01	; 1
    321a:	af 01       	movw	r20, r30
    321c:	40 1b       	sub	r20, r16
    321e:	51 0b       	sbc	r21, r17
    3220:	d7 01       	movw	r26, r14
    3222:	ed 91       	ld	r30, X+
    3224:	fc 91       	ld	r31, X
    3226:	02 80       	ldd	r0, Z+2	; 0x02
    3228:	f3 81       	ldd	r31, Z+3	; 0x03
    322a:	e0 2d       	mov	r30, r0
    322c:	b8 01       	movw	r22, r16
    322e:	c7 01       	movw	r24, r14
    3230:	09 95       	icall
    3232:	02 c0       	rjmp	.+4      	; 0x3238 <_ZN5Print11printNumberEmh+0xa8>
    3234:	80 e0       	ldi	r24, 0x00	; 0
    3236:	90 e0       	ldi	r25, 0x00	; 0
    3238:	a1 96       	adiw	r28, 0x21	; 33
    323a:	0f b6       	in	r0, 0x3f	; 63
    323c:	f8 94       	cli
    323e:	de bf       	out	0x3e, r29	; 62
    3240:	0f be       	out	0x3f, r0	; 63
    3242:	cd bf       	out	0x3d, r28	; 61
    3244:	df 91       	pop	r29
    3246:	cf 91       	pop	r28
    3248:	1f 91       	pop	r17
    324a:	0f 91       	pop	r16
    324c:	ff 90       	pop	r15
    324e:	ef 90       	pop	r14
    3250:	df 90       	pop	r13
    3252:	bf 90       	pop	r11
    3254:	af 90       	pop	r10
    3256:	9f 90       	pop	r9
    3258:	8f 90       	pop	r8
    325a:	08 95       	ret

0000325c <_ZN5Print5printEli>:
    325c:	cf 92       	push	r12
    325e:	df 92       	push	r13
    3260:	ef 92       	push	r14
    3262:	ff 92       	push	r15
    3264:	0f 93       	push	r16
    3266:	1f 93       	push	r17
    3268:	cf 93       	push	r28
    326a:	df 93       	push	r29
    326c:	ec 01       	movw	r28, r24
    326e:	6a 01       	movw	r12, r20
    3270:	7b 01       	movw	r14, r22
    3272:	21 15       	cp	r18, r1
    3274:	31 05       	cpc	r19, r1
    3276:	41 f4       	brne	.+16     	; 0x3288 <_ZN5Print5printEli+0x2c>
    3278:	e8 81       	ld	r30, Y
    327a:	f9 81       	ldd	r31, Y+1	; 0x01
    327c:	01 90       	ld	r0, Z+
    327e:	f0 81       	ld	r31, Z
    3280:	e0 2d       	mov	r30, r0
    3282:	64 2f       	mov	r22, r20
    3284:	09 95       	icall
    3286:	1d c0       	rjmp	.+58     	; 0x32c2 <_ZN5Print5printEli+0x66>
    3288:	2a 30       	cpi	r18, 0x0A	; 10
    328a:	31 05       	cpc	r19, r1
    328c:	c1 f4       	brne	.+48     	; 0x32be <_ZN5Print5printEli+0x62>
    328e:	77 23       	and	r23, r23
    3290:	94 f4       	brge	.+36     	; 0x32b6 <_ZN5Print5printEli+0x5a>
    3292:	6d e2       	ldi	r22, 0x2D	; 45
    3294:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN5Print5printEc>
    3298:	8c 01       	movw	r16, r24
    329a:	44 27       	eor	r20, r20
    329c:	55 27       	eor	r21, r21
    329e:	ba 01       	movw	r22, r20
    32a0:	4c 19       	sub	r20, r12
    32a2:	5d 09       	sbc	r21, r13
    32a4:	6e 09       	sbc	r22, r14
    32a6:	7f 09       	sbc	r23, r15
    32a8:	2a e0       	ldi	r18, 0x0A	; 10
    32aa:	ce 01       	movw	r24, r28
    32ac:	0e 94 c8 18 	call	0x3190	; 0x3190 <_ZN5Print11printNumberEmh>
    32b0:	80 0f       	add	r24, r16
    32b2:	91 1f       	adc	r25, r17
    32b4:	06 c0       	rjmp	.+12     	; 0x32c2 <_ZN5Print5printEli+0x66>
    32b6:	2a e0       	ldi	r18, 0x0A	; 10
    32b8:	0e 94 c8 18 	call	0x3190	; 0x3190 <_ZN5Print11printNumberEmh>
    32bc:	02 c0       	rjmp	.+4      	; 0x32c2 <_ZN5Print5printEli+0x66>
    32be:	0e 94 c8 18 	call	0x3190	; 0x3190 <_ZN5Print11printNumberEmh>
    32c2:	df 91       	pop	r29
    32c4:	cf 91       	pop	r28
    32c6:	1f 91       	pop	r17
    32c8:	0f 91       	pop	r16
    32ca:	ff 90       	pop	r15
    32cc:	ef 90       	pop	r14
    32ce:	df 90       	pop	r13
    32d0:	cf 90       	pop	r12
    32d2:	08 95       	ret

000032d4 <_ZN5Print5printEii>:
    32d4:	9a 01       	movw	r18, r20
    32d6:	ab 01       	movw	r20, r22
    32d8:	77 0f       	add	r23, r23
    32da:	66 0b       	sbc	r22, r22
    32dc:	77 0b       	sbc	r23, r23
    32de:	0e 94 2e 19 	call	0x325c	; 0x325c <_ZN5Print5printEli>
    32e2:	08 95       	ret

000032e4 <_ZN5Print5printEmi>:
    32e4:	21 15       	cp	r18, r1
    32e6:	31 05       	cpc	r19, r1
    32e8:	49 f4       	brne	.+18     	; 0x32fc <_ZN5Print5printEmi+0x18>
    32ea:	dc 01       	movw	r26, r24
    32ec:	ed 91       	ld	r30, X+
    32ee:	fc 91       	ld	r31, X
    32f0:	01 90       	ld	r0, Z+
    32f2:	f0 81       	ld	r31, Z
    32f4:	e0 2d       	mov	r30, r0
    32f6:	64 2f       	mov	r22, r20
    32f8:	09 95       	icall
    32fa:	08 95       	ret
    32fc:	0e 94 c8 18 	call	0x3190	; 0x3190 <_ZN5Print11printNumberEmh>
    3300:	08 95       	ret

00003302 <_ZN5Print5printEji>:
    3302:	9a 01       	movw	r18, r20
    3304:	ab 01       	movw	r20, r22
    3306:	60 e0       	ldi	r22, 0x00	; 0
    3308:	70 e0       	ldi	r23, 0x00	; 0
    330a:	0e 94 72 19 	call	0x32e4	; 0x32e4 <_ZN5Print5printEmi>
    330e:	08 95       	ret

00003310 <_ZN5Print7printlnEmi>:
  n += println();
  return n;
}

size_t Print::println(unsigned long num, int base)
{
    3310:	0f 93       	push	r16
    3312:	1f 93       	push	r17
    3314:	cf 93       	push	r28
    3316:	df 93       	push	r29
    3318:	ec 01       	movw	r28, r24
  size_t n = print(num, base);
    331a:	0e 94 72 19 	call	0x32e4	; 0x32e4 <_ZN5Print5printEmi>
    331e:	8c 01       	movw	r16, r24
  n += println();
    3320:	ce 01       	movw	r24, r28
    3322:	0e 94 aa 18 	call	0x3154	; 0x3154 <_ZN5Print7printlnEv>
  return n;
}
    3326:	80 0f       	add	r24, r16
    3328:	91 1f       	adc	r25, r17
    332a:	df 91       	pop	r29
    332c:	cf 91       	pop	r28
    332e:	1f 91       	pop	r17
    3330:	0f 91       	pop	r16
    3332:	08 95       	ret

00003334 <_ZN5Print10printFloatEdh>:

  return write(str);
}

size_t Print::printFloat(double number, uint8_t digits) 
{ 
    3334:	4f 92       	push	r4
    3336:	5f 92       	push	r5
    3338:	6f 92       	push	r6
    333a:	7f 92       	push	r7
    333c:	8f 92       	push	r8
    333e:	9f 92       	push	r9
    3340:	af 92       	push	r10
    3342:	bf 92       	push	r11
    3344:	cf 92       	push	r12
    3346:	df 92       	push	r13
    3348:	ef 92       	push	r14
    334a:	ff 92       	push	r15
    334c:	0f 93       	push	r16
    334e:	1f 93       	push	r17
    3350:	cf 93       	push	r28
    3352:	df 93       	push	r29
    3354:	8c 01       	movw	r16, r24
    3356:	4a 01       	movw	r8, r20
    3358:	5b 01       	movw	r10, r22
    335a:	f2 2e       	mov	r15, r18
  size_t n = 0;
  
  if (isnan(number)) return print("nan");
    335c:	9a 01       	movw	r18, r20
    335e:	ab 01       	movw	r20, r22
    3360:	c5 01       	movw	r24, r10
    3362:	b4 01       	movw	r22, r8
    3364:	0e 94 3d 1c 	call	0x387a	; 0x387a <__unordsf2>
    3368:	88 23       	and	r24, r24
    336a:	31 f0       	breq	.+12     	; 0x3378 <_ZN5Print10printFloatEdh+0x44>
    336c:	62 ed       	ldi	r22, 0xD2	; 210
    336e:	71 e0       	ldi	r23, 0x01	; 1
    3370:	c8 01       	movw	r24, r16
    3372:	0e 94 8c 18 	call	0x3118	; 0x3118 <_ZN5Print5printEPKc>
    3376:	b5 c0       	rjmp	.+362    	; 0x34e2 <_ZN5Print10printFloatEdh+0x1ae>
  if (isinf(number)) return print("inf");
    3378:	24 01       	movw	r4, r8
    337a:	35 01       	movw	r6, r10
    337c:	e8 94       	clt
    337e:	77 f8       	bld	r7, 7
    3380:	2f ef       	ldi	r18, 0xFF	; 255
    3382:	3f ef       	ldi	r19, 0xFF	; 255
    3384:	4f e7       	ldi	r20, 0x7F	; 127
    3386:	5f e7       	ldi	r21, 0x7F	; 127
    3388:	c3 01       	movw	r24, r6
    338a:	b2 01       	movw	r22, r4
    338c:	0e 94 3d 1c 	call	0x387a	; 0x387a <__unordsf2>
    3390:	81 11       	cpse	r24, r1
    3392:	10 c0       	rjmp	.+32     	; 0x33b4 <_ZN5Print10printFloatEdh+0x80>
    3394:	2f ef       	ldi	r18, 0xFF	; 255
    3396:	3f ef       	ldi	r19, 0xFF	; 255
    3398:	4f e7       	ldi	r20, 0x7F	; 127
    339a:	5f e7       	ldi	r21, 0x7F	; 127
    339c:	c3 01       	movw	r24, r6
    339e:	b2 01       	movw	r22, r4
    33a0:	0e 94 36 1b 	call	0x366c	; 0x366c <__cmpsf2>
    33a4:	18 16       	cp	r1, r24
    33a6:	34 f4       	brge	.+12     	; 0x33b4 <_ZN5Print10printFloatEdh+0x80>
    33a8:	66 ed       	ldi	r22, 0xD6	; 214
    33aa:	71 e0       	ldi	r23, 0x01	; 1
    33ac:	c8 01       	movw	r24, r16
    33ae:	0e 94 8c 18 	call	0x3118	; 0x3118 <_ZN5Print5printEPKc>
    33b2:	97 c0       	rjmp	.+302    	; 0x34e2 <_ZN5Print10printFloatEdh+0x1ae>
  if (number > 4294967040.0) return print ("ovf");  // constant determined empirically
    33b4:	2f ef       	ldi	r18, 0xFF	; 255
    33b6:	3f ef       	ldi	r19, 0xFF	; 255
    33b8:	4f e7       	ldi	r20, 0x7F	; 127
    33ba:	5f e4       	ldi	r21, 0x4F	; 79
    33bc:	c5 01       	movw	r24, r10
    33be:	b4 01       	movw	r22, r8
    33c0:	0e 94 cb 1b 	call	0x3796	; 0x3796 <__gesf2>
    33c4:	18 16       	cp	r1, r24
    33c6:	34 f4       	brge	.+12     	; 0x33d4 <_ZN5Print10printFloatEdh+0xa0>
    33c8:	6a ed       	ldi	r22, 0xDA	; 218
    33ca:	71 e0       	ldi	r23, 0x01	; 1
    33cc:	c8 01       	movw	r24, r16
    33ce:	0e 94 8c 18 	call	0x3118	; 0x3118 <_ZN5Print5printEPKc>
    33d2:	87 c0       	rjmp	.+270    	; 0x34e2 <_ZN5Print10printFloatEdh+0x1ae>
  if (number <-4294967040.0) return print ("ovf");  // constant determined empirically
    33d4:	2f ef       	ldi	r18, 0xFF	; 255
    33d6:	3f ef       	ldi	r19, 0xFF	; 255
    33d8:	4f e7       	ldi	r20, 0x7F	; 127
    33da:	5f ec       	ldi	r21, 0xCF	; 207
    33dc:	c5 01       	movw	r24, r10
    33de:	b4 01       	movw	r22, r8
    33e0:	0e 94 36 1b 	call	0x366c	; 0x366c <__cmpsf2>
    33e4:	88 23       	and	r24, r24
    33e6:	34 f4       	brge	.+12     	; 0x33f4 <_ZN5Print10printFloatEdh+0xc0>
    33e8:	6a ed       	ldi	r22, 0xDA	; 218
    33ea:	71 e0       	ldi	r23, 0x01	; 1
    33ec:	c8 01       	movw	r24, r16
    33ee:	0e 94 8c 18 	call	0x3118	; 0x3118 <_ZN5Print5printEPKc>
    33f2:	77 c0       	rjmp	.+238    	; 0x34e2 <_ZN5Print10printFloatEdh+0x1ae>
  
  // Handle negative numbers
  if (number < 0.0)
    33f4:	20 e0       	ldi	r18, 0x00	; 0
    33f6:	30 e0       	ldi	r19, 0x00	; 0
    33f8:	a9 01       	movw	r20, r18
    33fa:	c5 01       	movw	r24, r10
    33fc:	b4 01       	movw	r22, r8
    33fe:	0e 94 36 1b 	call	0x366c	; 0x366c <__cmpsf2>
    3402:	88 23       	and	r24, r24
    3404:	54 f4       	brge	.+20     	; 0x341a <_ZN5Print10printFloatEdh+0xe6>
  {
     n += print('-');
    3406:	6d e2       	ldi	r22, 0x2D	; 45
    3408:	c8 01       	movw	r24, r16
    340a:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN5Print5printEc>
    340e:	6c 01       	movw	r12, r24
     number = -number;
    3410:	b7 fa       	bst	r11, 7
    3412:	b0 94       	com	r11
    3414:	b7 f8       	bld	r11, 7
    3416:	b0 94       	com	r11
    3418:	02 c0       	rjmp	.+4      	; 0x341e <_ZN5Print10printFloatEdh+0xea>
  return write(str);
}

size_t Print::printFloat(double number, uint8_t digits) 
{ 
  size_t n = 0;
    341a:	c1 2c       	mov	r12, r1
    341c:	d1 2c       	mov	r13, r1
     number = -number;
  }

  // Round correctly so that print(1.999, 2) prints as "2.00"
  double rounding = 0.5;
  for (uint8_t i=0; i<digits; ++i)
    341e:	d0 e0       	ldi	r29, 0x00	; 0
     n += print('-');
     number = -number;
  }

  // Round correctly so that print(1.999, 2) prints as "2.00"
  double rounding = 0.5;
    3420:	60 e0       	ldi	r22, 0x00	; 0
    3422:	70 e0       	ldi	r23, 0x00	; 0
    3424:	80 e0       	ldi	r24, 0x00	; 0
    3426:	9f e3       	ldi	r25, 0x3F	; 63
  for (uint8_t i=0; i<digits; ++i)
    3428:	df 15       	cp	r29, r15
    342a:	40 f4       	brcc	.+16     	; 0x343c <_ZN5Print10printFloatEdh+0x108>
    rounding /= 10.0;
    342c:	20 e0       	ldi	r18, 0x00	; 0
    342e:	30 e0       	ldi	r19, 0x00	; 0
    3430:	40 e2       	ldi	r20, 0x20	; 32
    3432:	51 e4       	ldi	r21, 0x41	; 65
    3434:	0e 94 44 0d 	call	0x1a88	; 0x1a88 <__divsf3>
     number = -number;
  }

  // Round correctly so that print(1.999, 2) prints as "2.00"
  double rounding = 0.5;
  for (uint8_t i=0; i<digits; ++i)
    3438:	df 5f       	subi	r29, 0xFF	; 255
    343a:	f6 cf       	rjmp	.-20     	; 0x3428 <_ZN5Print10printFloatEdh+0xf4>
    rounding /= 10.0;
  
  number += rounding;
    343c:	9b 01       	movw	r18, r22
    343e:	ac 01       	movw	r20, r24
    3440:	c5 01       	movw	r24, r10
    3442:	b4 01       	movw	r22, r8
    3444:	0e 94 ca 1a 	call	0x3594	; 0x3594 <__addsf3>
    3448:	4b 01       	movw	r8, r22
    344a:	5c 01       	movw	r10, r24

  // Extract the integer part of the number and print it
  unsigned long int_part = (unsigned long)number;
    344c:	0e 94 3b 1b 	call	0x3676	; 0x3676 <__fixunssfsi>
    3450:	2b 01       	movw	r4, r22
    3452:	3c 01       	movw	r6, r24
  double remainder = number - (double)int_part;
    3454:	0e 94 6a 1b 	call	0x36d4	; 0x36d4 <__floatunsisf>
    3458:	9b 01       	movw	r18, r22
    345a:	ac 01       	movw	r20, r24
    345c:	c5 01       	movw	r24, r10
    345e:	b4 01       	movw	r22, r8
    3460:	0e 94 c9 1a 	call	0x3592	; 0x3592 <__subsf3>
    3464:	4b 01       	movw	r8, r22
    3466:	5c 01       	movw	r10, r24
  n += print(int_part);
    3468:	2a e0       	ldi	r18, 0x0A	; 10
    346a:	30 e0       	ldi	r19, 0x00	; 0
    346c:	b3 01       	movw	r22, r6
    346e:	a2 01       	movw	r20, r4
    3470:	c8 01       	movw	r24, r16
    3472:	0e 94 72 19 	call	0x32e4	; 0x32e4 <_ZN5Print5printEmi>
    3476:	e6 01       	movw	r28, r12
    3478:	c8 0f       	add	r28, r24
    347a:	d9 1f       	adc	r29, r25

  // Print the decimal point, but only if there are digits beyond
  if (digits > 0) {
    347c:	ff 20       	and	r15, r15
    347e:	31 f0       	breq	.+12     	; 0x348c <_ZN5Print10printFloatEdh+0x158>
    n += print('.'); 
    3480:	6e e2       	ldi	r22, 0x2E	; 46
    3482:	c8 01       	movw	r24, r16
    3484:	0e 94 a2 18 	call	0x3144	; 0x3144 <_ZN5Print5printEc>
    3488:	c8 0f       	add	r28, r24
    348a:	d9 1f       	adc	r29, r25
  }

  // Extract digits from the remainder one at a time
  while (digits-- > 0)
    348c:	77 24       	eor	r7, r7
    348e:	7a 94       	dec	r7
    3490:	7f 0c       	add	r7, r15
    3492:	ff 20       	and	r15, r15
    3494:	21 f1       	breq	.+72     	; 0x34de <_ZN5Print10printFloatEdh+0x1aa>
  {
    remainder *= 10.0;
    3496:	20 e0       	ldi	r18, 0x00	; 0
    3498:	30 e0       	ldi	r19, 0x00	; 0
    349a:	40 e2       	ldi	r20, 0x20	; 32
    349c:	51 e4       	ldi	r21, 0x41	; 65
    349e:	c5 01       	movw	r24, r10
    34a0:	b4 01       	movw	r22, r8
    34a2:	0e 94 d0 1b 	call	0x37a0	; 0x37a0 <__mulsf3>
    34a6:	4b 01       	movw	r8, r22
    34a8:	5c 01       	movw	r10, r24
    unsigned int toPrint = (unsigned int)(remainder);
    34aa:	0e 94 3b 1b 	call	0x3676	; 0x3676 <__fixunssfsi>
    34ae:	6b 01       	movw	r12, r22
    34b0:	7c 01       	movw	r14, r24
    n += print(toPrint);
    34b2:	4a e0       	ldi	r20, 0x0A	; 10
    34b4:	50 e0       	ldi	r21, 0x00	; 0
    34b6:	c8 01       	movw	r24, r16
    34b8:	0e 94 81 19 	call	0x3302	; 0x3302 <_ZN5Print5printEji>
    34bc:	c8 0f       	add	r28, r24
    34be:	d9 1f       	adc	r29, r25
    remainder -= toPrint; 
    34c0:	b6 01       	movw	r22, r12
    34c2:	80 e0       	ldi	r24, 0x00	; 0
    34c4:	90 e0       	ldi	r25, 0x00	; 0
    34c6:	0e 94 6a 1b 	call	0x36d4	; 0x36d4 <__floatunsisf>
    34ca:	9b 01       	movw	r18, r22
    34cc:	ac 01       	movw	r20, r24
    34ce:	c5 01       	movw	r24, r10
    34d0:	b4 01       	movw	r22, r8
    34d2:	0e 94 c9 1a 	call	0x3592	; 0x3592 <__subsf3>
    34d6:	4b 01       	movw	r8, r22
    34d8:	5c 01       	movw	r10, r24
  if (digits > 0) {
    n += print('.'); 
  }

  // Extract digits from the remainder one at a time
  while (digits-- > 0)
    34da:	f7 2c       	mov	r15, r7
    34dc:	d7 cf       	rjmp	.-82     	; 0x348c <_ZN5Print10printFloatEdh+0x158>
    unsigned int toPrint = (unsigned int)(remainder);
    n += print(toPrint);
    remainder -= toPrint; 
  } 
  
  return n;
    34de:	8c 2f       	mov	r24, r28
    34e0:	9d 2f       	mov	r25, r29
}
    34e2:	df 91       	pop	r29
    34e4:	cf 91       	pop	r28
    34e6:	1f 91       	pop	r17
    34e8:	0f 91       	pop	r16
    34ea:	ff 90       	pop	r15
    34ec:	ef 90       	pop	r14
    34ee:	df 90       	pop	r13
    34f0:	cf 90       	pop	r12
    34f2:	bf 90       	pop	r11
    34f4:	af 90       	pop	r10
    34f6:	9f 90       	pop	r9
    34f8:	8f 90       	pop	r8
    34fa:	7f 90       	pop	r7
    34fc:	6f 90       	pop	r6
    34fe:	5f 90       	pop	r5
    3500:	4f 90       	pop	r4
    3502:	08 95       	ret

00003504 <_ZN5Print5printEdi>:
  else return printNumber(n, base);
}

size_t Print::print(double n, int digits)
{
  return printFloat(n, digits);
    3504:	0e 94 9a 19 	call	0x3334	; 0x3334 <_ZN5Print10printFloatEdh>
}
    3508:	08 95       	ret

0000350a <_ZN5Print7printlnEdi>:
  n += println();
  return n;
}

size_t Print::println(double num, int digits)
{
    350a:	0f 93       	push	r16
    350c:	1f 93       	push	r17
    350e:	cf 93       	push	r28
    3510:	df 93       	push	r29
    3512:	ec 01       	movw	r28, r24
  size_t n = print(num, digits);
    3514:	0e 94 82 1a 	call	0x3504	; 0x3504 <_ZN5Print5printEdi>
    3518:	8c 01       	movw	r16, r24
  n += println();
    351a:	ce 01       	movw	r24, r28
    351c:	0e 94 aa 18 	call	0x3154	; 0x3154 <_ZN5Print7printlnEv>
  return n;
}
    3520:	80 0f       	add	r24, r16
    3522:	91 1f       	adc	r25, r17
    3524:	df 91       	pop	r29
    3526:	cf 91       	pop	r28
    3528:	1f 91       	pop	r17
    352a:	0f 91       	pop	r16
    352c:	08 95       	ret

0000352e <_ZN6Stream14readBytesUntilEcPcj>:
// as readBytes with terminator character
// terminates if length characters have been read, timeout, or if the terminator character  detected
// returns the number of characters placed in the buffer (0 means no valid data found)

size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)
{
    352e:	bf 92       	push	r11
    3530:	cf 92       	push	r12
    3532:	df 92       	push	r13
    3534:	ef 92       	push	r14
    3536:	ff 92       	push	r15
    3538:	0f 93       	push	r16
    353a:	1f 93       	push	r17
    353c:	cf 93       	push	r28
    353e:	df 93       	push	r29
    3540:	7c 01       	movw	r14, r24
    3542:	b6 2e       	mov	r11, r22
    3544:	8a 01       	movw	r16, r20
    3546:	69 01       	movw	r12, r18
  size_t index = 0;
    3548:	c0 e0       	ldi	r28, 0x00	; 0
    354a:	d0 e0       	ldi	r29, 0x00	; 0
  while (index < length) {
    354c:	cc 15       	cp	r28, r12
    354e:	dd 05       	cpc	r29, r13
    3550:	a8 f4       	brcc	.+42     	; 0x357c <_ZN6Stream14readBytesUntilEcPcj+0x4e>
    int c = read();
    3552:	d7 01       	movw	r26, r14
    3554:	ed 91       	ld	r30, X+
    3556:	fc 91       	ld	r31, X
    3558:	02 84       	ldd	r0, Z+10	; 0x0a
    355a:	f3 85       	ldd	r31, Z+11	; 0x0b
    355c:	e0 2d       	mov	r30, r0
    355e:	c7 01       	movw	r24, r14
    3560:	09 95       	icall
    if (c < 0 || c == terminator) break;
    3562:	99 23       	and	r25, r25
    3564:	5c f0       	brlt	.+22     	; 0x357c <_ZN6Stream14readBytesUntilEcPcj+0x4e>
    3566:	2b 2d       	mov	r18, r11
    3568:	30 e0       	ldi	r19, 0x00	; 0
    356a:	82 17       	cp	r24, r18
    356c:	93 07       	cpc	r25, r19
    356e:	31 f0       	breq	.+12     	; 0x357c <_ZN6Stream14readBytesUntilEcPcj+0x4e>
    *buffer++ = (char)c;
    3570:	f8 01       	movw	r30, r16
    3572:	80 83       	st	Z, r24
    index++;
    3574:	21 96       	adiw	r28, 0x01	; 1
{
  size_t index = 0;
  while (index < length) {
    int c = read();
    if (c < 0 || c == terminator) break;
    *buffer++ = (char)c;
    3576:	0f 5f       	subi	r16, 0xFF	; 255
    3578:	1f 4f       	sbci	r17, 0xFF	; 255
// returns the number of characters placed in the buffer (0 means no valid data found)

size_t Stream::readBytesUntil(char terminator, char *buffer, size_t length)
{
  size_t index = 0;
  while (index < length) {
    357a:	e8 cf       	rjmp	.-48     	; 0x354c <_ZN6Stream14readBytesUntilEcPcj+0x1e>
    if (c < 0 || c == terminator) break;
    *buffer++ = (char)c;
    index++;
  }
  return index; // return number of characters, not including null terminator
}
    357c:	ce 01       	movw	r24, r28
    357e:	df 91       	pop	r29
    3580:	cf 91       	pop	r28
    3582:	1f 91       	pop	r17
    3584:	0f 91       	pop	r16
    3586:	ff 90       	pop	r15
    3588:	ef 90       	pop	r14
    358a:	df 90       	pop	r13
    358c:	cf 90       	pop	r12
    358e:	bf 90       	pop	r11
    3590:	08 95       	ret

00003592 <__subsf3>:
    3592:	50 58       	subi	r21, 0x80	; 128

00003594 <__addsf3>:
    3594:	bb 27       	eor	r27, r27
    3596:	aa 27       	eor	r26, r26
    3598:	0e 94 e1 1a 	call	0x35c2	; 0x35c2 <__addsf3x>
    359c:	0c 94 cd 0d 	jmp	0x1b9a	; 0x1b9a <__fp_round>
    35a0:	0e 94 bf 0d 	call	0x1b7e	; 0x1b7e <__fp_pscA>
    35a4:	38 f0       	brcs	.+14     	; 0x35b4 <__addsf3+0x20>
    35a6:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <__fp_pscB>
    35aa:	20 f0       	brcs	.+8      	; 0x35b4 <__addsf3+0x20>
    35ac:	39 f4       	brne	.+14     	; 0x35bc <__addsf3+0x28>
    35ae:	9f 3f       	cpi	r25, 0xFF	; 255
    35b0:	19 f4       	brne	.+6      	; 0x35b8 <__addsf3+0x24>
    35b2:	26 f4       	brtc	.+8      	; 0x35bc <__addsf3+0x28>
    35b4:	0c 94 bc 0d 	jmp	0x1b78	; 0x1b78 <__fp_nan>
    35b8:	0e f4       	brtc	.+2      	; 0x35bc <__addsf3+0x28>
    35ba:	e0 95       	com	r30
    35bc:	e7 fb       	bst	r30, 7
    35be:	0c 94 b6 0d 	jmp	0x1b6c	; 0x1b6c <__fp_inf>

000035c2 <__addsf3x>:
    35c2:	e9 2f       	mov	r30, r25
    35c4:	0e 94 de 0d 	call	0x1bbc	; 0x1bbc <__fp_split3>
    35c8:	58 f3       	brcs	.-42     	; 0x35a0 <__addsf3+0xc>
    35ca:	ba 17       	cp	r27, r26
    35cc:	62 07       	cpc	r22, r18
    35ce:	73 07       	cpc	r23, r19
    35d0:	84 07       	cpc	r24, r20
    35d2:	95 07       	cpc	r25, r21
    35d4:	20 f0       	brcs	.+8      	; 0x35de <__addsf3x+0x1c>
    35d6:	79 f4       	brne	.+30     	; 0x35f6 <__addsf3x+0x34>
    35d8:	a6 f5       	brtc	.+104    	; 0x3642 <__addsf3x+0x80>
    35da:	0c 94 00 0e 	jmp	0x1c00	; 0x1c00 <__fp_zero>
    35de:	0e f4       	brtc	.+2      	; 0x35e2 <__addsf3x+0x20>
    35e0:	e0 95       	com	r30
    35e2:	0b 2e       	mov	r0, r27
    35e4:	ba 2f       	mov	r27, r26
    35e6:	a0 2d       	mov	r26, r0
    35e8:	0b 01       	movw	r0, r22
    35ea:	b9 01       	movw	r22, r18
    35ec:	90 01       	movw	r18, r0
    35ee:	0c 01       	movw	r0, r24
    35f0:	ca 01       	movw	r24, r20
    35f2:	a0 01       	movw	r20, r0
    35f4:	11 24       	eor	r1, r1
    35f6:	ff 27       	eor	r31, r31
    35f8:	59 1b       	sub	r21, r25
    35fa:	99 f0       	breq	.+38     	; 0x3622 <__addsf3x+0x60>
    35fc:	59 3f       	cpi	r21, 0xF9	; 249
    35fe:	50 f4       	brcc	.+20     	; 0x3614 <__addsf3x+0x52>
    3600:	50 3e       	cpi	r21, 0xE0	; 224
    3602:	68 f1       	brcs	.+90     	; 0x365e <__addsf3x+0x9c>
    3604:	1a 16       	cp	r1, r26
    3606:	f0 40       	sbci	r31, 0x00	; 0
    3608:	a2 2f       	mov	r26, r18
    360a:	23 2f       	mov	r18, r19
    360c:	34 2f       	mov	r19, r20
    360e:	44 27       	eor	r20, r20
    3610:	58 5f       	subi	r21, 0xF8	; 248
    3612:	f3 cf       	rjmp	.-26     	; 0x35fa <__addsf3x+0x38>
    3614:	46 95       	lsr	r20
    3616:	37 95       	ror	r19
    3618:	27 95       	ror	r18
    361a:	a7 95       	ror	r26
    361c:	f0 40       	sbci	r31, 0x00	; 0
    361e:	53 95       	inc	r21
    3620:	c9 f7       	brne	.-14     	; 0x3614 <__addsf3x+0x52>
    3622:	7e f4       	brtc	.+30     	; 0x3642 <__addsf3x+0x80>
    3624:	1f 16       	cp	r1, r31
    3626:	ba 0b       	sbc	r27, r26
    3628:	62 0b       	sbc	r22, r18
    362a:	73 0b       	sbc	r23, r19
    362c:	84 0b       	sbc	r24, r20
    362e:	ba f0       	brmi	.+46     	; 0x365e <__addsf3x+0x9c>
    3630:	91 50       	subi	r25, 0x01	; 1
    3632:	a1 f0       	breq	.+40     	; 0x365c <__addsf3x+0x9a>
    3634:	ff 0f       	add	r31, r31
    3636:	bb 1f       	adc	r27, r27
    3638:	66 1f       	adc	r22, r22
    363a:	77 1f       	adc	r23, r23
    363c:	88 1f       	adc	r24, r24
    363e:	c2 f7       	brpl	.-16     	; 0x3630 <__addsf3x+0x6e>
    3640:	0e c0       	rjmp	.+28     	; 0x365e <__addsf3x+0x9c>
    3642:	ba 0f       	add	r27, r26
    3644:	62 1f       	adc	r22, r18
    3646:	73 1f       	adc	r23, r19
    3648:	84 1f       	adc	r24, r20
    364a:	48 f4       	brcc	.+18     	; 0x365e <__addsf3x+0x9c>
    364c:	87 95       	ror	r24
    364e:	77 95       	ror	r23
    3650:	67 95       	ror	r22
    3652:	b7 95       	ror	r27
    3654:	f7 95       	ror	r31
    3656:	9e 3f       	cpi	r25, 0xFE	; 254
    3658:	08 f0       	brcs	.+2      	; 0x365c <__addsf3x+0x9a>
    365a:	b0 cf       	rjmp	.-160    	; 0x35bc <__addsf3+0x28>
    365c:	93 95       	inc	r25
    365e:	88 0f       	add	r24, r24
    3660:	08 f0       	brcs	.+2      	; 0x3664 <__addsf3x+0xa2>
    3662:	99 27       	eor	r25, r25
    3664:	ee 0f       	add	r30, r30
    3666:	97 95       	ror	r25
    3668:	87 95       	ror	r24
    366a:	08 95       	ret

0000366c <__cmpsf2>:
    366c:	0e 94 a7 1b 	call	0x374e	; 0x374e <__fp_cmp>
    3670:	08 f4       	brcc	.+2      	; 0x3674 <__cmpsf2+0x8>
    3672:	81 e0       	ldi	r24, 0x01	; 1
    3674:	08 95       	ret

00003676 <__fixunssfsi>:
    3676:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <__fp_splitA>
    367a:	88 f0       	brcs	.+34     	; 0x369e <__fixunssfsi+0x28>
    367c:	9f 57       	subi	r25, 0x7F	; 127
    367e:	98 f0       	brcs	.+38     	; 0x36a6 <__fixunssfsi+0x30>
    3680:	b9 2f       	mov	r27, r25
    3682:	99 27       	eor	r25, r25
    3684:	b7 51       	subi	r27, 0x17	; 23
    3686:	b0 f0       	brcs	.+44     	; 0x36b4 <__fixunssfsi+0x3e>
    3688:	e1 f0       	breq	.+56     	; 0x36c2 <__fixunssfsi+0x4c>
    368a:	66 0f       	add	r22, r22
    368c:	77 1f       	adc	r23, r23
    368e:	88 1f       	adc	r24, r24
    3690:	99 1f       	adc	r25, r25
    3692:	1a f0       	brmi	.+6      	; 0x369a <__fixunssfsi+0x24>
    3694:	ba 95       	dec	r27
    3696:	c9 f7       	brne	.-14     	; 0x368a <__fixunssfsi+0x14>
    3698:	14 c0       	rjmp	.+40     	; 0x36c2 <__fixunssfsi+0x4c>
    369a:	b1 30       	cpi	r27, 0x01	; 1
    369c:	91 f0       	breq	.+36     	; 0x36c2 <__fixunssfsi+0x4c>
    369e:	0e 94 00 0e 	call	0x1c00	; 0x1c00 <__fp_zero>
    36a2:	b1 e0       	ldi	r27, 0x01	; 1
    36a4:	08 95       	ret
    36a6:	0c 94 00 0e 	jmp	0x1c00	; 0x1c00 <__fp_zero>
    36aa:	67 2f       	mov	r22, r23
    36ac:	78 2f       	mov	r23, r24
    36ae:	88 27       	eor	r24, r24
    36b0:	b8 5f       	subi	r27, 0xF8	; 248
    36b2:	39 f0       	breq	.+14     	; 0x36c2 <__fixunssfsi+0x4c>
    36b4:	b9 3f       	cpi	r27, 0xF9	; 249
    36b6:	cc f3       	brlt	.-14     	; 0x36aa <__fixunssfsi+0x34>
    36b8:	86 95       	lsr	r24
    36ba:	77 95       	ror	r23
    36bc:	67 95       	ror	r22
    36be:	b3 95       	inc	r27
    36c0:	d9 f7       	brne	.-10     	; 0x36b8 <__fixunssfsi+0x42>
    36c2:	3e f4       	brtc	.+14     	; 0x36d2 <__fixunssfsi+0x5c>
    36c4:	90 95       	com	r25
    36c6:	80 95       	com	r24
    36c8:	70 95       	com	r23
    36ca:	61 95       	neg	r22
    36cc:	7f 4f       	sbci	r23, 0xFF	; 255
    36ce:	8f 4f       	sbci	r24, 0xFF	; 255
    36d0:	9f 4f       	sbci	r25, 0xFF	; 255
    36d2:	08 95       	ret

000036d4 <__floatunsisf>:
    36d4:	e8 94       	clt
    36d6:	09 c0       	rjmp	.+18     	; 0x36ea <__floatsisf+0x12>

000036d8 <__floatsisf>:
    36d8:	97 fb       	bst	r25, 7
    36da:	3e f4       	brtc	.+14     	; 0x36ea <__floatsisf+0x12>
    36dc:	90 95       	com	r25
    36de:	80 95       	com	r24
    36e0:	70 95       	com	r23
    36e2:	61 95       	neg	r22
    36e4:	7f 4f       	sbci	r23, 0xFF	; 255
    36e6:	8f 4f       	sbci	r24, 0xFF	; 255
    36e8:	9f 4f       	sbci	r25, 0xFF	; 255
    36ea:	99 23       	and	r25, r25
    36ec:	a9 f0       	breq	.+42     	; 0x3718 <__floatsisf+0x40>
    36ee:	f9 2f       	mov	r31, r25
    36f0:	96 e9       	ldi	r25, 0x96	; 150
    36f2:	bb 27       	eor	r27, r27
    36f4:	93 95       	inc	r25
    36f6:	f6 95       	lsr	r31
    36f8:	87 95       	ror	r24
    36fa:	77 95       	ror	r23
    36fc:	67 95       	ror	r22
    36fe:	b7 95       	ror	r27
    3700:	f1 11       	cpse	r31, r1
    3702:	f8 cf       	rjmp	.-16     	; 0x36f4 <__floatsisf+0x1c>
    3704:	fa f4       	brpl	.+62     	; 0x3744 <__floatsisf+0x6c>
    3706:	bb 0f       	add	r27, r27
    3708:	11 f4       	brne	.+4      	; 0x370e <__floatsisf+0x36>
    370a:	60 ff       	sbrs	r22, 0
    370c:	1b c0       	rjmp	.+54     	; 0x3744 <__floatsisf+0x6c>
    370e:	6f 5f       	subi	r22, 0xFF	; 255
    3710:	7f 4f       	sbci	r23, 0xFF	; 255
    3712:	8f 4f       	sbci	r24, 0xFF	; 255
    3714:	9f 4f       	sbci	r25, 0xFF	; 255
    3716:	16 c0       	rjmp	.+44     	; 0x3744 <__floatsisf+0x6c>
    3718:	88 23       	and	r24, r24
    371a:	11 f0       	breq	.+4      	; 0x3720 <__floatsisf+0x48>
    371c:	96 e9       	ldi	r25, 0x96	; 150
    371e:	11 c0       	rjmp	.+34     	; 0x3742 <__floatsisf+0x6a>
    3720:	77 23       	and	r23, r23
    3722:	21 f0       	breq	.+8      	; 0x372c <__floatsisf+0x54>
    3724:	9e e8       	ldi	r25, 0x8E	; 142
    3726:	87 2f       	mov	r24, r23
    3728:	76 2f       	mov	r23, r22
    372a:	05 c0       	rjmp	.+10     	; 0x3736 <__floatsisf+0x5e>
    372c:	66 23       	and	r22, r22
    372e:	71 f0       	breq	.+28     	; 0x374c <__floatsisf+0x74>
    3730:	96 e8       	ldi	r25, 0x86	; 134
    3732:	86 2f       	mov	r24, r22
    3734:	70 e0       	ldi	r23, 0x00	; 0
    3736:	60 e0       	ldi	r22, 0x00	; 0
    3738:	2a f0       	brmi	.+10     	; 0x3744 <__floatsisf+0x6c>
    373a:	9a 95       	dec	r25
    373c:	66 0f       	add	r22, r22
    373e:	77 1f       	adc	r23, r23
    3740:	88 1f       	adc	r24, r24
    3742:	da f7       	brpl	.-10     	; 0x373a <__floatsisf+0x62>
    3744:	88 0f       	add	r24, r24
    3746:	96 95       	lsr	r25
    3748:	87 95       	ror	r24
    374a:	97 f9       	bld	r25, 7
    374c:	08 95       	ret

0000374e <__fp_cmp>:
    374e:	99 0f       	add	r25, r25
    3750:	00 08       	sbc	r0, r0
    3752:	55 0f       	add	r21, r21
    3754:	aa 0b       	sbc	r26, r26
    3756:	e0 e8       	ldi	r30, 0x80	; 128
    3758:	fe ef       	ldi	r31, 0xFE	; 254
    375a:	16 16       	cp	r1, r22
    375c:	17 06       	cpc	r1, r23
    375e:	e8 07       	cpc	r30, r24
    3760:	f9 07       	cpc	r31, r25
    3762:	c0 f0       	brcs	.+48     	; 0x3794 <__fp_cmp+0x46>
    3764:	12 16       	cp	r1, r18
    3766:	13 06       	cpc	r1, r19
    3768:	e4 07       	cpc	r30, r20
    376a:	f5 07       	cpc	r31, r21
    376c:	98 f0       	brcs	.+38     	; 0x3794 <__fp_cmp+0x46>
    376e:	62 1b       	sub	r22, r18
    3770:	73 0b       	sbc	r23, r19
    3772:	84 0b       	sbc	r24, r20
    3774:	95 0b       	sbc	r25, r21
    3776:	39 f4       	brne	.+14     	; 0x3786 <__fp_cmp+0x38>
    3778:	0a 26       	eor	r0, r26
    377a:	61 f0       	breq	.+24     	; 0x3794 <__fp_cmp+0x46>
    377c:	23 2b       	or	r18, r19
    377e:	24 2b       	or	r18, r20
    3780:	25 2b       	or	r18, r21
    3782:	21 f4       	brne	.+8      	; 0x378c <__fp_cmp+0x3e>
    3784:	08 95       	ret
    3786:	0a 26       	eor	r0, r26
    3788:	09 f4       	brne	.+2      	; 0x378c <__fp_cmp+0x3e>
    378a:	a1 40       	sbci	r26, 0x01	; 1
    378c:	a6 95       	lsr	r26
    378e:	8f ef       	ldi	r24, 0xFF	; 255
    3790:	81 1d       	adc	r24, r1
    3792:	81 1d       	adc	r24, r1
    3794:	08 95       	ret

00003796 <__gesf2>:
    3796:	0e 94 a7 1b 	call	0x374e	; 0x374e <__fp_cmp>
    379a:	08 f4       	brcc	.+2      	; 0x379e <__gesf2+0x8>
    379c:	8f ef       	ldi	r24, 0xFF	; 255
    379e:	08 95       	ret

000037a0 <__mulsf3>:
    37a0:	0e 94 e3 1b 	call	0x37c6	; 0x37c6 <__mulsf3x>
    37a4:	0c 94 cd 0d 	jmp	0x1b9a	; 0x1b9a <__fp_round>
    37a8:	0e 94 bf 0d 	call	0x1b7e	; 0x1b7e <__fp_pscA>
    37ac:	38 f0       	brcs	.+14     	; 0x37bc <__mulsf3+0x1c>
    37ae:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <__fp_pscB>
    37b2:	20 f0       	brcs	.+8      	; 0x37bc <__mulsf3+0x1c>
    37b4:	95 23       	and	r25, r21
    37b6:	11 f0       	breq	.+4      	; 0x37bc <__mulsf3+0x1c>
    37b8:	0c 94 b6 0d 	jmp	0x1b6c	; 0x1b6c <__fp_inf>
    37bc:	0c 94 bc 0d 	jmp	0x1b78	; 0x1b78 <__fp_nan>
    37c0:	11 24       	eor	r1, r1
    37c2:	0c 94 01 0e 	jmp	0x1c02	; 0x1c02 <__fp_szero>

000037c6 <__mulsf3x>:
    37c6:	0e 94 de 0d 	call	0x1bbc	; 0x1bbc <__fp_split3>
    37ca:	70 f3       	brcs	.-36     	; 0x37a8 <__mulsf3+0x8>

000037cc <__mulsf3_pse>:
    37cc:	95 9f       	mul	r25, r21
    37ce:	c1 f3       	breq	.-16     	; 0x37c0 <__mulsf3+0x20>
    37d0:	95 0f       	add	r25, r21
    37d2:	50 e0       	ldi	r21, 0x00	; 0
    37d4:	55 1f       	adc	r21, r21
    37d6:	62 9f       	mul	r22, r18
    37d8:	f0 01       	movw	r30, r0
    37da:	72 9f       	mul	r23, r18
    37dc:	bb 27       	eor	r27, r27
    37de:	f0 0d       	add	r31, r0
    37e0:	b1 1d       	adc	r27, r1
    37e2:	63 9f       	mul	r22, r19
    37e4:	aa 27       	eor	r26, r26
    37e6:	f0 0d       	add	r31, r0
    37e8:	b1 1d       	adc	r27, r1
    37ea:	aa 1f       	adc	r26, r26
    37ec:	64 9f       	mul	r22, r20
    37ee:	66 27       	eor	r22, r22
    37f0:	b0 0d       	add	r27, r0
    37f2:	a1 1d       	adc	r26, r1
    37f4:	66 1f       	adc	r22, r22
    37f6:	82 9f       	mul	r24, r18
    37f8:	22 27       	eor	r18, r18
    37fa:	b0 0d       	add	r27, r0
    37fc:	a1 1d       	adc	r26, r1
    37fe:	62 1f       	adc	r22, r18
    3800:	73 9f       	mul	r23, r19
    3802:	b0 0d       	add	r27, r0
    3804:	a1 1d       	adc	r26, r1
    3806:	62 1f       	adc	r22, r18
    3808:	83 9f       	mul	r24, r19
    380a:	a0 0d       	add	r26, r0
    380c:	61 1d       	adc	r22, r1
    380e:	22 1f       	adc	r18, r18
    3810:	74 9f       	mul	r23, r20
    3812:	33 27       	eor	r19, r19
    3814:	a0 0d       	add	r26, r0
    3816:	61 1d       	adc	r22, r1
    3818:	23 1f       	adc	r18, r19
    381a:	84 9f       	mul	r24, r20
    381c:	60 0d       	add	r22, r0
    381e:	21 1d       	adc	r18, r1
    3820:	82 2f       	mov	r24, r18
    3822:	76 2f       	mov	r23, r22
    3824:	6a 2f       	mov	r22, r26
    3826:	11 24       	eor	r1, r1
    3828:	9f 57       	subi	r25, 0x7F	; 127
    382a:	50 40       	sbci	r21, 0x00	; 0
    382c:	9a f0       	brmi	.+38     	; 0x3854 <__mulsf3_pse+0x88>
    382e:	f1 f0       	breq	.+60     	; 0x386c <__mulsf3_pse+0xa0>
    3830:	88 23       	and	r24, r24
    3832:	4a f0       	brmi	.+18     	; 0x3846 <__mulsf3_pse+0x7a>
    3834:	ee 0f       	add	r30, r30
    3836:	ff 1f       	adc	r31, r31
    3838:	bb 1f       	adc	r27, r27
    383a:	66 1f       	adc	r22, r22
    383c:	77 1f       	adc	r23, r23
    383e:	88 1f       	adc	r24, r24
    3840:	91 50       	subi	r25, 0x01	; 1
    3842:	50 40       	sbci	r21, 0x00	; 0
    3844:	a9 f7       	brne	.-22     	; 0x3830 <__mulsf3_pse+0x64>
    3846:	9e 3f       	cpi	r25, 0xFE	; 254
    3848:	51 05       	cpc	r21, r1
    384a:	80 f0       	brcs	.+32     	; 0x386c <__mulsf3_pse+0xa0>
    384c:	0c 94 b6 0d 	jmp	0x1b6c	; 0x1b6c <__fp_inf>
    3850:	0c 94 01 0e 	jmp	0x1c02	; 0x1c02 <__fp_szero>
    3854:	5f 3f       	cpi	r21, 0xFF	; 255
    3856:	e4 f3       	brlt	.-8      	; 0x3850 <__mulsf3_pse+0x84>
    3858:	98 3e       	cpi	r25, 0xE8	; 232
    385a:	d4 f3       	brlt	.-12     	; 0x3850 <__mulsf3_pse+0x84>
    385c:	86 95       	lsr	r24
    385e:	77 95       	ror	r23
    3860:	67 95       	ror	r22
    3862:	b7 95       	ror	r27
    3864:	f7 95       	ror	r31
    3866:	e7 95       	ror	r30
    3868:	9f 5f       	subi	r25, 0xFF	; 255
    386a:	c1 f7       	brne	.-16     	; 0x385c <__mulsf3_pse+0x90>
    386c:	fe 2b       	or	r31, r30
    386e:	88 0f       	add	r24, r24
    3870:	91 1d       	adc	r25, r1
    3872:	96 95       	lsr	r25
    3874:	87 95       	ror	r24
    3876:	97 f9       	bld	r25, 7
    3878:	08 95       	ret

0000387a <__unordsf2>:
    387a:	0e 94 a7 1b 	call	0x374e	; 0x374e <__fp_cmp>
    387e:	88 0b       	sbc	r24, r24
    3880:	99 0b       	sbc	r25, r25
    3882:	08 95       	ret

00003884 <__mulsi3>:
    3884:	db 01       	movw	r26, r22
    3886:	8f 93       	push	r24
    3888:	9f 93       	push	r25
    388a:	0e 94 74 1c 	call	0x38e8	; 0x38e8 <__muluhisi3>
    388e:	bf 91       	pop	r27
    3890:	af 91       	pop	r26
    3892:	a2 9f       	mul	r26, r18
    3894:	80 0d       	add	r24, r0
    3896:	91 1d       	adc	r25, r1
    3898:	a3 9f       	mul	r26, r19
    389a:	90 0d       	add	r25, r0
    389c:	b2 9f       	mul	r27, r18
    389e:	90 0d       	add	r25, r0
    38a0:	11 24       	eor	r1, r1
    38a2:	08 95       	ret

000038a4 <__udivmodsi4>:
    38a4:	a1 e2       	ldi	r26, 0x21	; 33
    38a6:	1a 2e       	mov	r1, r26
    38a8:	aa 1b       	sub	r26, r26
    38aa:	bb 1b       	sub	r27, r27
    38ac:	fd 01       	movw	r30, r26
    38ae:	0d c0       	rjmp	.+26     	; 0x38ca <__udivmodsi4_ep>

000038b0 <__udivmodsi4_loop>:
    38b0:	aa 1f       	adc	r26, r26
    38b2:	bb 1f       	adc	r27, r27
    38b4:	ee 1f       	adc	r30, r30
    38b6:	ff 1f       	adc	r31, r31
    38b8:	a2 17       	cp	r26, r18
    38ba:	b3 07       	cpc	r27, r19
    38bc:	e4 07       	cpc	r30, r20
    38be:	f5 07       	cpc	r31, r21
    38c0:	20 f0       	brcs	.+8      	; 0x38ca <__udivmodsi4_ep>
    38c2:	a2 1b       	sub	r26, r18
    38c4:	b3 0b       	sbc	r27, r19
    38c6:	e4 0b       	sbc	r30, r20
    38c8:	f5 0b       	sbc	r31, r21

000038ca <__udivmodsi4_ep>:
    38ca:	66 1f       	adc	r22, r22
    38cc:	77 1f       	adc	r23, r23
    38ce:	88 1f       	adc	r24, r24
    38d0:	99 1f       	adc	r25, r25
    38d2:	1a 94       	dec	r1
    38d4:	69 f7       	brne	.-38     	; 0x38b0 <__udivmodsi4_loop>
    38d6:	60 95       	com	r22
    38d8:	70 95       	com	r23
    38da:	80 95       	com	r24
    38dc:	90 95       	com	r25
    38de:	9b 01       	movw	r18, r22
    38e0:	ac 01       	movw	r20, r24
    38e2:	bd 01       	movw	r22, r26
    38e4:	cf 01       	movw	r24, r30
    38e6:	08 95       	ret

000038e8 <__muluhisi3>:
    38e8:	0e 94 0b 1d 	call	0x3a16	; 0x3a16 <__umulhisi3>
    38ec:	a5 9f       	mul	r26, r21
    38ee:	90 0d       	add	r25, r0
    38f0:	b4 9f       	mul	r27, r20
    38f2:	90 0d       	add	r25, r0
    38f4:	a4 9f       	mul	r26, r20
    38f6:	80 0d       	add	r24, r0
    38f8:	91 1d       	adc	r25, r1
    38fa:	11 24       	eor	r1, r1
    38fc:	08 95       	ret

000038fe <__umoddi3>:
    38fe:	68 94       	set
    3900:	01 c0       	rjmp	.+2      	; 0x3904 <__udivdi3_umoddi3>

00003902 <__udivdi3>:
    3902:	e8 94       	clt

00003904 <__udivdi3_umoddi3>:
    3904:	8f 92       	push	r8
    3906:	9f 92       	push	r9
    3908:	cf 93       	push	r28
    390a:	df 93       	push	r29
    390c:	0e 94 8d 1c 	call	0x391a	; 0x391a <__udivmod64>
    3910:	df 91       	pop	r29
    3912:	cf 91       	pop	r28
    3914:	9f 90       	pop	r9
    3916:	8f 90       	pop	r8
    3918:	08 95       	ret

0000391a <__udivmod64>:
    391a:	88 24       	eor	r8, r8
    391c:	99 24       	eor	r9, r9
    391e:	f4 01       	movw	r30, r8
    3920:	e4 01       	movw	r28, r8
    3922:	b0 e4       	ldi	r27, 0x40	; 64
    3924:	9f 93       	push	r25
    3926:	aa 27       	eor	r26, r26
    3928:	9a 15       	cp	r25, r10
    392a:	8b 04       	cpc	r8, r11
    392c:	9c 04       	cpc	r9, r12
    392e:	ed 05       	cpc	r30, r13
    3930:	fe 05       	cpc	r31, r14
    3932:	cf 05       	cpc	r28, r15
    3934:	d0 07       	cpc	r29, r16
    3936:	a1 07       	cpc	r26, r17
    3938:	98 f4       	brcc	.+38     	; 0x3960 <__udivmod64+0x46>
    393a:	ad 2f       	mov	r26, r29
    393c:	dc 2f       	mov	r29, r28
    393e:	cf 2f       	mov	r28, r31
    3940:	fe 2f       	mov	r31, r30
    3942:	e9 2d       	mov	r30, r9
    3944:	98 2c       	mov	r9, r8
    3946:	89 2e       	mov	r8, r25
    3948:	98 2f       	mov	r25, r24
    394a:	87 2f       	mov	r24, r23
    394c:	76 2f       	mov	r23, r22
    394e:	65 2f       	mov	r22, r21
    3950:	54 2f       	mov	r21, r20
    3952:	43 2f       	mov	r20, r19
    3954:	32 2f       	mov	r19, r18
    3956:	22 27       	eor	r18, r18
    3958:	b8 50       	subi	r27, 0x08	; 8
    395a:	31 f7       	brne	.-52     	; 0x3928 <__udivmod64+0xe>
    395c:	bf 91       	pop	r27
    395e:	27 c0       	rjmp	.+78     	; 0x39ae <__udivmod64+0x94>
    3960:	1b 2e       	mov	r1, r27
    3962:	bf 91       	pop	r27
    3964:	bb 27       	eor	r27, r27
    3966:	22 0f       	add	r18, r18
    3968:	33 1f       	adc	r19, r19
    396a:	44 1f       	adc	r20, r20
    396c:	55 1f       	adc	r21, r21
    396e:	66 1f       	adc	r22, r22
    3970:	77 1f       	adc	r23, r23
    3972:	88 1f       	adc	r24, r24
    3974:	99 1f       	adc	r25, r25
    3976:	88 1c       	adc	r8, r8
    3978:	99 1c       	adc	r9, r9
    397a:	ee 1f       	adc	r30, r30
    397c:	ff 1f       	adc	r31, r31
    397e:	cc 1f       	adc	r28, r28
    3980:	dd 1f       	adc	r29, r29
    3982:	aa 1f       	adc	r26, r26
    3984:	bb 1f       	adc	r27, r27
    3986:	8a 14       	cp	r8, r10
    3988:	9b 04       	cpc	r9, r11
    398a:	ec 05       	cpc	r30, r12
    398c:	fd 05       	cpc	r31, r13
    398e:	ce 05       	cpc	r28, r14
    3990:	df 05       	cpc	r29, r15
    3992:	a0 07       	cpc	r26, r16
    3994:	b1 07       	cpc	r27, r17
    3996:	48 f0       	brcs	.+18     	; 0x39aa <__udivmod64+0x90>
    3998:	8a 18       	sub	r8, r10
    399a:	9b 08       	sbc	r9, r11
    399c:	ec 09       	sbc	r30, r12
    399e:	fd 09       	sbc	r31, r13
    39a0:	ce 09       	sbc	r28, r14
    39a2:	df 09       	sbc	r29, r15
    39a4:	a0 0b       	sbc	r26, r16
    39a6:	b1 0b       	sbc	r27, r17
    39a8:	21 60       	ori	r18, 0x01	; 1
    39aa:	1a 94       	dec	r1
    39ac:	e1 f6       	brne	.-72     	; 0x3966 <__udivmod64+0x4c>
    39ae:	2e f4       	brtc	.+10     	; 0x39ba <__udivmod64+0xa0>
    39b0:	94 01       	movw	r18, r8
    39b2:	af 01       	movw	r20, r30
    39b4:	be 01       	movw	r22, r28
    39b6:	cd 01       	movw	r24, r26
    39b8:	00 0c       	add	r0, r0
    39ba:	08 95       	ret

000039bc <__adddi3>:
    39bc:	2a 0d       	add	r18, r10
    39be:	3b 1d       	adc	r19, r11
    39c0:	4c 1d       	adc	r20, r12
    39c2:	5d 1d       	adc	r21, r13
    39c4:	6e 1d       	adc	r22, r14
    39c6:	7f 1d       	adc	r23, r15
    39c8:	80 1f       	adc	r24, r16
    39ca:	91 1f       	adc	r25, r17
    39cc:	08 95       	ret

000039ce <__adddi3_s8>:
    39ce:	00 24       	eor	r0, r0
    39d0:	a7 fd       	sbrc	r26, 7
    39d2:	00 94       	com	r0
    39d4:	2a 0f       	add	r18, r26
    39d6:	30 1d       	adc	r19, r0
    39d8:	40 1d       	adc	r20, r0
    39da:	50 1d       	adc	r21, r0
    39dc:	60 1d       	adc	r22, r0
    39de:	70 1d       	adc	r23, r0
    39e0:	80 1d       	adc	r24, r0
    39e2:	90 1d       	adc	r25, r0
    39e4:	08 95       	ret

000039e6 <__subdi3>:
    39e6:	2a 19       	sub	r18, r10
    39e8:	3b 09       	sbc	r19, r11
    39ea:	4c 09       	sbc	r20, r12
    39ec:	5d 09       	sbc	r21, r13
    39ee:	6e 09       	sbc	r22, r14
    39f0:	7f 09       	sbc	r23, r15
    39f2:	80 0b       	sbc	r24, r16
    39f4:	91 0b       	sbc	r25, r17
    39f6:	08 95       	ret

000039f8 <__cmpdi2>:
    39f8:	2a 15       	cp	r18, r10
    39fa:	3b 05       	cpc	r19, r11
    39fc:	4c 05       	cpc	r20, r12
    39fe:	5d 05       	cpc	r21, r13
    3a00:	6e 05       	cpc	r22, r14
    3a02:	7f 05       	cpc	r23, r15
    3a04:	80 07       	cpc	r24, r16
    3a06:	91 07       	cpc	r25, r17
    3a08:	08 95       	ret

00003a0a <__tablejump2__>:
    3a0a:	ee 0f       	add	r30, r30
    3a0c:	ff 1f       	adc	r31, r31
    3a0e:	05 90       	lpm	r0, Z+
    3a10:	f4 91       	lpm	r31, Z
    3a12:	e0 2d       	mov	r30, r0
    3a14:	09 94       	ijmp

00003a16 <__umulhisi3>:
    3a16:	a2 9f       	mul	r26, r18
    3a18:	b0 01       	movw	r22, r0
    3a1a:	b3 9f       	mul	r27, r19
    3a1c:	c0 01       	movw	r24, r0
    3a1e:	a3 9f       	mul	r26, r19
    3a20:	70 0d       	add	r23, r0
    3a22:	81 1d       	adc	r24, r1
    3a24:	11 24       	eor	r1, r1
    3a26:	91 1d       	adc	r25, r1
    3a28:	b2 9f       	mul	r27, r18
    3a2a:	70 0d       	add	r23, r0
    3a2c:	81 1d       	adc	r24, r1
    3a2e:	11 24       	eor	r1, r1
    3a30:	91 1d       	adc	r25, r1
    3a32:	08 95       	ret

00003a34 <calloc>:
    3a34:	0f 93       	push	r16
    3a36:	1f 93       	push	r17
    3a38:	cf 93       	push	r28
    3a3a:	df 93       	push	r29
    3a3c:	86 9f       	mul	r24, r22
    3a3e:	80 01       	movw	r16, r0
    3a40:	87 9f       	mul	r24, r23
    3a42:	10 0d       	add	r17, r0
    3a44:	96 9f       	mul	r25, r22
    3a46:	10 0d       	add	r17, r0
    3a48:	11 24       	eor	r1, r1
    3a4a:	c8 01       	movw	r24, r16
    3a4c:	0e 94 36 1d 	call	0x3a6c	; 0x3a6c <malloc>
    3a50:	ec 01       	movw	r28, r24
    3a52:	00 97       	sbiw	r24, 0x00	; 0
    3a54:	29 f0       	breq	.+10     	; 0x3a60 <calloc+0x2c>
    3a56:	a8 01       	movw	r20, r16
    3a58:	60 e0       	ldi	r22, 0x00	; 0
    3a5a:	70 e0       	ldi	r23, 0x00	; 0
    3a5c:	0e 94 60 1e 	call	0x3cc0	; 0x3cc0 <memset>
    3a60:	ce 01       	movw	r24, r28
    3a62:	df 91       	pop	r29
    3a64:	cf 91       	pop	r28
    3a66:	1f 91       	pop	r17
    3a68:	0f 91       	pop	r16
    3a6a:	08 95       	ret

00003a6c <malloc>:
    3a6c:	0f 93       	push	r16
    3a6e:	1f 93       	push	r17
    3a70:	cf 93       	push	r28
    3a72:	df 93       	push	r29
    3a74:	82 30       	cpi	r24, 0x02	; 2
    3a76:	91 05       	cpc	r25, r1
    3a78:	10 f4       	brcc	.+4      	; 0x3a7e <malloc+0x12>
    3a7a:	82 e0       	ldi	r24, 0x02	; 2
    3a7c:	90 e0       	ldi	r25, 0x00	; 0
    3a7e:	e0 91 c3 08 	lds	r30, 0x08C3	; 0x8008c3 <__flp>
    3a82:	f0 91 c4 08 	lds	r31, 0x08C4	; 0x8008c4 <__flp+0x1>
    3a86:	20 e0       	ldi	r18, 0x00	; 0
    3a88:	30 e0       	ldi	r19, 0x00	; 0
    3a8a:	a0 e0       	ldi	r26, 0x00	; 0
    3a8c:	b0 e0       	ldi	r27, 0x00	; 0
    3a8e:	30 97       	sbiw	r30, 0x00	; 0
    3a90:	19 f1       	breq	.+70     	; 0x3ad8 <malloc+0x6c>
    3a92:	40 81       	ld	r20, Z
    3a94:	51 81       	ldd	r21, Z+1	; 0x01
    3a96:	02 81       	ldd	r16, Z+2	; 0x02
    3a98:	13 81       	ldd	r17, Z+3	; 0x03
    3a9a:	48 17       	cp	r20, r24
    3a9c:	59 07       	cpc	r21, r25
    3a9e:	c8 f0       	brcs	.+50     	; 0x3ad2 <malloc+0x66>
    3aa0:	84 17       	cp	r24, r20
    3aa2:	95 07       	cpc	r25, r21
    3aa4:	69 f4       	brne	.+26     	; 0x3ac0 <malloc+0x54>
    3aa6:	10 97       	sbiw	r26, 0x00	; 0
    3aa8:	31 f0       	breq	.+12     	; 0x3ab6 <malloc+0x4a>
    3aaa:	12 96       	adiw	r26, 0x02	; 2
    3aac:	0c 93       	st	X, r16
    3aae:	12 97       	sbiw	r26, 0x02	; 2
    3ab0:	13 96       	adiw	r26, 0x03	; 3
    3ab2:	1c 93       	st	X, r17
    3ab4:	27 c0       	rjmp	.+78     	; 0x3b04 <malloc+0x98>
    3ab6:	00 93 c3 08 	sts	0x08C3, r16	; 0x8008c3 <__flp>
    3aba:	10 93 c4 08 	sts	0x08C4, r17	; 0x8008c4 <__flp+0x1>
    3abe:	22 c0       	rjmp	.+68     	; 0x3b04 <malloc+0x98>
    3ac0:	21 15       	cp	r18, r1
    3ac2:	31 05       	cpc	r19, r1
    3ac4:	19 f0       	breq	.+6      	; 0x3acc <malloc+0x60>
    3ac6:	42 17       	cp	r20, r18
    3ac8:	53 07       	cpc	r21, r19
    3aca:	18 f4       	brcc	.+6      	; 0x3ad2 <malloc+0x66>
    3acc:	9a 01       	movw	r18, r20
    3ace:	bd 01       	movw	r22, r26
    3ad0:	ef 01       	movw	r28, r30
    3ad2:	df 01       	movw	r26, r30
    3ad4:	f8 01       	movw	r30, r16
    3ad6:	db cf       	rjmp	.-74     	; 0x3a8e <malloc+0x22>
    3ad8:	21 15       	cp	r18, r1
    3ada:	31 05       	cpc	r19, r1
    3adc:	f9 f0       	breq	.+62     	; 0x3b1c <malloc+0xb0>
    3ade:	28 1b       	sub	r18, r24
    3ae0:	39 0b       	sbc	r19, r25
    3ae2:	24 30       	cpi	r18, 0x04	; 4
    3ae4:	31 05       	cpc	r19, r1
    3ae6:	80 f4       	brcc	.+32     	; 0x3b08 <malloc+0x9c>
    3ae8:	8a 81       	ldd	r24, Y+2	; 0x02
    3aea:	9b 81       	ldd	r25, Y+3	; 0x03
    3aec:	61 15       	cp	r22, r1
    3aee:	71 05       	cpc	r23, r1
    3af0:	21 f0       	breq	.+8      	; 0x3afa <malloc+0x8e>
    3af2:	fb 01       	movw	r30, r22
    3af4:	93 83       	std	Z+3, r25	; 0x03
    3af6:	82 83       	std	Z+2, r24	; 0x02
    3af8:	04 c0       	rjmp	.+8      	; 0x3b02 <malloc+0x96>
    3afa:	90 93 c4 08 	sts	0x08C4, r25	; 0x8008c4 <__flp+0x1>
    3afe:	80 93 c3 08 	sts	0x08C3, r24	; 0x8008c3 <__flp>
    3b02:	fe 01       	movw	r30, r28
    3b04:	32 96       	adiw	r30, 0x02	; 2
    3b06:	44 c0       	rjmp	.+136    	; 0x3b90 <malloc+0x124>
    3b08:	fe 01       	movw	r30, r28
    3b0a:	e2 0f       	add	r30, r18
    3b0c:	f3 1f       	adc	r31, r19
    3b0e:	81 93       	st	Z+, r24
    3b10:	91 93       	st	Z+, r25
    3b12:	22 50       	subi	r18, 0x02	; 2
    3b14:	31 09       	sbc	r19, r1
    3b16:	39 83       	std	Y+1, r19	; 0x01
    3b18:	28 83       	st	Y, r18
    3b1a:	3a c0       	rjmp	.+116    	; 0x3b90 <malloc+0x124>
    3b1c:	20 91 c1 08 	lds	r18, 0x08C1	; 0x8008c1 <__brkval>
    3b20:	30 91 c2 08 	lds	r19, 0x08C2	; 0x8008c2 <__brkval+0x1>
    3b24:	23 2b       	or	r18, r19
    3b26:	41 f4       	brne	.+16     	; 0x3b38 <malloc+0xcc>
    3b28:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    3b2c:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    3b30:	30 93 c2 08 	sts	0x08C2, r19	; 0x8008c2 <__brkval+0x1>
    3b34:	20 93 c1 08 	sts	0x08C1, r18	; 0x8008c1 <__brkval>
    3b38:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
    3b3c:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__DATA_REGION_ORIGIN__+0x1>
    3b40:	21 15       	cp	r18, r1
    3b42:	31 05       	cpc	r19, r1
    3b44:	41 f4       	brne	.+16     	; 0x3b56 <malloc+0xea>
    3b46:	2d b7       	in	r18, 0x3d	; 61
    3b48:	3e b7       	in	r19, 0x3e	; 62
    3b4a:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    3b4e:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    3b52:	24 1b       	sub	r18, r20
    3b54:	35 0b       	sbc	r19, r21
    3b56:	e0 91 c1 08 	lds	r30, 0x08C1	; 0x8008c1 <__brkval>
    3b5a:	f0 91 c2 08 	lds	r31, 0x08C2	; 0x8008c2 <__brkval+0x1>
    3b5e:	e2 17       	cp	r30, r18
    3b60:	f3 07       	cpc	r31, r19
    3b62:	a0 f4       	brcc	.+40     	; 0x3b8c <malloc+0x120>
    3b64:	2e 1b       	sub	r18, r30
    3b66:	3f 0b       	sbc	r19, r31
    3b68:	28 17       	cp	r18, r24
    3b6a:	39 07       	cpc	r19, r25
    3b6c:	78 f0       	brcs	.+30     	; 0x3b8c <malloc+0x120>
    3b6e:	ac 01       	movw	r20, r24
    3b70:	4e 5f       	subi	r20, 0xFE	; 254
    3b72:	5f 4f       	sbci	r21, 0xFF	; 255
    3b74:	24 17       	cp	r18, r20
    3b76:	35 07       	cpc	r19, r21
    3b78:	48 f0       	brcs	.+18     	; 0x3b8c <malloc+0x120>
    3b7a:	4e 0f       	add	r20, r30
    3b7c:	5f 1f       	adc	r21, r31
    3b7e:	50 93 c2 08 	sts	0x08C2, r21	; 0x8008c2 <__brkval+0x1>
    3b82:	40 93 c1 08 	sts	0x08C1, r20	; 0x8008c1 <__brkval>
    3b86:	81 93       	st	Z+, r24
    3b88:	91 93       	st	Z+, r25
    3b8a:	02 c0       	rjmp	.+4      	; 0x3b90 <malloc+0x124>
    3b8c:	e0 e0       	ldi	r30, 0x00	; 0
    3b8e:	f0 e0       	ldi	r31, 0x00	; 0
    3b90:	cf 01       	movw	r24, r30
    3b92:	df 91       	pop	r29
    3b94:	cf 91       	pop	r28
    3b96:	1f 91       	pop	r17
    3b98:	0f 91       	pop	r16
    3b9a:	08 95       	ret

00003b9c <free>:
    3b9c:	cf 93       	push	r28
    3b9e:	df 93       	push	r29
    3ba0:	00 97       	sbiw	r24, 0x00	; 0
    3ba2:	09 f4       	brne	.+2      	; 0x3ba6 <free+0xa>
    3ba4:	81 c0       	rjmp	.+258    	; 0x3ca8 <free+0x10c>
    3ba6:	fc 01       	movw	r30, r24
    3ba8:	32 97       	sbiw	r30, 0x02	; 2
    3baa:	13 82       	std	Z+3, r1	; 0x03
    3bac:	12 82       	std	Z+2, r1	; 0x02
    3bae:	a0 91 c3 08 	lds	r26, 0x08C3	; 0x8008c3 <__flp>
    3bb2:	b0 91 c4 08 	lds	r27, 0x08C4	; 0x8008c4 <__flp+0x1>
    3bb6:	10 97       	sbiw	r26, 0x00	; 0
    3bb8:	81 f4       	brne	.+32     	; 0x3bda <free+0x3e>
    3bba:	20 81       	ld	r18, Z
    3bbc:	31 81       	ldd	r19, Z+1	; 0x01
    3bbe:	82 0f       	add	r24, r18
    3bc0:	93 1f       	adc	r25, r19
    3bc2:	20 91 c1 08 	lds	r18, 0x08C1	; 0x8008c1 <__brkval>
    3bc6:	30 91 c2 08 	lds	r19, 0x08C2	; 0x8008c2 <__brkval+0x1>
    3bca:	28 17       	cp	r18, r24
    3bcc:	39 07       	cpc	r19, r25
    3bce:	51 f5       	brne	.+84     	; 0x3c24 <free+0x88>
    3bd0:	f0 93 c2 08 	sts	0x08C2, r31	; 0x8008c2 <__brkval+0x1>
    3bd4:	e0 93 c1 08 	sts	0x08C1, r30	; 0x8008c1 <__brkval>
    3bd8:	67 c0       	rjmp	.+206    	; 0x3ca8 <free+0x10c>
    3bda:	ed 01       	movw	r28, r26
    3bdc:	20 e0       	ldi	r18, 0x00	; 0
    3bde:	30 e0       	ldi	r19, 0x00	; 0
    3be0:	ce 17       	cp	r28, r30
    3be2:	df 07       	cpc	r29, r31
    3be4:	40 f4       	brcc	.+16     	; 0x3bf6 <free+0x5a>
    3be6:	4a 81       	ldd	r20, Y+2	; 0x02
    3be8:	5b 81       	ldd	r21, Y+3	; 0x03
    3bea:	9e 01       	movw	r18, r28
    3bec:	41 15       	cp	r20, r1
    3bee:	51 05       	cpc	r21, r1
    3bf0:	f1 f0       	breq	.+60     	; 0x3c2e <free+0x92>
    3bf2:	ea 01       	movw	r28, r20
    3bf4:	f5 cf       	rjmp	.-22     	; 0x3be0 <free+0x44>
    3bf6:	d3 83       	std	Z+3, r29	; 0x03
    3bf8:	c2 83       	std	Z+2, r28	; 0x02
    3bfa:	40 81       	ld	r20, Z
    3bfc:	51 81       	ldd	r21, Z+1	; 0x01
    3bfe:	84 0f       	add	r24, r20
    3c00:	95 1f       	adc	r25, r21
    3c02:	c8 17       	cp	r28, r24
    3c04:	d9 07       	cpc	r29, r25
    3c06:	59 f4       	brne	.+22     	; 0x3c1e <free+0x82>
    3c08:	88 81       	ld	r24, Y
    3c0a:	99 81       	ldd	r25, Y+1	; 0x01
    3c0c:	84 0f       	add	r24, r20
    3c0e:	95 1f       	adc	r25, r21
    3c10:	02 96       	adiw	r24, 0x02	; 2
    3c12:	91 83       	std	Z+1, r25	; 0x01
    3c14:	80 83       	st	Z, r24
    3c16:	8a 81       	ldd	r24, Y+2	; 0x02
    3c18:	9b 81       	ldd	r25, Y+3	; 0x03
    3c1a:	93 83       	std	Z+3, r25	; 0x03
    3c1c:	82 83       	std	Z+2, r24	; 0x02
    3c1e:	21 15       	cp	r18, r1
    3c20:	31 05       	cpc	r19, r1
    3c22:	29 f4       	brne	.+10     	; 0x3c2e <free+0x92>
    3c24:	f0 93 c4 08 	sts	0x08C4, r31	; 0x8008c4 <__flp+0x1>
    3c28:	e0 93 c3 08 	sts	0x08C3, r30	; 0x8008c3 <__flp>
    3c2c:	3d c0       	rjmp	.+122    	; 0x3ca8 <free+0x10c>
    3c2e:	e9 01       	movw	r28, r18
    3c30:	fb 83       	std	Y+3, r31	; 0x03
    3c32:	ea 83       	std	Y+2, r30	; 0x02
    3c34:	49 91       	ld	r20, Y+
    3c36:	59 91       	ld	r21, Y+
    3c38:	c4 0f       	add	r28, r20
    3c3a:	d5 1f       	adc	r29, r21
    3c3c:	ec 17       	cp	r30, r28
    3c3e:	fd 07       	cpc	r31, r29
    3c40:	61 f4       	brne	.+24     	; 0x3c5a <free+0xbe>
    3c42:	80 81       	ld	r24, Z
    3c44:	91 81       	ldd	r25, Z+1	; 0x01
    3c46:	84 0f       	add	r24, r20
    3c48:	95 1f       	adc	r25, r21
    3c4a:	02 96       	adiw	r24, 0x02	; 2
    3c4c:	e9 01       	movw	r28, r18
    3c4e:	99 83       	std	Y+1, r25	; 0x01
    3c50:	88 83       	st	Y, r24
    3c52:	82 81       	ldd	r24, Z+2	; 0x02
    3c54:	93 81       	ldd	r25, Z+3	; 0x03
    3c56:	9b 83       	std	Y+3, r25	; 0x03
    3c58:	8a 83       	std	Y+2, r24	; 0x02
    3c5a:	e0 e0       	ldi	r30, 0x00	; 0
    3c5c:	f0 e0       	ldi	r31, 0x00	; 0
    3c5e:	12 96       	adiw	r26, 0x02	; 2
    3c60:	8d 91       	ld	r24, X+
    3c62:	9c 91       	ld	r25, X
    3c64:	13 97       	sbiw	r26, 0x03	; 3
    3c66:	00 97       	sbiw	r24, 0x00	; 0
    3c68:	19 f0       	breq	.+6      	; 0x3c70 <free+0xd4>
    3c6a:	fd 01       	movw	r30, r26
    3c6c:	dc 01       	movw	r26, r24
    3c6e:	f7 cf       	rjmp	.-18     	; 0x3c5e <free+0xc2>
    3c70:	8d 91       	ld	r24, X+
    3c72:	9c 91       	ld	r25, X
    3c74:	11 97       	sbiw	r26, 0x01	; 1
    3c76:	9d 01       	movw	r18, r26
    3c78:	2e 5f       	subi	r18, 0xFE	; 254
    3c7a:	3f 4f       	sbci	r19, 0xFF	; 255
    3c7c:	82 0f       	add	r24, r18
    3c7e:	93 1f       	adc	r25, r19
    3c80:	20 91 c1 08 	lds	r18, 0x08C1	; 0x8008c1 <__brkval>
    3c84:	30 91 c2 08 	lds	r19, 0x08C2	; 0x8008c2 <__brkval+0x1>
    3c88:	28 17       	cp	r18, r24
    3c8a:	39 07       	cpc	r19, r25
    3c8c:	69 f4       	brne	.+26     	; 0x3ca8 <free+0x10c>
    3c8e:	30 97       	sbiw	r30, 0x00	; 0
    3c90:	29 f4       	brne	.+10     	; 0x3c9c <free+0x100>
    3c92:	10 92 c4 08 	sts	0x08C4, r1	; 0x8008c4 <__flp+0x1>
    3c96:	10 92 c3 08 	sts	0x08C3, r1	; 0x8008c3 <__flp>
    3c9a:	02 c0       	rjmp	.+4      	; 0x3ca0 <free+0x104>
    3c9c:	13 82       	std	Z+3, r1	; 0x03
    3c9e:	12 82       	std	Z+2, r1	; 0x02
    3ca0:	b0 93 c2 08 	sts	0x08C2, r27	; 0x8008c2 <__brkval+0x1>
    3ca4:	a0 93 c1 08 	sts	0x08C1, r26	; 0x8008c1 <__brkval>
    3ca8:	df 91       	pop	r29
    3caa:	cf 91       	pop	r28
    3cac:	08 95       	ret

00003cae <memcpy>:
    3cae:	fb 01       	movw	r30, r22
    3cb0:	dc 01       	movw	r26, r24
    3cb2:	02 c0       	rjmp	.+4      	; 0x3cb8 <memcpy+0xa>
    3cb4:	01 90       	ld	r0, Z+
    3cb6:	0d 92       	st	X+, r0
    3cb8:	41 50       	subi	r20, 0x01	; 1
    3cba:	50 40       	sbci	r21, 0x00	; 0
    3cbc:	d8 f7       	brcc	.-10     	; 0x3cb4 <memcpy+0x6>
    3cbe:	08 95       	ret

00003cc0 <memset>:
    3cc0:	dc 01       	movw	r26, r24
    3cc2:	01 c0       	rjmp	.+2      	; 0x3cc6 <memset+0x6>
    3cc4:	6d 93       	st	X+, r22
    3cc6:	41 50       	subi	r20, 0x01	; 1
    3cc8:	50 40       	sbci	r21, 0x00	; 0
    3cca:	e0 f7       	brcc	.-8      	; 0x3cc4 <memset+0x4>
    3ccc:	08 95       	ret

00003cce <eeprom_read_block>:
    3cce:	dc 01       	movw	r26, r24
    3cd0:	cb 01       	movw	r24, r22

00003cd2 <eeprom_read_blraw>:
    3cd2:	fc 01       	movw	r30, r24
    3cd4:	f9 99       	sbic	0x1f, 1	; 31
    3cd6:	fe cf       	rjmp	.-4      	; 0x3cd4 <eeprom_read_blraw+0x2>
    3cd8:	06 c0       	rjmp	.+12     	; 0x3ce6 <eeprom_read_blraw+0x14>
    3cda:	f2 bd       	out	0x22, r31	; 34
    3cdc:	e1 bd       	out	0x21, r30	; 33
    3cde:	f8 9a       	sbi	0x1f, 0	; 31
    3ce0:	31 96       	adiw	r30, 0x01	; 1
    3ce2:	00 b4       	in	r0, 0x20	; 32
    3ce4:	0d 92       	st	X+, r0
    3ce6:	41 50       	subi	r20, 0x01	; 1
    3ce8:	50 40       	sbci	r21, 0x00	; 0
    3cea:	b8 f7       	brcc	.-18     	; 0x3cda <eeprom_read_blraw+0x8>
    3cec:	08 95       	ret

00003cee <_exit>:
    3cee:	f8 94       	cli

00003cf0 <__stop_program>:
    3cf0:	ff cf       	rjmp	.-2      	; 0x3cf0 <__stop_program>
