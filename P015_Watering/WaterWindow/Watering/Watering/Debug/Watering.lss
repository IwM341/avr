
Watering.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000032  00800100  0000133e  000013d2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000133e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006e7  00800132  00800132  00001404  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001404  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001434  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000388  00000000  00000000  00001474  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000588b  00000000  00000000  000017fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001849  00000000  00000000  00007087  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000023bd  00000000  00000000  000088d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000ac4  00000000  00000000  0000ac90  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001e69  00000000  00000000  0000b754  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003d6c  00000000  00000000  0000d5bd  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000398  00000000  00000000  00011329  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 35 00 	jmp	0x6a	; 0x6a <__ctors_end>
       4:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
       8:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
       c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      10:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      14:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      18:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      1c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      20:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      24:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      28:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      2c:	0c 94 a1 06 	jmp	0xd42	; 0xd42 <__vector_11>
      30:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      34:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      38:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      3c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      40:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      44:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      48:	0c 94 9c 08 	jmp	0x1138	; 0x1138 <__vector_18>
      4c:	0c 94 d4 08 	jmp	0x11a8	; 0x11a8 <__vector_19>
      50:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      54:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      58:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      5c:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      60:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>
      64:	0c 94 5d 00 	jmp	0xba	; 0xba <__bad_interrupt>

00000068 <__ctors_start>:
      68:	18 09       	sbc	r17, r8

0000006a <__ctors_end>:
      6a:	11 24       	eor	r1, r1
      6c:	1f be       	out	0x3f, r1	; 63
      6e:	cf ef       	ldi	r28, 0xFF	; 255
      70:	d8 e0       	ldi	r29, 0x08	; 8
      72:	de bf       	out	0x3e, r29	; 62
      74:	cd bf       	out	0x3d, r28	; 61

00000076 <__do_copy_data>:
      76:	11 e0       	ldi	r17, 0x01	; 1
      78:	a0 e0       	ldi	r26, 0x00	; 0
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	ee e3       	ldi	r30, 0x3E	; 62
      7e:	f3 e1       	ldi	r31, 0x13	; 19
      80:	02 c0       	rjmp	.+4      	; 0x86 <__do_copy_data+0x10>
      82:	05 90       	lpm	r0, Z+
      84:	0d 92       	st	X+, r0
      86:	a2 33       	cpi	r26, 0x32	; 50
      88:	b1 07       	cpc	r27, r17
      8a:	d9 f7       	brne	.-10     	; 0x82 <__do_copy_data+0xc>

0000008c <__do_clear_bss>:
      8c:	28 e0       	ldi	r18, 0x08	; 8
      8e:	a2 e3       	ldi	r26, 0x32	; 50
      90:	b1 e0       	ldi	r27, 0x01	; 1
      92:	01 c0       	rjmp	.+2      	; 0x96 <.do_clear_bss_start>

00000094 <.do_clear_bss_loop>:
      94:	1d 92       	st	X+, r1

00000096 <.do_clear_bss_start>:
      96:	a9 31       	cpi	r26, 0x19	; 25
      98:	b2 07       	cpc	r27, r18
      9a:	e1 f7       	brne	.-8      	; 0x94 <.do_clear_bss_loop>

0000009c <__do_global_ctors>:
      9c:	10 e0       	ldi	r17, 0x00	; 0
      9e:	c5 e3       	ldi	r28, 0x35	; 53
      a0:	d0 e0       	ldi	r29, 0x00	; 0
      a2:	04 c0       	rjmp	.+8      	; 0xac <__do_global_ctors+0x10>
      a4:	21 97       	sbiw	r28, 0x01	; 1
      a6:	fe 01       	movw	r30, r28
      a8:	0e 94 97 09 	call	0x132e	; 0x132e <__tablejump2__>
      ac:	c4 33       	cpi	r28, 0x34	; 52
      ae:	d1 07       	cpc	r29, r17
      b0:	c9 f7       	brne	.-14     	; 0xa4 <__do_global_ctors+0x8>
      b2:	0e 94 8d 00 	call	0x11a	; 0x11a <main>
      b6:	0c 94 9d 09 	jmp	0x133a	; 0x133a <_exit>

000000ba <__bad_interrupt>:
      ba:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000be <_ZL14vLEDBlink_taskPv>:
#include "../FreeRTOS/task.h"
#include "include/ports.h"
#include "../Uart/HardwareSerial.h"
#include "global.h"
#include <avr/interrupt.h>
static void vLEDBlink_task(void *) {
      be:	cf 93       	push	r28
      c0:	df 93       	push	r29
      c2:	00 d0       	rcall	.+0      	; 0xc4 <_ZL14vLEDBlink_taskPv+0x6>
      c4:	cd b7       	in	r28, 0x3d	; 61
      c6:	de b7       	in	r29, 0x3e	; 62
			set_mode(PinMode_t{});
		}
		
		template <typename PinMode_t = InputMode_tag>
		inline void set_mode(PinMode_t){
			if (Std::is_same_v<PinMode_t,OutputMode_tag>){
      c8:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
      cc:	88 23       	and	r24, r24
      ce:	21 f0       	breq	.+8      	; 0xd8 <_ZL14vLEDBlink_taskPv+0x1a>
#define PIN_MASK_12 0b00010000
#define PIN_MASK_13 0b00100000

inline void set_port_bit(volatile uint8_t & _port,uint8_t bit_num,uint8_t value){
	if(value){
		_port |= (1<<bit_num);
      d0:	8a b1       	in	r24, 0x0a	; 10
      d2:	80 68       	ori	r24, 0x80	; 128
      d4:	8a b9       	out	0x0a, r24	; 10
      d6:	03 c0       	rjmp	.+6      	; 0xde <_ZL14vLEDBlink_taskPv+0x20>
	} else {
		_port &= ~(1<<bit_num);
      d8:	8a b1       	in	r24, 0x0a	; 10
      da:	8f 77       	andi	r24, 0x7F	; 127
      dc:	8a b9       	out	0x0a, r24	; 10
	
		
	pins::pin<7> m_pin(pins::OutputMode);
	
	TickType_t xNextWakeTime = xTaskGetTickCount();
      de:	0e 94 5f 02 	call	0x4be	; 0x4be <xTaskGetTickCount>
      e2:	9a 83       	std	Y+2, r25	; 0x02
      e4:	89 83       	std	Y+1, r24	; 0x01
	  
	inline void set_f_cpu(uint_least32_t n_f_cpu = SERIAL_F_CPU){
		_f_cpu = n_f_cpu;
	}
	
    inline void begin(unsigned long baud) { begin(baud, SERIAL_8N1); }
      e6:	26 e0       	ldi	r18, 0x06	; 6
      e8:	44 e7       	ldi	r20, 0x74	; 116
      ea:	57 eb       	ldi	r21, 0xB7	; 183
      ec:	61 e0       	ldi	r22, 0x01	; 1
      ee:	70 e0       	ldi	r23, 0x00	; 0
      f0:	88 e7       	ldi	r24, 0x78	; 120
      f2:	97 e0       	ldi	r25, 0x07	; 7
      f4:	0e 94 cf 07 	call	0xf9e	; 0xf9e <_ZN14HardwareSerial5beginEmh>
	const int delayTime = 1000;
	Serial.begin(112500);
	for(;;) {
		int tmp_t = xTaskGetTickCount();
      f8:	0e 94 5f 02 	call	0x4be	; 0x4be <xTaskGetTickCount>
		PORTB = ~PORTB;
      fc:	85 b1       	in	r24, 0x05	; 5
      fe:	80 95       	com	r24
     100:	85 b9       	out	0x05, r24	; 5
		vTaskDelayUntil(&xNextWakeTime, delayTime);
     102:	68 ee       	ldi	r22, 0xE8	; 232
     104:	73 e0       	ldi	r23, 0x03	; 3
     106:	ce 01       	movw	r24, r28
     108:	01 96       	adiw	r24, 0x01	; 1
     10a:	0e 94 a3 03 	call	0x746	; 0x746 <vTaskDelayUntil>
		Serial.println('i');
     10e:	69 e6       	ldi	r22, 0x69	; 105
     110:	88 e7       	ldi	r24, 0x78	; 120
     112:	97 e0       	ldi	r25, 0x07	; 7
     114:	0e 94 63 09 	call	0x12c6	; 0x12c6 <_ZN5Print7printlnEc>
     118:	ef cf       	rjmp	.-34     	; 0xf8 <_ZL14vLEDBlink_taskPv+0x3a>

0000011a <main>:
	}
}

int main(void)
{
     11a:	cf 93       	push	r28
     11c:	df 93       	push	r29
     11e:	00 d0       	rcall	.+0      	; 0x120 <main+0x6>
     120:	00 d0       	rcall	.+0      	; 0x122 <main+0x8>
     122:	cd b7       	in	r28, 0x3d	; 61
     124:	de b7       	in	r29, 0x3e	; 62
	volatile uint32_t x = __cplusplus;
     126:	8a eb       	ldi	r24, 0xBA	; 186
     128:	92 e1       	ldi	r25, 0x12	; 18
     12a:	a3 e0       	ldi	r26, 0x03	; 3
     12c:	b0 e0       	ldi	r27, 0x00	; 0
     12e:	89 83       	std	Y+1, r24	; 0x01
     130:	9a 83       	std	Y+2, r25	; 0x02
     132:	ab 83       	std	Y+3, r26	; 0x03
     134:	bc 83       	std	Y+4, r27	; 0x04
    xTaskCreate(vLEDBlink_task, "LED Blink", configMINIMAL_STACK_SIZE, NULL, 1, NULL);
     136:	e1 2c       	mov	r14, r1
     138:	f1 2c       	mov	r15, r1
     13a:	01 e0       	ldi	r16, 0x01	; 1
     13c:	20 e0       	ldi	r18, 0x00	; 0
     13e:	30 e0       	ldi	r19, 0x00	; 0
     140:	45 e5       	ldi	r20, 0x55	; 85
     142:	50 e0       	ldi	r21, 0x00	; 0
     144:	61 e0       	ldi	r22, 0x01	; 1
     146:	71 e0       	ldi	r23, 0x01	; 1
     148:	8f e5       	ldi	r24, 0x5F	; 95
     14a:	90 e0       	ldi	r25, 0x00	; 0
     14c:	0e 94 22 01 	call	0x244	; 0x244 <xTaskCreate>
	
	vTaskStartScheduler();
     150:	0e 94 2f 02 	call	0x45e	; 0x45e <vTaskStartScheduler>
     154:	ff cf       	rjmp	.-2      	; 0x154 <main+0x3a>

00000156 <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     156:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <pxDelayedTaskList>
     15a:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <pxDelayedTaskList+0x1>
     15e:	80 81       	ld	r24, Z
     160:	81 11       	cpse	r24, r1
     162:	07 c0       	rjmp	.+14     	; 0x172 <prvResetNextTaskUnblockTime+0x1c>
     164:	8f ef       	ldi	r24, 0xFF	; 255
     166:	9f ef       	ldi	r25, 0xFF	; 255
     168:	90 93 36 01 	sts	0x0136, r25	; 0x800136 <xNextTaskUnblockTime+0x1>
     16c:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <xNextTaskUnblockTime>
     170:	08 95       	ret
     172:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <pxDelayedTaskList>
     176:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <pxDelayedTaskList+0x1>
     17a:	05 80       	ldd	r0, Z+5	; 0x05
     17c:	f6 81       	ldd	r31, Z+6	; 0x06
     17e:	e0 2d       	mov	r30, r0
     180:	06 80       	ldd	r0, Z+6	; 0x06
     182:	f7 81       	ldd	r31, Z+7	; 0x07
     184:	e0 2d       	mov	r30, r0
     186:	82 81       	ldd	r24, Z+2	; 0x02
     188:	93 81       	ldd	r25, Z+3	; 0x03
     18a:	90 93 36 01 	sts	0x0136, r25	; 0x800136 <xNextTaskUnblockTime+0x1>
     18e:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <xNextTaskUnblockTime>
     192:	08 95       	ret

00000194 <prvAddCurrentTaskToDelayedList>:
     194:	ff 92       	push	r15
     196:	0f 93       	push	r16
     198:	1f 93       	push	r17
     19a:	cf 93       	push	r28
     19c:	df 93       	push	r29
     19e:	ec 01       	movw	r28, r24
     1a0:	f6 2e       	mov	r15, r22
     1a2:	00 91 3d 01 	lds	r16, 0x013D	; 0x80013d <xTickCount>
     1a6:	10 91 3e 01 	lds	r17, 0x013E	; 0x80013e <xTickCount+0x1>
     1aa:	80 91 96 01 	lds	r24, 0x0196	; 0x800196 <pxCurrentTCB>
     1ae:	90 91 97 01 	lds	r25, 0x0197	; 0x800197 <pxCurrentTCB+0x1>
     1b2:	02 96       	adiw	r24, 0x02	; 2
     1b4:	0e 94 1e 05 	call	0xa3c	; 0xa3c <uxListRemove>
     1b8:	cf 3f       	cpi	r28, 0xFF	; 255
     1ba:	8f ef       	ldi	r24, 0xFF	; 255
     1bc:	d8 07       	cpc	r29, r24
     1be:	69 f4       	brne	.+26     	; 0x1da <prvAddCurrentTaskToDelayedList+0x46>
     1c0:	ff 20       	and	r15, r15
     1c2:	59 f0       	breq	.+22     	; 0x1da <prvAddCurrentTaskToDelayedList+0x46>
     1c4:	60 91 96 01 	lds	r22, 0x0196	; 0x800196 <pxCurrentTCB>
     1c8:	70 91 97 01 	lds	r23, 0x0197	; 0x800197 <pxCurrentTCB+0x1>
     1cc:	6e 5f       	subi	r22, 0xFE	; 254
     1ce:	7f 4f       	sbci	r23, 0xFF	; 255
     1d0:	80 e4       	ldi	r24, 0x40	; 64
     1d2:	91 e0       	ldi	r25, 0x01	; 1
     1d4:	0e 94 cc 04 	call	0x998	; 0x998 <vListInsertEnd>
     1d8:	2f c0       	rjmp	.+94     	; 0x238 <prvAddCurrentTaskToDelayedList+0xa4>
     1da:	c0 0f       	add	r28, r16
     1dc:	d1 1f       	adc	r29, r17
     1de:	e0 91 96 01 	lds	r30, 0x0196	; 0x800196 <pxCurrentTCB>
     1e2:	f0 91 97 01 	lds	r31, 0x0197	; 0x800197 <pxCurrentTCB+0x1>
     1e6:	d3 83       	std	Z+3, r29	; 0x03
     1e8:	c2 83       	std	Z+2, r28	; 0x02
     1ea:	c0 17       	cp	r28, r16
     1ec:	d1 07       	cpc	r29, r17
     1ee:	68 f4       	brcc	.+26     	; 0x20a <prvAddCurrentTaskToDelayedList+0x76>
     1f0:	60 91 96 01 	lds	r22, 0x0196	; 0x800196 <pxCurrentTCB>
     1f4:	70 91 97 01 	lds	r23, 0x0197	; 0x800197 <pxCurrentTCB+0x1>
     1f8:	80 91 5c 01 	lds	r24, 0x015C	; 0x80015c <pxOverflowDelayedTaskList>
     1fc:	90 91 5d 01 	lds	r25, 0x015D	; 0x80015d <pxOverflowDelayedTaskList+0x1>
     200:	6e 5f       	subi	r22, 0xFE	; 254
     202:	7f 4f       	sbci	r23, 0xFF	; 255
     204:	0e 94 ed 04 	call	0x9da	; 0x9da <vListInsert>
     208:	17 c0       	rjmp	.+46     	; 0x238 <prvAddCurrentTaskToDelayedList+0xa4>
     20a:	60 91 96 01 	lds	r22, 0x0196	; 0x800196 <pxCurrentTCB>
     20e:	70 91 97 01 	lds	r23, 0x0197	; 0x800197 <pxCurrentTCB+0x1>
     212:	80 91 5e 01 	lds	r24, 0x015E	; 0x80015e <pxDelayedTaskList>
     216:	90 91 5f 01 	lds	r25, 0x015F	; 0x80015f <pxDelayedTaskList+0x1>
     21a:	6e 5f       	subi	r22, 0xFE	; 254
     21c:	7f 4f       	sbci	r23, 0xFF	; 255
     21e:	0e 94 ed 04 	call	0x9da	; 0x9da <vListInsert>
     222:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <xNextTaskUnblockTime>
     226:	90 91 36 01 	lds	r25, 0x0136	; 0x800136 <xNextTaskUnblockTime+0x1>
     22a:	c8 17       	cp	r28, r24
     22c:	d9 07       	cpc	r29, r25
     22e:	20 f4       	brcc	.+8      	; 0x238 <prvAddCurrentTaskToDelayedList+0xa4>
     230:	d0 93 36 01 	sts	0x0136, r29	; 0x800136 <xNextTaskUnblockTime+0x1>
     234:	c0 93 35 01 	sts	0x0135, r28	; 0x800135 <xNextTaskUnblockTime>
     238:	df 91       	pop	r29
     23a:	cf 91       	pop	r28
     23c:	1f 91       	pop	r17
     23e:	0f 91       	pop	r16
     240:	ff 90       	pop	r15
     242:	08 95       	ret

00000244 <xTaskCreate>:
     244:	4f 92       	push	r4
     246:	5f 92       	push	r5
     248:	6f 92       	push	r6
     24a:	7f 92       	push	r7
     24c:	8f 92       	push	r8
     24e:	9f 92       	push	r9
     250:	af 92       	push	r10
     252:	bf 92       	push	r11
     254:	cf 92       	push	r12
     256:	df 92       	push	r13
     258:	ef 92       	push	r14
     25a:	ff 92       	push	r15
     25c:	0f 93       	push	r16
     25e:	cf 93       	push	r28
     260:	df 93       	push	r29
     262:	4c 01       	movw	r8, r24
     264:	6b 01       	movw	r12, r22
     266:	5a 01       	movw	r10, r20
     268:	29 01       	movw	r4, r18
     26a:	ca 01       	movw	r24, r20
     26c:	0e 94 84 04 	call	0x908	; 0x908 <pvPortMalloc>
     270:	3c 01       	movw	r6, r24
     272:	89 2b       	or	r24, r25
     274:	09 f4       	brne	.+2      	; 0x278 <xTaskCreate+0x34>
     276:	e2 c0       	rjmp	.+452    	; 0x43c <__EEPROM_REGION_LENGTH__+0x3c>
     278:	86 e2       	ldi	r24, 0x26	; 38
     27a:	90 e0       	ldi	r25, 0x00	; 0
     27c:	0e 94 84 04 	call	0x908	; 0x908 <pvPortMalloc>
     280:	ec 01       	movw	r28, r24
     282:	89 2b       	or	r24, r25
     284:	71 f0       	breq	.+28     	; 0x2a2 <xTaskCreate+0x5e>
     286:	78 8e       	std	Y+24, r7	; 0x18
     288:	6f 8a       	std	Y+23, r6	; 0x17
     28a:	81 e0       	ldi	r24, 0x01	; 1
     28c:	a8 1a       	sub	r10, r24
     28e:	b1 08       	sbc	r11, r1
     290:	a6 0c       	add	r10, r6
     292:	b7 1c       	adc	r11, r7
     294:	d6 01       	movw	r26, r12
     296:	8c 91       	ld	r24, X
     298:	89 8f       	std	Y+25, r24	; 0x19
     29a:	8c 91       	ld	r24, X
     29c:	81 11       	cpse	r24, r1
     29e:	05 c0       	rjmp	.+10     	; 0x2aa <xTaskCreate+0x66>
     2a0:	18 c0       	rjmp	.+48     	; 0x2d2 <xTaskCreate+0x8e>
     2a2:	c3 01       	movw	r24, r6
     2a4:	0e 94 b9 04 	call	0x972	; 0x972 <vPortFree>
     2a8:	c9 c0       	rjmp	.+402    	; 0x43c <__EEPROM_REGION_LENGTH__+0x3c>
     2aa:	ae 01       	movw	r20, r28
     2ac:	46 5e       	subi	r20, 0xE6	; 230
     2ae:	5f 4f       	sbci	r21, 0xFF	; 255
     2b0:	f6 01       	movw	r30, r12
     2b2:	31 96       	adiw	r30, 0x01	; 1
     2b4:	b8 e0       	ldi	r27, 0x08	; 8
     2b6:	cb 0e       	add	r12, r27
     2b8:	d1 1c       	adc	r13, r1
     2ba:	cf 01       	movw	r24, r30
     2bc:	21 91       	ld	r18, Z+
     2be:	da 01       	movw	r26, r20
     2c0:	2d 93       	st	X+, r18
     2c2:	ad 01       	movw	r20, r26
     2c4:	dc 01       	movw	r26, r24
     2c6:	8c 91       	ld	r24, X
     2c8:	88 23       	and	r24, r24
     2ca:	19 f0       	breq	.+6      	; 0x2d2 <xTaskCreate+0x8e>
     2cc:	ec 15       	cp	r30, r12
     2ce:	fd 05       	cpc	r31, r13
     2d0:	a1 f7       	brne	.-24     	; 0x2ba <xTaskCreate+0x76>
     2d2:	18 a2       	std	Y+32, r1	; 0x20
     2d4:	04 30       	cpi	r16, 0x04	; 4
     2d6:	08 f0       	brcs	.+2      	; 0x2da <xTaskCreate+0x96>
     2d8:	03 e0       	ldi	r16, 0x03	; 3
     2da:	0e 8b       	std	Y+22, r16	; 0x16
     2dc:	6e 01       	movw	r12, r28
     2de:	b2 e0       	ldi	r27, 0x02	; 2
     2e0:	cb 0e       	add	r12, r27
     2e2:	d1 1c       	adc	r13, r1
     2e4:	c6 01       	movw	r24, r12
     2e6:	0e 94 c8 04 	call	0x990	; 0x990 <vListInitialiseItem>
     2ea:	ce 01       	movw	r24, r28
     2ec:	0c 96       	adiw	r24, 0x0c	; 12
     2ee:	0e 94 c8 04 	call	0x990	; 0x990 <vListInitialiseItem>
     2f2:	d9 87       	std	Y+9, r29	; 0x09
     2f4:	c8 87       	std	Y+8, r28	; 0x08
     2f6:	84 e0       	ldi	r24, 0x04	; 4
     2f8:	90 e0       	ldi	r25, 0x00	; 0
     2fa:	80 1b       	sub	r24, r16
     2fc:	91 09       	sbc	r25, r1
     2fe:	9d 87       	std	Y+13, r25	; 0x0d
     300:	8c 87       	std	Y+12, r24	; 0x0c
     302:	db 8b       	std	Y+19, r29	; 0x13
     304:	ca 8b       	std	Y+18, r28	; 0x12
     306:	19 a2       	std	Y+33, r1	; 0x21
     308:	1a a2       	std	Y+34, r1	; 0x22
     30a:	1b a2       	std	Y+35, r1	; 0x23
     30c:	1c a2       	std	Y+36, r1	; 0x24
     30e:	1d a2       	std	Y+37, r1	; 0x25
     310:	a2 01       	movw	r20, r4
     312:	b4 01       	movw	r22, r8
     314:	c5 01       	movw	r24, r10
     316:	0e 94 44 05 	call	0xa88	; 0xa88 <pxPortInitialiseStack>
     31a:	99 83       	std	Y+1, r25	; 0x01
     31c:	88 83       	st	Y, r24
     31e:	e1 14       	cp	r14, r1
     320:	f1 04       	cpc	r15, r1
     322:	19 f0       	breq	.+6      	; 0x32a <xTaskCreate+0xe6>
     324:	f7 01       	movw	r30, r14
     326:	d1 83       	std	Z+1, r29	; 0x01
     328:	c0 83       	st	Z, r28
     32a:	0f b6       	in	r0, 0x3f	; 63
     32c:	f8 94       	cli
     32e:	0f 92       	push	r0
     330:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <uxCurrentNumberOfTasks>
     334:	8f 5f       	subi	r24, 0xFF	; 255
     336:	80 93 3f 01 	sts	0x013F, r24	; 0x80013f <uxCurrentNumberOfTasks>
     33a:	80 91 96 01 	lds	r24, 0x0196	; 0x800196 <pxCurrentTCB>
     33e:	90 91 97 01 	lds	r25, 0x0197	; 0x800197 <pxCurrentTCB+0x1>
     342:	89 2b       	or	r24, r25
     344:	d1 f5       	brne	.+116    	; 0x3ba <xTaskCreate+0x176>
     346:	d0 93 97 01 	sts	0x0197, r29	; 0x800197 <pxCurrentTCB+0x1>
     34a:	c0 93 96 01 	sts	0x0196, r28	; 0x800196 <pxCurrentTCB>
     34e:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <uxCurrentNumberOfTasks>
     352:	81 30       	cpi	r24, 0x01	; 1
     354:	09 f0       	breq	.+2      	; 0x358 <xTaskCreate+0x114>
     356:	41 c0       	rjmp	.+130    	; 0x3da <xTaskCreate+0x196>
     358:	82 e7       	ldi	r24, 0x72	; 114
     35a:	91 e0       	ldi	r25, 0x01	; 1
     35c:	0e 94 ba 04 	call	0x974	; 0x974 <vListInitialise>
     360:	8b e7       	ldi	r24, 0x7B	; 123
     362:	91 e0       	ldi	r25, 0x01	; 1
     364:	0e 94 ba 04 	call	0x974	; 0x974 <vListInitialise>
     368:	84 e8       	ldi	r24, 0x84	; 132
     36a:	91 e0       	ldi	r25, 0x01	; 1
     36c:	0e 94 ba 04 	call	0x974	; 0x974 <vListInitialise>
     370:	8d e8       	ldi	r24, 0x8D	; 141
     372:	91 e0       	ldi	r25, 0x01	; 1
     374:	0e 94 ba 04 	call	0x974	; 0x974 <vListInitialise>
     378:	89 e6       	ldi	r24, 0x69	; 105
     37a:	91 e0       	ldi	r25, 0x01	; 1
     37c:	0e 94 ba 04 	call	0x974	; 0x974 <vListInitialise>
     380:	80 e6       	ldi	r24, 0x60	; 96
     382:	91 e0       	ldi	r25, 0x01	; 1
     384:	0e 94 ba 04 	call	0x974	; 0x974 <vListInitialise>
     388:	83 e5       	ldi	r24, 0x53	; 83
     38a:	91 e0       	ldi	r25, 0x01	; 1
     38c:	0e 94 ba 04 	call	0x974	; 0x974 <vListInitialise>
     390:	8a e4       	ldi	r24, 0x4A	; 74
     392:	91 e0       	ldi	r25, 0x01	; 1
     394:	0e 94 ba 04 	call	0x974	; 0x974 <vListInitialise>
     398:	80 e4       	ldi	r24, 0x40	; 64
     39a:	91 e0       	ldi	r25, 0x01	; 1
     39c:	0e 94 ba 04 	call	0x974	; 0x974 <vListInitialise>
     3a0:	89 e6       	ldi	r24, 0x69	; 105
     3a2:	91 e0       	ldi	r25, 0x01	; 1
     3a4:	90 93 5f 01 	sts	0x015F, r25	; 0x80015f <pxDelayedTaskList+0x1>
     3a8:	80 93 5e 01 	sts	0x015E, r24	; 0x80015e <pxDelayedTaskList>
     3ac:	80 e6       	ldi	r24, 0x60	; 96
     3ae:	91 e0       	ldi	r25, 0x01	; 1
     3b0:	90 93 5d 01 	sts	0x015D, r25	; 0x80015d <pxOverflowDelayedTaskList+0x1>
     3b4:	80 93 5c 01 	sts	0x015C, r24	; 0x80015c <pxOverflowDelayedTaskList>
     3b8:	10 c0       	rjmp	.+32     	; 0x3da <xTaskCreate+0x196>
     3ba:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <xSchedulerRunning>
     3be:	81 11       	cpse	r24, r1
     3c0:	0c c0       	rjmp	.+24     	; 0x3da <xTaskCreate+0x196>
     3c2:	e0 91 96 01 	lds	r30, 0x0196	; 0x800196 <pxCurrentTCB>
     3c6:	f0 91 97 01 	lds	r31, 0x0197	; 0x800197 <pxCurrentTCB+0x1>
     3ca:	96 89       	ldd	r25, Z+22	; 0x16
     3cc:	8e 89       	ldd	r24, Y+22	; 0x16
     3ce:	89 17       	cp	r24, r25
     3d0:	20 f0       	brcs	.+8      	; 0x3da <xTaskCreate+0x196>
     3d2:	d0 93 97 01 	sts	0x0197, r29	; 0x800197 <pxCurrentTCB+0x1>
     3d6:	c0 93 96 01 	sts	0x0196, r28	; 0x800196 <pxCurrentTCB>
     3da:	80 91 37 01 	lds	r24, 0x0137	; 0x800137 <uxTaskNumber>
     3de:	8f 5f       	subi	r24, 0xFF	; 255
     3e0:	80 93 37 01 	sts	0x0137, r24	; 0x800137 <uxTaskNumber>
     3e4:	8e 89       	ldd	r24, Y+22	; 0x16
     3e6:	90 91 3c 01 	lds	r25, 0x013C	; 0x80013c <uxTopReadyPriority>
     3ea:	98 17       	cp	r25, r24
     3ec:	10 f4       	brcc	.+4      	; 0x3f2 <xTaskCreate+0x1ae>
     3ee:	80 93 3c 01 	sts	0x013C, r24	; 0x80013c <uxTopReadyPriority>
     3f2:	90 e0       	ldi	r25, 0x00	; 0
     3f4:	9c 01       	movw	r18, r24
     3f6:	22 0f       	add	r18, r18
     3f8:	33 1f       	adc	r19, r19
     3fa:	22 0f       	add	r18, r18
     3fc:	33 1f       	adc	r19, r19
     3fe:	22 0f       	add	r18, r18
     400:	33 1f       	adc	r19, r19
     402:	82 0f       	add	r24, r18
     404:	93 1f       	adc	r25, r19
     406:	b6 01       	movw	r22, r12
     408:	8e 58       	subi	r24, 0x8E	; 142
     40a:	9e 4f       	sbci	r25, 0xFE	; 254
     40c:	0e 94 cc 04 	call	0x998	; 0x998 <vListInsertEnd>
     410:	0f 90       	pop	r0
     412:	0f be       	out	0x3f, r0	; 63
     414:	80 91 3b 01 	lds	r24, 0x013B	; 0x80013b <xSchedulerRunning>
     418:	88 23       	and	r24, r24
     41a:	61 f0       	breq	.+24     	; 0x434 <__EEPROM_REGION_LENGTH__+0x34>
     41c:	e0 91 96 01 	lds	r30, 0x0196	; 0x800196 <pxCurrentTCB>
     420:	f0 91 97 01 	lds	r31, 0x0197	; 0x800197 <pxCurrentTCB+0x1>
     424:	96 89       	ldd	r25, Z+22	; 0x16
     426:	8e 89       	ldd	r24, Y+22	; 0x16
     428:	98 17       	cp	r25, r24
     42a:	30 f4       	brcc	.+12     	; 0x438 <__EEPROM_REGION_LENGTH__+0x38>
     42c:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <vPortYield>
     430:	81 e0       	ldi	r24, 0x01	; 1
     432:	05 c0       	rjmp	.+10     	; 0x43e <__EEPROM_REGION_LENGTH__+0x3e>
     434:	81 e0       	ldi	r24, 0x01	; 1
     436:	03 c0       	rjmp	.+6      	; 0x43e <__EEPROM_REGION_LENGTH__+0x3e>
     438:	81 e0       	ldi	r24, 0x01	; 1
     43a:	01 c0       	rjmp	.+2      	; 0x43e <__EEPROM_REGION_LENGTH__+0x3e>
     43c:	8f ef       	ldi	r24, 0xFF	; 255
     43e:	df 91       	pop	r29
     440:	cf 91       	pop	r28
     442:	0f 91       	pop	r16
     444:	ff 90       	pop	r15
     446:	ef 90       	pop	r14
     448:	df 90       	pop	r13
     44a:	cf 90       	pop	r12
     44c:	bf 90       	pop	r11
     44e:	af 90       	pop	r10
     450:	9f 90       	pop	r9
     452:	8f 90       	pop	r8
     454:	7f 90       	pop	r7
     456:	6f 90       	pop	r6
     458:	5f 90       	pop	r5
     45a:	4f 90       	pop	r4
     45c:	08 95       	ret

0000045e <vTaskStartScheduler>:
     45e:	ef 92       	push	r14
     460:	ff 92       	push	r15
     462:	0f 93       	push	r16
     464:	0f 2e       	mov	r0, r31
     466:	f3 e3       	ldi	r31, 0x33	; 51
     468:	ef 2e       	mov	r14, r31
     46a:	f1 e0       	ldi	r31, 0x01	; 1
     46c:	ff 2e       	mov	r15, r31
     46e:	f0 2d       	mov	r31, r0
     470:	00 e0       	ldi	r16, 0x00	; 0
     472:	20 e0       	ldi	r18, 0x00	; 0
     474:	30 e0       	ldi	r19, 0x00	; 0
     476:	45 e5       	ldi	r20, 0x55	; 85
     478:	50 e0       	ldi	r21, 0x00	; 0
     47a:	6b e0       	ldi	r22, 0x0B	; 11
     47c:	71 e0       	ldi	r23, 0x01	; 1
     47e:	81 ee       	ldi	r24, 0xE1	; 225
     480:	93 e0       	ldi	r25, 0x03	; 3
     482:	0e 94 22 01 	call	0x244	; 0x244 <xTaskCreate>
     486:	81 30       	cpi	r24, 0x01	; 1
     488:	81 f4       	brne	.+32     	; 0x4aa <vTaskStartScheduler+0x4c>
     48a:	f8 94       	cli
     48c:	8f ef       	ldi	r24, 0xFF	; 255
     48e:	9f ef       	ldi	r25, 0xFF	; 255
     490:	90 93 36 01 	sts	0x0136, r25	; 0x800136 <xNextTaskUnblockTime+0x1>
     494:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <xNextTaskUnblockTime>
     498:	81 e0       	ldi	r24, 0x01	; 1
     49a:	80 93 3b 01 	sts	0x013B, r24	; 0x80013b <xSchedulerRunning>
     49e:	10 92 3e 01 	sts	0x013E, r1	; 0x80013e <xTickCount+0x1>
     4a2:	10 92 3d 01 	sts	0x013D, r1	; 0x80013d <xTickCount>
     4a6:	0e 94 b0 05 	call	0xb60	; 0xb60 <xPortStartScheduler>
     4aa:	0f 91       	pop	r16
     4ac:	ff 90       	pop	r15
     4ae:	ef 90       	pop	r14
     4b0:	08 95       	ret

000004b2 <vTaskSuspendAll>:
     4b2:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <__data_end>
     4b6:	8f 5f       	subi	r24, 0xFF	; 255
     4b8:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__data_end>
     4bc:	08 95       	ret

000004be <xTaskGetTickCount>:
     4be:	0f b6       	in	r0, 0x3f	; 63
     4c0:	f8 94       	cli
     4c2:	0f 92       	push	r0
     4c4:	80 91 3d 01 	lds	r24, 0x013D	; 0x80013d <xTickCount>
     4c8:	90 91 3e 01 	lds	r25, 0x013E	; 0x80013e <xTickCount+0x1>
     4cc:	0f 90       	pop	r0
     4ce:	0f be       	out	0x3f, r0	; 63
     4d0:	08 95       	ret

000004d2 <xTaskIncrementTick>:
     4d2:	cf 92       	push	r12
     4d4:	df 92       	push	r13
     4d6:	ef 92       	push	r14
     4d8:	ff 92       	push	r15
     4da:	0f 93       	push	r16
     4dc:	1f 93       	push	r17
     4de:	cf 93       	push	r28
     4e0:	df 93       	push	r29
     4e2:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <__data_end>
     4e6:	81 11       	cpse	r24, r1
     4e8:	99 c0       	rjmp	.+306    	; 0x61c <xTaskIncrementTick+0x14a>
     4ea:	e0 90 3d 01 	lds	r14, 0x013D	; 0x80013d <xTickCount>
     4ee:	f0 90 3e 01 	lds	r15, 0x013E	; 0x80013e <xTickCount+0x1>
     4f2:	8f ef       	ldi	r24, 0xFF	; 255
     4f4:	e8 1a       	sub	r14, r24
     4f6:	f8 0a       	sbc	r15, r24
     4f8:	f0 92 3e 01 	sts	0x013E, r15	; 0x80013e <xTickCount+0x1>
     4fc:	e0 92 3d 01 	sts	0x013D, r14	; 0x80013d <xTickCount>
     500:	e1 14       	cp	r14, r1
     502:	f1 04       	cpc	r15, r1
     504:	b9 f4       	brne	.+46     	; 0x534 <xTaskIncrementTick+0x62>
     506:	80 91 5e 01 	lds	r24, 0x015E	; 0x80015e <pxDelayedTaskList>
     50a:	90 91 5f 01 	lds	r25, 0x015F	; 0x80015f <pxDelayedTaskList+0x1>
     50e:	20 91 5c 01 	lds	r18, 0x015C	; 0x80015c <pxOverflowDelayedTaskList>
     512:	30 91 5d 01 	lds	r19, 0x015D	; 0x80015d <pxOverflowDelayedTaskList+0x1>
     516:	30 93 5f 01 	sts	0x015F, r19	; 0x80015f <pxDelayedTaskList+0x1>
     51a:	20 93 5e 01 	sts	0x015E, r18	; 0x80015e <pxDelayedTaskList>
     51e:	90 93 5d 01 	sts	0x015D, r25	; 0x80015d <pxOverflowDelayedTaskList+0x1>
     522:	80 93 5c 01 	sts	0x015C, r24	; 0x80015c <pxOverflowDelayedTaskList>
     526:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <xNumOfOverflows>
     52a:	8f 5f       	subi	r24, 0xFF	; 255
     52c:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <xNumOfOverflows>
     530:	0e 94 ab 00 	call	0x156	; 0x156 <prvResetNextTaskUnblockTime>
     534:	80 91 35 01 	lds	r24, 0x0135	; 0x800135 <xNextTaskUnblockTime>
     538:	90 91 36 01 	lds	r25, 0x0136	; 0x800136 <xNextTaskUnblockTime+0x1>
     53c:	e8 16       	cp	r14, r24
     53e:	f9 06       	cpc	r15, r25
     540:	10 f4       	brcc	.+4      	; 0x546 <xTaskIncrementTick+0x74>
     542:	d1 2c       	mov	r13, r1
     544:	53 c0       	rjmp	.+166    	; 0x5ec <xTaskIncrementTick+0x11a>
     546:	d1 2c       	mov	r13, r1
     548:	cc 24       	eor	r12, r12
     54a:	c3 94       	inc	r12
     54c:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <pxDelayedTaskList>
     550:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <pxDelayedTaskList+0x1>
     554:	80 81       	ld	r24, Z
     556:	81 11       	cpse	r24, r1
     558:	07 c0       	rjmp	.+14     	; 0x568 <xTaskIncrementTick+0x96>
     55a:	8f ef       	ldi	r24, 0xFF	; 255
     55c:	9f ef       	ldi	r25, 0xFF	; 255
     55e:	90 93 36 01 	sts	0x0136, r25	; 0x800136 <xNextTaskUnblockTime+0x1>
     562:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <xNextTaskUnblockTime>
     566:	42 c0       	rjmp	.+132    	; 0x5ec <xTaskIncrementTick+0x11a>
     568:	e0 91 5e 01 	lds	r30, 0x015E	; 0x80015e <pxDelayedTaskList>
     56c:	f0 91 5f 01 	lds	r31, 0x015F	; 0x80015f <pxDelayedTaskList+0x1>
     570:	05 80       	ldd	r0, Z+5	; 0x05
     572:	f6 81       	ldd	r31, Z+6	; 0x06
     574:	e0 2d       	mov	r30, r0
     576:	c6 81       	ldd	r28, Z+6	; 0x06
     578:	d7 81       	ldd	r29, Z+7	; 0x07
     57a:	8a 81       	ldd	r24, Y+2	; 0x02
     57c:	9b 81       	ldd	r25, Y+3	; 0x03
     57e:	e8 16       	cp	r14, r24
     580:	f9 06       	cpc	r15, r25
     582:	28 f4       	brcc	.+10     	; 0x58e <xTaskIncrementTick+0xbc>
     584:	90 93 36 01 	sts	0x0136, r25	; 0x800136 <xNextTaskUnblockTime+0x1>
     588:	80 93 35 01 	sts	0x0135, r24	; 0x800135 <xNextTaskUnblockTime>
     58c:	2f c0       	rjmp	.+94     	; 0x5ec <xTaskIncrementTick+0x11a>
     58e:	8e 01       	movw	r16, r28
     590:	0e 5f       	subi	r16, 0xFE	; 254
     592:	1f 4f       	sbci	r17, 0xFF	; 255
     594:	c8 01       	movw	r24, r16
     596:	0e 94 1e 05 	call	0xa3c	; 0xa3c <uxListRemove>
     59a:	8c 89       	ldd	r24, Y+20	; 0x14
     59c:	9d 89       	ldd	r25, Y+21	; 0x15
     59e:	89 2b       	or	r24, r25
     5a0:	21 f0       	breq	.+8      	; 0x5aa <xTaskIncrementTick+0xd8>
     5a2:	ce 01       	movw	r24, r28
     5a4:	0c 96       	adiw	r24, 0x0c	; 12
     5a6:	0e 94 1e 05 	call	0xa3c	; 0xa3c <uxListRemove>
     5aa:	8e 89       	ldd	r24, Y+22	; 0x16
     5ac:	90 91 3c 01 	lds	r25, 0x013C	; 0x80013c <uxTopReadyPriority>
     5b0:	98 17       	cp	r25, r24
     5b2:	10 f4       	brcc	.+4      	; 0x5b8 <xTaskIncrementTick+0xe6>
     5b4:	80 93 3c 01 	sts	0x013C, r24	; 0x80013c <uxTopReadyPriority>
     5b8:	90 e0       	ldi	r25, 0x00	; 0
     5ba:	9c 01       	movw	r18, r24
     5bc:	22 0f       	add	r18, r18
     5be:	33 1f       	adc	r19, r19
     5c0:	22 0f       	add	r18, r18
     5c2:	33 1f       	adc	r19, r19
     5c4:	22 0f       	add	r18, r18
     5c6:	33 1f       	adc	r19, r19
     5c8:	82 0f       	add	r24, r18
     5ca:	93 1f       	adc	r25, r19
     5cc:	b8 01       	movw	r22, r16
     5ce:	8e 58       	subi	r24, 0x8E	; 142
     5d0:	9e 4f       	sbci	r25, 0xFE	; 254
     5d2:	0e 94 cc 04 	call	0x998	; 0x998 <vListInsertEnd>
     5d6:	e0 91 96 01 	lds	r30, 0x0196	; 0x800196 <pxCurrentTCB>
     5da:	f0 91 97 01 	lds	r31, 0x0197	; 0x800197 <pxCurrentTCB+0x1>
     5de:	9e 89       	ldd	r25, Y+22	; 0x16
     5e0:	86 89       	ldd	r24, Z+22	; 0x16
     5e2:	98 17       	cp	r25, r24
     5e4:	08 f4       	brcc	.+2      	; 0x5e8 <xTaskIncrementTick+0x116>
     5e6:	b2 cf       	rjmp	.-156    	; 0x54c <xTaskIncrementTick+0x7a>
     5e8:	dc 2c       	mov	r13, r12
     5ea:	b0 cf       	rjmp	.-160    	; 0x54c <xTaskIncrementTick+0x7a>
     5ec:	e0 91 96 01 	lds	r30, 0x0196	; 0x800196 <pxCurrentTCB>
     5f0:	f0 91 97 01 	lds	r31, 0x0197	; 0x800197 <pxCurrentTCB+0x1>
     5f4:	86 89       	ldd	r24, Z+22	; 0x16
     5f6:	90 e0       	ldi	r25, 0x00	; 0
     5f8:	fc 01       	movw	r30, r24
     5fa:	ee 0f       	add	r30, r30
     5fc:	ff 1f       	adc	r31, r31
     5fe:	ee 0f       	add	r30, r30
     600:	ff 1f       	adc	r31, r31
     602:	ee 0f       	add	r30, r30
     604:	ff 1f       	adc	r31, r31
     606:	8e 0f       	add	r24, r30
     608:	9f 1f       	adc	r25, r31
     60a:	fc 01       	movw	r30, r24
     60c:	ee 58       	subi	r30, 0x8E	; 142
     60e:	fe 4f       	sbci	r31, 0xFE	; 254
     610:	80 81       	ld	r24, Z
     612:	82 30       	cpi	r24, 0x02	; 2
     614:	48 f0       	brcs	.+18     	; 0x628 <xTaskIncrementTick+0x156>
     616:	dd 24       	eor	r13, r13
     618:	d3 94       	inc	r13
     61a:	06 c0       	rjmp	.+12     	; 0x628 <xTaskIncrementTick+0x156>
     61c:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <uxPendedTicks>
     620:	8f 5f       	subi	r24, 0xFF	; 255
     622:	80 93 3a 01 	sts	0x013A, r24	; 0x80013a <uxPendedTicks>
     626:	d1 2c       	mov	r13, r1
     628:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <xYieldPending>
     62c:	88 23       	and	r24, r24
     62e:	11 f0       	breq	.+4      	; 0x634 <xTaskIncrementTick+0x162>
     630:	dd 24       	eor	r13, r13
     632:	d3 94       	inc	r13
     634:	8d 2d       	mov	r24, r13
     636:	df 91       	pop	r29
     638:	cf 91       	pop	r28
     63a:	1f 91       	pop	r17
     63c:	0f 91       	pop	r16
     63e:	ff 90       	pop	r15
     640:	ef 90       	pop	r14
     642:	df 90       	pop	r13
     644:	cf 90       	pop	r12
     646:	08 95       	ret

00000648 <xTaskResumeAll>:
     648:	df 92       	push	r13
     64a:	ef 92       	push	r14
     64c:	ff 92       	push	r15
     64e:	0f 93       	push	r16
     650:	1f 93       	push	r17
     652:	cf 93       	push	r28
     654:	df 93       	push	r29
     656:	0f b6       	in	r0, 0x3f	; 63
     658:	f8 94       	cli
     65a:	0f 92       	push	r0
     65c:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <__data_end>
     660:	81 50       	subi	r24, 0x01	; 1
     662:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <__data_end>
     666:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <__data_end>
     66a:	81 11       	cpse	r24, r1
     66c:	5f c0       	rjmp	.+190    	; 0x72c <xTaskResumeAll+0xe4>
     66e:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <uxCurrentNumberOfTasks>
     672:	81 11       	cpse	r24, r1
     674:	33 c0       	rjmp	.+102    	; 0x6dc <xTaskResumeAll+0x94>
     676:	5d c0       	rjmp	.+186    	; 0x732 <xTaskResumeAll+0xea>
     678:	d7 01       	movw	r26, r14
     67a:	15 96       	adiw	r26, 0x05	; 5
     67c:	ed 91       	ld	r30, X+
     67e:	fc 91       	ld	r31, X
     680:	16 97       	sbiw	r26, 0x06	; 6
     682:	c6 81       	ldd	r28, Z+6	; 0x06
     684:	d7 81       	ldd	r29, Z+7	; 0x07
     686:	ce 01       	movw	r24, r28
     688:	0c 96       	adiw	r24, 0x0c	; 12
     68a:	0e 94 1e 05 	call	0xa3c	; 0xa3c <uxListRemove>
     68e:	8e 01       	movw	r16, r28
     690:	0e 5f       	subi	r16, 0xFE	; 254
     692:	1f 4f       	sbci	r17, 0xFF	; 255
     694:	c8 01       	movw	r24, r16
     696:	0e 94 1e 05 	call	0xa3c	; 0xa3c <uxListRemove>
     69a:	8e 89       	ldd	r24, Y+22	; 0x16
     69c:	90 91 3c 01 	lds	r25, 0x013C	; 0x80013c <uxTopReadyPriority>
     6a0:	98 17       	cp	r25, r24
     6a2:	10 f4       	brcc	.+4      	; 0x6a8 <xTaskResumeAll+0x60>
     6a4:	80 93 3c 01 	sts	0x013C, r24	; 0x80013c <uxTopReadyPriority>
     6a8:	90 e0       	ldi	r25, 0x00	; 0
     6aa:	9c 01       	movw	r18, r24
     6ac:	22 0f       	add	r18, r18
     6ae:	33 1f       	adc	r19, r19
     6b0:	22 0f       	add	r18, r18
     6b2:	33 1f       	adc	r19, r19
     6b4:	22 0f       	add	r18, r18
     6b6:	33 1f       	adc	r19, r19
     6b8:	82 0f       	add	r24, r18
     6ba:	93 1f       	adc	r25, r19
     6bc:	b8 01       	movw	r22, r16
     6be:	8e 58       	subi	r24, 0x8E	; 142
     6c0:	9e 4f       	sbci	r25, 0xFE	; 254
     6c2:	0e 94 cc 04 	call	0x998	; 0x998 <vListInsertEnd>
     6c6:	e0 91 96 01 	lds	r30, 0x0196	; 0x800196 <pxCurrentTCB>
     6ca:	f0 91 97 01 	lds	r31, 0x0197	; 0x800197 <pxCurrentTCB+0x1>
     6ce:	9e 89       	ldd	r25, Y+22	; 0x16
     6d0:	86 89       	ldd	r24, Z+22	; 0x16
     6d2:	98 17       	cp	r25, r24
     6d4:	68 f0       	brcs	.+26     	; 0x6f0 <xTaskResumeAll+0xa8>
     6d6:	d0 92 39 01 	sts	0x0139, r13	; 0x800139 <xYieldPending>
     6da:	0a c0       	rjmp	.+20     	; 0x6f0 <xTaskResumeAll+0xa8>
     6dc:	c0 e0       	ldi	r28, 0x00	; 0
     6de:	d0 e0       	ldi	r29, 0x00	; 0
     6e0:	0f 2e       	mov	r0, r31
     6e2:	f3 e5       	ldi	r31, 0x53	; 83
     6e4:	ef 2e       	mov	r14, r31
     6e6:	f1 e0       	ldi	r31, 0x01	; 1
     6e8:	ff 2e       	mov	r15, r31
     6ea:	f0 2d       	mov	r31, r0
     6ec:	dd 24       	eor	r13, r13
     6ee:	d3 94       	inc	r13
     6f0:	f7 01       	movw	r30, r14
     6f2:	80 81       	ld	r24, Z
     6f4:	81 11       	cpse	r24, r1
     6f6:	c0 cf       	rjmp	.-128    	; 0x678 <xTaskResumeAll+0x30>
     6f8:	cd 2b       	or	r28, r29
     6fa:	11 f0       	breq	.+4      	; 0x700 <xTaskResumeAll+0xb8>
     6fc:	0e 94 ab 00 	call	0x156	; 0x156 <prvResetNextTaskUnblockTime>
     700:	c0 91 3a 01 	lds	r28, 0x013A	; 0x80013a <uxPendedTicks>
     704:	cc 23       	and	r28, r28
     706:	51 f0       	breq	.+20     	; 0x71c <xTaskResumeAll+0xd4>
     708:	d1 e0       	ldi	r29, 0x01	; 1
     70a:	0e 94 69 02 	call	0x4d2	; 0x4d2 <xTaskIncrementTick>
     70e:	81 11       	cpse	r24, r1
     710:	d0 93 39 01 	sts	0x0139, r29	; 0x800139 <xYieldPending>
     714:	c1 50       	subi	r28, 0x01	; 1
     716:	c9 f7       	brne	.-14     	; 0x70a <xTaskResumeAll+0xc2>
     718:	10 92 3a 01 	sts	0x013A, r1	; 0x80013a <uxPendedTicks>
     71c:	80 91 39 01 	lds	r24, 0x0139	; 0x800139 <xYieldPending>
     720:	88 23       	and	r24, r24
     722:	31 f0       	breq	.+12     	; 0x730 <xTaskResumeAll+0xe8>
     724:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <vPortYield>
     728:	81 e0       	ldi	r24, 0x01	; 1
     72a:	03 c0       	rjmp	.+6      	; 0x732 <xTaskResumeAll+0xea>
     72c:	80 e0       	ldi	r24, 0x00	; 0
     72e:	01 c0       	rjmp	.+2      	; 0x732 <xTaskResumeAll+0xea>
     730:	80 e0       	ldi	r24, 0x00	; 0
     732:	0f 90       	pop	r0
     734:	0f be       	out	0x3f, r0	; 63
     736:	df 91       	pop	r29
     738:	cf 91       	pop	r28
     73a:	1f 91       	pop	r17
     73c:	0f 91       	pop	r16
     73e:	ff 90       	pop	r15
     740:	ef 90       	pop	r14
     742:	df 90       	pop	r13
     744:	08 95       	ret

00000746 <vTaskDelayUntil>:
     746:	0f 93       	push	r16
     748:	1f 93       	push	r17
     74a:	cf 93       	push	r28
     74c:	df 93       	push	r29
     74e:	8c 01       	movw	r16, r24
     750:	eb 01       	movw	r28, r22
     752:	0e 94 59 02 	call	0x4b2	; 0x4b2 <vTaskSuspendAll>
     756:	40 91 3d 01 	lds	r20, 0x013D	; 0x80013d <xTickCount>
     75a:	50 91 3e 01 	lds	r21, 0x013E	; 0x80013e <xTickCount+0x1>
     75e:	f8 01       	movw	r30, r16
     760:	20 81       	ld	r18, Z
     762:	31 81       	ldd	r19, Z+1	; 0x01
     764:	c9 01       	movw	r24, r18
     766:	8c 0f       	add	r24, r28
     768:	9d 1f       	adc	r25, r29
     76a:	42 17       	cp	r20, r18
     76c:	53 07       	cpc	r21, r19
     76e:	48 f4       	brcc	.+18     	; 0x782 <vTaskDelayUntil+0x3c>
     770:	82 17       	cp	r24, r18
     772:	93 07       	cpc	r25, r19
     774:	e8 f4       	brcc	.+58     	; 0x7b0 <vTaskDelayUntil+0x6a>
     776:	91 83       	std	Z+1, r25	; 0x01
     778:	80 83       	st	Z, r24
     77a:	48 17       	cp	r20, r24
     77c:	59 07       	cpc	r21, r25
     77e:	68 f4       	brcc	.+26     	; 0x79a <vTaskDelayUntil+0x54>
     780:	07 c0       	rjmp	.+14     	; 0x790 <vTaskDelayUntil+0x4a>
     782:	82 17       	cp	r24, r18
     784:	93 07       	cpc	r25, r19
     786:	80 f0       	brcs	.+32     	; 0x7a8 <vTaskDelayUntil+0x62>
     788:	48 17       	cp	r20, r24
     78a:	59 07       	cpc	r21, r25
     78c:	68 f0       	brcs	.+26     	; 0x7a8 <vTaskDelayUntil+0x62>
     78e:	10 c0       	rjmp	.+32     	; 0x7b0 <vTaskDelayUntil+0x6a>
     790:	60 e0       	ldi	r22, 0x00	; 0
     792:	84 1b       	sub	r24, r20
     794:	95 0b       	sbc	r25, r21
     796:	0e 94 ca 00 	call	0x194	; 0x194 <prvAddCurrentTaskToDelayedList>
     79a:	0e 94 24 03 	call	0x648	; 0x648 <xTaskResumeAll>
     79e:	81 11       	cpse	r24, r1
     7a0:	0b c0       	rjmp	.+22     	; 0x7b8 <vTaskDelayUntil+0x72>
     7a2:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <vPortYield>
     7a6:	08 c0       	rjmp	.+16     	; 0x7b8 <vTaskDelayUntil+0x72>
     7a8:	f8 01       	movw	r30, r16
     7aa:	91 83       	std	Z+1, r25	; 0x01
     7ac:	80 83       	st	Z, r24
     7ae:	f0 cf       	rjmp	.-32     	; 0x790 <vTaskDelayUntil+0x4a>
     7b0:	f8 01       	movw	r30, r16
     7b2:	91 83       	std	Z+1, r25	; 0x01
     7b4:	80 83       	st	Z, r24
     7b6:	f1 cf       	rjmp	.-30     	; 0x79a <vTaskDelayUntil+0x54>
     7b8:	df 91       	pop	r29
     7ba:	cf 91       	pop	r28
     7bc:	1f 91       	pop	r17
     7be:	0f 91       	pop	r16
     7c0:	08 95       	ret

000007c2 <prvIdleTask>:
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
     7c2:	0a e4       	ldi	r16, 0x4A	; 74
     7c4:	11 e0       	ldi	r17, 0x01	; 1

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     7c6:	0f 2e       	mov	r0, r31
     7c8:	f2 e7       	ldi	r31, 0x72	; 114
     7ca:	ef 2e       	mov	r14, r31
     7cc:	f1 e0       	ldi	r31, 0x01	; 1
     7ce:	ff 2e       	mov	r15, r31
     7d0:	f0 2d       	mov	r31, r0
     7d2:	29 c0       	rjmp	.+82     	; 0x826 <__DATA_REGION_LENGTH__+0x26>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
     7d4:	0e 94 59 02 	call	0x4b2	; 0x4b2 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
     7d8:	d8 01       	movw	r26, r16
     7da:	cc 91       	ld	r28, X
			}
			( void ) xTaskResumeAll();
     7dc:	0e 94 24 03 	call	0x648	; 0x648 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
     7e0:	cc 23       	and	r28, r28
     7e2:	09 f1       	breq	.+66     	; 0x826 <__DATA_REGION_LENGTH__+0x26>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
     7e4:	0f b6       	in	r0, 0x3f	; 63
     7e6:	f8 94       	cli
     7e8:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
     7ea:	d8 01       	movw	r26, r16
     7ec:	15 96       	adiw	r26, 0x05	; 5
     7ee:	ed 91       	ld	r30, X+
     7f0:	fc 91       	ld	r31, X
     7f2:	16 97       	sbiw	r26, 0x06	; 6
     7f4:	c6 81       	ldd	r28, Z+6	; 0x06
     7f6:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     7f8:	ce 01       	movw	r24, r28
     7fa:	02 96       	adiw	r24, 0x02	; 2
     7fc:	0e 94 1e 05 	call	0xa3c	; 0xa3c <uxListRemove>
					--uxCurrentNumberOfTasks;
     800:	80 91 3f 01 	lds	r24, 0x013F	; 0x80013f <uxCurrentNumberOfTasks>
     804:	81 50       	subi	r24, 0x01	; 1
     806:	80 93 3f 01 	sts	0x013F, r24	; 0x80013f <uxCurrentNumberOfTasks>
					--uxDeletedTasksWaitingCleanUp;
     80a:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <uxDeletedTasksWaitingCleanUp>
     80e:	81 50       	subi	r24, 0x01	; 1
     810:	80 93 49 01 	sts	0x0149, r24	; 0x800149 <uxDeletedTasksWaitingCleanUp>
				}
				taskEXIT_CRITICAL();
     814:	0f 90       	pop	r0
     816:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
     818:	8f 89       	ldd	r24, Y+23	; 0x17
     81a:	98 8d       	ldd	r25, Y+24	; 0x18
     81c:	0e 94 b9 04 	call	0x972	; 0x972 <vPortFree>
			vPortFree( pxTCB );
     820:	ce 01       	movw	r24, r28
     822:	0e 94 b9 04 	call	0x972	; 0x972 <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
     826:	80 91 49 01 	lds	r24, 0x0149	; 0x800149 <uxDeletedTasksWaitingCleanUp>
     82a:	81 11       	cpse	r24, r1
     82c:	d3 cf       	rjmp	.-90     	; 0x7d4 <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     82e:	f7 01       	movw	r30, r14
     830:	80 81       	ld	r24, Z
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	c0 f3       	brcs	.-16     	; 0x826 <__DATA_REGION_LENGTH__+0x26>
			{
				taskYIELD();
     836:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <vPortYield>
     83a:	f5 cf       	rjmp	.-22     	; 0x826 <__DATA_REGION_LENGTH__+0x26>

0000083c <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     83c:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <__data_end>
     840:	88 23       	and	r24, r24
     842:	21 f0       	breq	.+8      	; 0x84c <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     844:	81 e0       	ldi	r24, 0x01	; 1
     846:	80 93 39 01 	sts	0x0139, r24	; 0x800139 <xYieldPending>
     84a:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     84c:	10 92 39 01 	sts	0x0139, r1	; 0x800139 <xYieldPending>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     850:	20 91 3c 01 	lds	r18, 0x013C	; 0x80013c <uxTopReadyPriority>
     854:	82 2f       	mov	r24, r18
     856:	90 e0       	ldi	r25, 0x00	; 0
     858:	fc 01       	movw	r30, r24
     85a:	ee 0f       	add	r30, r30
     85c:	ff 1f       	adc	r31, r31
     85e:	ee 0f       	add	r30, r30
     860:	ff 1f       	adc	r31, r31
     862:	ee 0f       	add	r30, r30
     864:	ff 1f       	adc	r31, r31
     866:	e8 0f       	add	r30, r24
     868:	f9 1f       	adc	r31, r25
     86a:	ee 58       	subi	r30, 0x8E	; 142
     86c:	fe 4f       	sbci	r31, 0xFE	; 254
     86e:	30 81       	ld	r19, Z
     870:	31 11       	cpse	r19, r1
     872:	11 c0       	rjmp	.+34     	; 0x896 <vTaskSwitchContext+0x5a>
     874:	21 50       	subi	r18, 0x01	; 1
     876:	82 2f       	mov	r24, r18
     878:	90 e0       	ldi	r25, 0x00	; 0
     87a:	fc 01       	movw	r30, r24
     87c:	ee 0f       	add	r30, r30
     87e:	ff 1f       	adc	r31, r31
     880:	ee 0f       	add	r30, r30
     882:	ff 1f       	adc	r31, r31
     884:	ee 0f       	add	r30, r30
     886:	ff 1f       	adc	r31, r31
     888:	e8 0f       	add	r30, r24
     88a:	f9 1f       	adc	r31, r25
     88c:	ee 58       	subi	r30, 0x8E	; 142
     88e:	fe 4f       	sbci	r31, 0xFE	; 254
     890:	30 81       	ld	r19, Z
     892:	33 23       	and	r19, r19
     894:	79 f3       	breq	.-34     	; 0x874 <vTaskSwitchContext+0x38>
     896:	ac 01       	movw	r20, r24
     898:	44 0f       	add	r20, r20
     89a:	55 1f       	adc	r21, r21
     89c:	44 0f       	add	r20, r20
     89e:	55 1f       	adc	r21, r21
     8a0:	44 0f       	add	r20, r20
     8a2:	55 1f       	adc	r21, r21
     8a4:	48 0f       	add	r20, r24
     8a6:	59 1f       	adc	r21, r25
     8a8:	da 01       	movw	r26, r20
     8aa:	ae 58       	subi	r26, 0x8E	; 142
     8ac:	be 4f       	sbci	r27, 0xFE	; 254
     8ae:	11 96       	adiw	r26, 0x01	; 1
     8b0:	ed 91       	ld	r30, X+
     8b2:	fc 91       	ld	r31, X
     8b4:	12 97       	sbiw	r26, 0x02	; 2
     8b6:	02 80       	ldd	r0, Z+2	; 0x02
     8b8:	f3 81       	ldd	r31, Z+3	; 0x03
     8ba:	e0 2d       	mov	r30, r0
     8bc:	12 96       	adiw	r26, 0x02	; 2
     8be:	fc 93       	st	X, r31
     8c0:	ee 93       	st	-X, r30
     8c2:	11 97       	sbiw	r26, 0x01	; 1
     8c4:	4b 58       	subi	r20, 0x8B	; 139
     8c6:	5e 4f       	sbci	r21, 0xFE	; 254
     8c8:	e4 17       	cp	r30, r20
     8ca:	f5 07       	cpc	r31, r21
     8cc:	29 f4       	brne	.+10     	; 0x8d8 <vTaskSwitchContext+0x9c>
     8ce:	42 81       	ldd	r20, Z+2	; 0x02
     8d0:	53 81       	ldd	r21, Z+3	; 0x03
     8d2:	fd 01       	movw	r30, r26
     8d4:	52 83       	std	Z+2, r21	; 0x02
     8d6:	41 83       	std	Z+1, r20	; 0x01
     8d8:	fc 01       	movw	r30, r24
     8da:	ee 0f       	add	r30, r30
     8dc:	ff 1f       	adc	r31, r31
     8de:	ee 0f       	add	r30, r30
     8e0:	ff 1f       	adc	r31, r31
     8e2:	ee 0f       	add	r30, r30
     8e4:	ff 1f       	adc	r31, r31
     8e6:	8e 0f       	add	r24, r30
     8e8:	9f 1f       	adc	r25, r31
     8ea:	fc 01       	movw	r30, r24
     8ec:	ee 58       	subi	r30, 0x8E	; 142
     8ee:	fe 4f       	sbci	r31, 0xFE	; 254
     8f0:	01 80       	ldd	r0, Z+1	; 0x01
     8f2:	f2 81       	ldd	r31, Z+2	; 0x02
     8f4:	e0 2d       	mov	r30, r0
     8f6:	86 81       	ldd	r24, Z+6	; 0x06
     8f8:	97 81       	ldd	r25, Z+7	; 0x07
     8fa:	90 93 97 01 	sts	0x0197, r25	; 0x800197 <pxCurrentTCB+0x1>
     8fe:	80 93 96 01 	sts	0x0196, r24	; 0x800196 <pxCurrentTCB>
     902:	20 93 3c 01 	sts	0x013C, r18	; 0x80013c <uxTopReadyPriority>
     906:	08 95       	ret

00000908 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     908:	cf 93       	push	r28
     90a:	df 93       	push	r29
     90c:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     90e:	0e 94 59 02 	call	0x4b2	; 0x4b2 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     912:	80 91 98 01 	lds	r24, 0x0198	; 0x800198 <pucAlignedHeap.2068>
     916:	90 91 99 01 	lds	r25, 0x0199	; 0x800199 <pucAlignedHeap.2068+0x1>
     91a:	89 2b       	or	r24, r25
     91c:	31 f4       	brne	.+12     	; 0x92a <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     91e:	8d e9       	ldi	r24, 0x9D	; 157
     920:	91 e0       	ldi	r25, 0x01	; 1
     922:	90 93 99 01 	sts	0x0199, r25	; 0x800199 <pucAlignedHeap.2068+0x1>
     926:	80 93 98 01 	sts	0x0198, r24	; 0x800198 <pucAlignedHeap.2068>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     92a:	20 91 9a 01 	lds	r18, 0x019A	; 0x80019a <xNextFreeByte>
     92e:	30 91 9b 01 	lds	r19, 0x019B	; 0x80019b <xNextFreeByte+0x1>
     932:	c9 01       	movw	r24, r18
     934:	8c 0f       	add	r24, r28
     936:	9d 1f       	adc	r25, r29
     938:	8b 3d       	cpi	r24, 0xDB	; 219
     93a:	45 e0       	ldi	r20, 0x05	; 5
     93c:	94 07       	cpc	r25, r20
     93e:	70 f4       	brcc	.+28     	; 0x95c <pvPortMalloc+0x54>
     940:	28 17       	cp	r18, r24
     942:	39 07       	cpc	r19, r25
     944:	70 f4       	brcc	.+28     	; 0x962 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     946:	c0 91 98 01 	lds	r28, 0x0198	; 0x800198 <pucAlignedHeap.2068>
     94a:	d0 91 99 01 	lds	r29, 0x0199	; 0x800199 <pucAlignedHeap.2068+0x1>
     94e:	c2 0f       	add	r28, r18
     950:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     952:	90 93 9b 01 	sts	0x019B, r25	; 0x80019b <xNextFreeByte+0x1>
     956:	80 93 9a 01 	sts	0x019A, r24	; 0x80019a <xNextFreeByte>
     95a:	05 c0       	rjmp	.+10     	; 0x966 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     95c:	c0 e0       	ldi	r28, 0x00	; 0
     95e:	d0 e0       	ldi	r29, 0x00	; 0
     960:	02 c0       	rjmp	.+4      	; 0x966 <pvPortMalloc+0x5e>
     962:	c0 e0       	ldi	r28, 0x00	; 0
     964:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     966:	0e 94 24 03 	call	0x648	; 0x648 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     96a:	ce 01       	movw	r24, r28
     96c:	df 91       	pop	r29
     96e:	cf 91       	pop	r28
     970:	08 95       	ret

00000972 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     972:	08 95       	ret

00000974 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     974:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     976:	03 96       	adiw	r24, 0x03	; 3
     978:	92 83       	std	Z+2, r25	; 0x02
     97a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     97c:	2f ef       	ldi	r18, 0xFF	; 255
     97e:	3f ef       	ldi	r19, 0xFF	; 255
     980:	34 83       	std	Z+4, r19	; 0x04
     982:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     984:	96 83       	std	Z+6, r25	; 0x06
     986:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     988:	90 87       	std	Z+8, r25	; 0x08
     98a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     98c:	10 82       	st	Z, r1
     98e:	08 95       	ret

00000990 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     990:	fc 01       	movw	r30, r24
     992:	11 86       	std	Z+9, r1	; 0x09
     994:	10 86       	std	Z+8, r1	; 0x08
     996:	08 95       	ret

00000998 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     998:	cf 93       	push	r28
     99a:	df 93       	push	r29
     99c:	9c 01       	movw	r18, r24
     99e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     9a0:	dc 01       	movw	r26, r24
     9a2:	11 96       	adiw	r26, 0x01	; 1
     9a4:	cd 91       	ld	r28, X+
     9a6:	dc 91       	ld	r29, X
     9a8:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     9aa:	d3 83       	std	Z+3, r29	; 0x03
     9ac:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     9ae:	8c 81       	ldd	r24, Y+4	; 0x04
     9b0:	9d 81       	ldd	r25, Y+5	; 0x05
     9b2:	95 83       	std	Z+5, r25	; 0x05
     9b4:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     9b6:	8c 81       	ldd	r24, Y+4	; 0x04
     9b8:	9d 81       	ldd	r25, Y+5	; 0x05
     9ba:	dc 01       	movw	r26, r24
     9bc:	13 96       	adiw	r26, 0x03	; 3
     9be:	7c 93       	st	X, r23
     9c0:	6e 93       	st	-X, r22
     9c2:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     9c4:	7d 83       	std	Y+5, r23	; 0x05
     9c6:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     9c8:	31 87       	std	Z+9, r19	; 0x09
     9ca:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     9cc:	f9 01       	movw	r30, r18
     9ce:	80 81       	ld	r24, Z
     9d0:	8f 5f       	subi	r24, 0xFF	; 255
     9d2:	80 83       	st	Z, r24
}
     9d4:	df 91       	pop	r29
     9d6:	cf 91       	pop	r28
     9d8:	08 95       	ret

000009da <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     9da:	cf 93       	push	r28
     9dc:	df 93       	push	r29
     9de:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     9e0:	48 81       	ld	r20, Y
     9e2:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     9e4:	4f 3f       	cpi	r20, 0xFF	; 255
     9e6:	2f ef       	ldi	r18, 0xFF	; 255
     9e8:	52 07       	cpc	r21, r18
     9ea:	21 f4       	brne	.+8      	; 0x9f4 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     9ec:	fc 01       	movw	r30, r24
     9ee:	a7 81       	ldd	r26, Z+7	; 0x07
     9f0:	b0 85       	ldd	r27, Z+8	; 0x08
     9f2:	0d c0       	rjmp	.+26     	; 0xa0e <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     9f4:	dc 01       	movw	r26, r24
     9f6:	13 96       	adiw	r26, 0x03	; 3
     9f8:	01 c0       	rjmp	.+2      	; 0x9fc <vListInsert+0x22>
     9fa:	df 01       	movw	r26, r30
     9fc:	12 96       	adiw	r26, 0x02	; 2
     9fe:	ed 91       	ld	r30, X+
     a00:	fc 91       	ld	r31, X
     a02:	13 97       	sbiw	r26, 0x03	; 3
     a04:	20 81       	ld	r18, Z
     a06:	31 81       	ldd	r19, Z+1	; 0x01
     a08:	42 17       	cp	r20, r18
     a0a:	53 07       	cpc	r21, r19
     a0c:	b0 f7       	brcc	.-20     	; 0x9fa <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     a0e:	12 96       	adiw	r26, 0x02	; 2
     a10:	ed 91       	ld	r30, X+
     a12:	fc 91       	ld	r31, X
     a14:	13 97       	sbiw	r26, 0x03	; 3
     a16:	fb 83       	std	Y+3, r31	; 0x03
     a18:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     a1a:	d5 83       	std	Z+5, r29	; 0x05
     a1c:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     a1e:	bd 83       	std	Y+5, r27	; 0x05
     a20:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     a22:	13 96       	adiw	r26, 0x03	; 3
     a24:	dc 93       	st	X, r29
     a26:	ce 93       	st	-X, r28
     a28:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     a2a:	99 87       	std	Y+9, r25	; 0x09
     a2c:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     a2e:	fc 01       	movw	r30, r24
     a30:	20 81       	ld	r18, Z
     a32:	2f 5f       	subi	r18, 0xFF	; 255
     a34:	20 83       	st	Z, r18
}
     a36:	df 91       	pop	r29
     a38:	cf 91       	pop	r28
     a3a:	08 95       	ret

00000a3c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     a3c:	cf 93       	push	r28
     a3e:	df 93       	push	r29
     a40:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     a42:	a0 85       	ldd	r26, Z+8	; 0x08
     a44:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     a46:	c2 81       	ldd	r28, Z+2	; 0x02
     a48:	d3 81       	ldd	r29, Z+3	; 0x03
     a4a:	84 81       	ldd	r24, Z+4	; 0x04
     a4c:	95 81       	ldd	r25, Z+5	; 0x05
     a4e:	9d 83       	std	Y+5, r25	; 0x05
     a50:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     a52:	c4 81       	ldd	r28, Z+4	; 0x04
     a54:	d5 81       	ldd	r29, Z+5	; 0x05
     a56:	82 81       	ldd	r24, Z+2	; 0x02
     a58:	93 81       	ldd	r25, Z+3	; 0x03
     a5a:	9b 83       	std	Y+3, r25	; 0x03
     a5c:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     a5e:	11 96       	adiw	r26, 0x01	; 1
     a60:	8d 91       	ld	r24, X+
     a62:	9c 91       	ld	r25, X
     a64:	12 97       	sbiw	r26, 0x02	; 2
     a66:	e8 17       	cp	r30, r24
     a68:	f9 07       	cpc	r31, r25
     a6a:	31 f4       	brne	.+12     	; 0xa78 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     a6c:	84 81       	ldd	r24, Z+4	; 0x04
     a6e:	95 81       	ldd	r25, Z+5	; 0x05
     a70:	12 96       	adiw	r26, 0x02	; 2
     a72:	9c 93       	st	X, r25
     a74:	8e 93       	st	-X, r24
     a76:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     a78:	11 86       	std	Z+9, r1	; 0x09
     a7a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     a7c:	8c 91       	ld	r24, X
     a7e:	81 50       	subi	r24, 0x01	; 1
     a80:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     a82:	df 91       	pop	r29
     a84:	cf 91       	pop	r28
     a86:	08 95       	ret

00000a88 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     a88:	31 e1       	ldi	r19, 0x11	; 17
     a8a:	fc 01       	movw	r30, r24
     a8c:	30 83       	st	Z, r19
     a8e:	31 97       	sbiw	r30, 0x01	; 1
     a90:	22 e2       	ldi	r18, 0x22	; 34
     a92:	20 83       	st	Z, r18
     a94:	31 97       	sbiw	r30, 0x01	; 1
     a96:	a3 e3       	ldi	r26, 0x33	; 51
     a98:	a0 83       	st	Z, r26
     a9a:	31 97       	sbiw	r30, 0x01	; 1
     a9c:	60 83       	st	Z, r22
     a9e:	31 97       	sbiw	r30, 0x01	; 1
     aa0:	70 83       	st	Z, r23
     aa2:	31 97       	sbiw	r30, 0x01	; 1
     aa4:	10 82       	st	Z, r1
     aa6:	31 97       	sbiw	r30, 0x01	; 1
     aa8:	60 e8       	ldi	r22, 0x80	; 128
     aaa:	60 83       	st	Z, r22
     aac:	31 97       	sbiw	r30, 0x01	; 1
     aae:	10 82       	st	Z, r1
     ab0:	31 97       	sbiw	r30, 0x01	; 1
     ab2:	62 e0       	ldi	r22, 0x02	; 2
     ab4:	60 83       	st	Z, r22
     ab6:	31 97       	sbiw	r30, 0x01	; 1
     ab8:	63 e0       	ldi	r22, 0x03	; 3
     aba:	60 83       	st	Z, r22
     abc:	31 97       	sbiw	r30, 0x01	; 1
     abe:	64 e0       	ldi	r22, 0x04	; 4
     ac0:	60 83       	st	Z, r22
     ac2:	31 97       	sbiw	r30, 0x01	; 1
     ac4:	65 e0       	ldi	r22, 0x05	; 5
     ac6:	60 83       	st	Z, r22
     ac8:	31 97       	sbiw	r30, 0x01	; 1
     aca:	66 e0       	ldi	r22, 0x06	; 6
     acc:	60 83       	st	Z, r22
     ace:	31 97       	sbiw	r30, 0x01	; 1
     ad0:	67 e0       	ldi	r22, 0x07	; 7
     ad2:	60 83       	st	Z, r22
     ad4:	31 97       	sbiw	r30, 0x01	; 1
     ad6:	68 e0       	ldi	r22, 0x08	; 8
     ad8:	60 83       	st	Z, r22
     ada:	31 97       	sbiw	r30, 0x01	; 1
     adc:	69 e0       	ldi	r22, 0x09	; 9
     ade:	60 83       	st	Z, r22
     ae0:	31 97       	sbiw	r30, 0x01	; 1
     ae2:	60 e1       	ldi	r22, 0x10	; 16
     ae4:	60 83       	st	Z, r22
     ae6:	31 97       	sbiw	r30, 0x01	; 1
     ae8:	30 83       	st	Z, r19
     aea:	31 97       	sbiw	r30, 0x01	; 1
     aec:	32 e1       	ldi	r19, 0x12	; 18
     aee:	30 83       	st	Z, r19
     af0:	31 97       	sbiw	r30, 0x01	; 1
     af2:	33 e1       	ldi	r19, 0x13	; 19
     af4:	30 83       	st	Z, r19
     af6:	31 97       	sbiw	r30, 0x01	; 1
     af8:	34 e1       	ldi	r19, 0x14	; 20
     afa:	30 83       	st	Z, r19
     afc:	31 97       	sbiw	r30, 0x01	; 1
     afe:	35 e1       	ldi	r19, 0x15	; 21
     b00:	30 83       	st	Z, r19
     b02:	31 97       	sbiw	r30, 0x01	; 1
     b04:	36 e1       	ldi	r19, 0x16	; 22
     b06:	30 83       	st	Z, r19
     b08:	31 97       	sbiw	r30, 0x01	; 1
     b0a:	37 e1       	ldi	r19, 0x17	; 23
     b0c:	30 83       	st	Z, r19
     b0e:	31 97       	sbiw	r30, 0x01	; 1
     b10:	38 e1       	ldi	r19, 0x18	; 24
     b12:	30 83       	st	Z, r19
     b14:	31 97       	sbiw	r30, 0x01	; 1
     b16:	39 e1       	ldi	r19, 0x19	; 25
     b18:	30 83       	st	Z, r19
     b1a:	31 97       	sbiw	r30, 0x01	; 1
     b1c:	30 e2       	ldi	r19, 0x20	; 32
     b1e:	30 83       	st	Z, r19
     b20:	31 97       	sbiw	r30, 0x01	; 1
     b22:	31 e2       	ldi	r19, 0x21	; 33
     b24:	30 83       	st	Z, r19
     b26:	31 97       	sbiw	r30, 0x01	; 1
     b28:	20 83       	st	Z, r18
     b2a:	31 97       	sbiw	r30, 0x01	; 1
     b2c:	23 e2       	ldi	r18, 0x23	; 35
     b2e:	20 83       	st	Z, r18
     b30:	31 97       	sbiw	r30, 0x01	; 1
     b32:	40 83       	st	Z, r20
     b34:	31 97       	sbiw	r30, 0x01	; 1
     b36:	50 83       	st	Z, r21
     b38:	31 97       	sbiw	r30, 0x01	; 1
     b3a:	26 e2       	ldi	r18, 0x26	; 38
     b3c:	20 83       	st	Z, r18
     b3e:	31 97       	sbiw	r30, 0x01	; 1
     b40:	27 e2       	ldi	r18, 0x27	; 39
     b42:	20 83       	st	Z, r18
     b44:	31 97       	sbiw	r30, 0x01	; 1
     b46:	28 e2       	ldi	r18, 0x28	; 40
     b48:	20 83       	st	Z, r18
     b4a:	31 97       	sbiw	r30, 0x01	; 1
     b4c:	29 e2       	ldi	r18, 0x29	; 41
     b4e:	20 83       	st	Z, r18
     b50:	31 97       	sbiw	r30, 0x01	; 1
     b52:	20 e3       	ldi	r18, 0x30	; 48
     b54:	20 83       	st	Z, r18
     b56:	31 97       	sbiw	r30, 0x01	; 1
     b58:	21 e3       	ldi	r18, 0x31	; 49
     b5a:	20 83       	st	Z, r18
     b5c:	86 97       	sbiw	r24, 0x26	; 38
     b5e:	08 95       	ret

00000b60 <xPortStartScheduler>:
     b60:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
     b64:	89 ef       	ldi	r24, 0xF9	; 249
     b66:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
     b6a:	e1 e8       	ldi	r30, 0x81	; 129
     b6c:	f0 e0       	ldi	r31, 0x00	; 0
     b6e:	80 81       	ld	r24, Z
     b70:	8b 60       	ori	r24, 0x0B	; 11
     b72:	80 83       	st	Z, r24
     b74:	ef e6       	ldi	r30, 0x6F	; 111
     b76:	f0 e0       	ldi	r31, 0x00	; 0
     b78:	80 81       	ld	r24, Z
     b7a:	82 60       	ori	r24, 0x02	; 2
     b7c:	80 83       	st	Z, r24
     b7e:	a0 91 96 01 	lds	r26, 0x0196	; 0x800196 <pxCurrentTCB>
     b82:	b0 91 97 01 	lds	r27, 0x0197	; 0x800197 <pxCurrentTCB+0x1>
     b86:	cd 91       	ld	r28, X+
     b88:	cd bf       	out	0x3d, r28	; 61
     b8a:	dd 91       	ld	r29, X+
     b8c:	de bf       	out	0x3e, r29	; 62
     b8e:	ff 91       	pop	r31
     b90:	ef 91       	pop	r30
     b92:	df 91       	pop	r29
     b94:	cf 91       	pop	r28
     b96:	bf 91       	pop	r27
     b98:	af 91       	pop	r26
     b9a:	9f 91       	pop	r25
     b9c:	8f 91       	pop	r24
     b9e:	7f 91       	pop	r23
     ba0:	6f 91       	pop	r22
     ba2:	5f 91       	pop	r21
     ba4:	4f 91       	pop	r20
     ba6:	3f 91       	pop	r19
     ba8:	2f 91       	pop	r18
     baa:	1f 91       	pop	r17
     bac:	0f 91       	pop	r16
     bae:	ff 90       	pop	r15
     bb0:	ef 90       	pop	r14
     bb2:	df 90       	pop	r13
     bb4:	cf 90       	pop	r12
     bb6:	bf 90       	pop	r11
     bb8:	af 90       	pop	r10
     bba:	9f 90       	pop	r9
     bbc:	8f 90       	pop	r8
     bbe:	7f 90       	pop	r7
     bc0:	6f 90       	pop	r6
     bc2:	5f 90       	pop	r5
     bc4:	4f 90       	pop	r4
     bc6:	3f 90       	pop	r3
     bc8:	2f 90       	pop	r2
     bca:	1f 90       	pop	r1
     bcc:	0f 90       	pop	r0
     bce:	0f be       	out	0x3f, r0	; 63
     bd0:	0f 90       	pop	r0
     bd2:	08 95       	ret
     bd4:	81 e0       	ldi	r24, 0x01	; 1
     bd6:	08 95       	ret

00000bd8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     bd8:	0f 92       	push	r0
     bda:	0f b6       	in	r0, 0x3f	; 63
     bdc:	f8 94       	cli
     bde:	0f 92       	push	r0
     be0:	1f 92       	push	r1
     be2:	11 24       	eor	r1, r1
     be4:	2f 92       	push	r2
     be6:	3f 92       	push	r3
     be8:	4f 92       	push	r4
     bea:	5f 92       	push	r5
     bec:	6f 92       	push	r6
     bee:	7f 92       	push	r7
     bf0:	8f 92       	push	r8
     bf2:	9f 92       	push	r9
     bf4:	af 92       	push	r10
     bf6:	bf 92       	push	r11
     bf8:	cf 92       	push	r12
     bfa:	df 92       	push	r13
     bfc:	ef 92       	push	r14
     bfe:	ff 92       	push	r15
     c00:	0f 93       	push	r16
     c02:	1f 93       	push	r17
     c04:	2f 93       	push	r18
     c06:	3f 93       	push	r19
     c08:	4f 93       	push	r20
     c0a:	5f 93       	push	r21
     c0c:	6f 93       	push	r22
     c0e:	7f 93       	push	r23
     c10:	8f 93       	push	r24
     c12:	9f 93       	push	r25
     c14:	af 93       	push	r26
     c16:	bf 93       	push	r27
     c18:	cf 93       	push	r28
     c1a:	df 93       	push	r29
     c1c:	ef 93       	push	r30
     c1e:	ff 93       	push	r31
     c20:	a0 91 96 01 	lds	r26, 0x0196	; 0x800196 <pxCurrentTCB>
     c24:	b0 91 97 01 	lds	r27, 0x0197	; 0x800197 <pxCurrentTCB+0x1>
     c28:	0d b6       	in	r0, 0x3d	; 61
     c2a:	0d 92       	st	X+, r0
     c2c:	0e b6       	in	r0, 0x3e	; 62
     c2e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     c30:	0e 94 1e 04 	call	0x83c	; 0x83c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     c34:	a0 91 96 01 	lds	r26, 0x0196	; 0x800196 <pxCurrentTCB>
     c38:	b0 91 97 01 	lds	r27, 0x0197	; 0x800197 <pxCurrentTCB+0x1>
     c3c:	cd 91       	ld	r28, X+
     c3e:	cd bf       	out	0x3d, r28	; 61
     c40:	dd 91       	ld	r29, X+
     c42:	de bf       	out	0x3e, r29	; 62
     c44:	ff 91       	pop	r31
     c46:	ef 91       	pop	r30
     c48:	df 91       	pop	r29
     c4a:	cf 91       	pop	r28
     c4c:	bf 91       	pop	r27
     c4e:	af 91       	pop	r26
     c50:	9f 91       	pop	r25
     c52:	8f 91       	pop	r24
     c54:	7f 91       	pop	r23
     c56:	6f 91       	pop	r22
     c58:	5f 91       	pop	r21
     c5a:	4f 91       	pop	r20
     c5c:	3f 91       	pop	r19
     c5e:	2f 91       	pop	r18
     c60:	1f 91       	pop	r17
     c62:	0f 91       	pop	r16
     c64:	ff 90       	pop	r15
     c66:	ef 90       	pop	r14
     c68:	df 90       	pop	r13
     c6a:	cf 90       	pop	r12
     c6c:	bf 90       	pop	r11
     c6e:	af 90       	pop	r10
     c70:	9f 90       	pop	r9
     c72:	8f 90       	pop	r8
     c74:	7f 90       	pop	r7
     c76:	6f 90       	pop	r6
     c78:	5f 90       	pop	r5
     c7a:	4f 90       	pop	r4
     c7c:	3f 90       	pop	r3
     c7e:	2f 90       	pop	r2
     c80:	1f 90       	pop	r1
     c82:	0f 90       	pop	r0
     c84:	0f be       	out	0x3f, r0	; 63
     c86:	0f 90       	pop	r0

	asm volatile ( "ret" );
     c88:	08 95       	ret

00000c8a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     c8a:	0f 92       	push	r0
     c8c:	0f b6       	in	r0, 0x3f	; 63
     c8e:	f8 94       	cli
     c90:	0f 92       	push	r0
     c92:	1f 92       	push	r1
     c94:	11 24       	eor	r1, r1
     c96:	2f 92       	push	r2
     c98:	3f 92       	push	r3
     c9a:	4f 92       	push	r4
     c9c:	5f 92       	push	r5
     c9e:	6f 92       	push	r6
     ca0:	7f 92       	push	r7
     ca2:	8f 92       	push	r8
     ca4:	9f 92       	push	r9
     ca6:	af 92       	push	r10
     ca8:	bf 92       	push	r11
     caa:	cf 92       	push	r12
     cac:	df 92       	push	r13
     cae:	ef 92       	push	r14
     cb0:	ff 92       	push	r15
     cb2:	0f 93       	push	r16
     cb4:	1f 93       	push	r17
     cb6:	2f 93       	push	r18
     cb8:	3f 93       	push	r19
     cba:	4f 93       	push	r20
     cbc:	5f 93       	push	r21
     cbe:	6f 93       	push	r22
     cc0:	7f 93       	push	r23
     cc2:	8f 93       	push	r24
     cc4:	9f 93       	push	r25
     cc6:	af 93       	push	r26
     cc8:	bf 93       	push	r27
     cca:	cf 93       	push	r28
     ccc:	df 93       	push	r29
     cce:	ef 93       	push	r30
     cd0:	ff 93       	push	r31
     cd2:	a0 91 96 01 	lds	r26, 0x0196	; 0x800196 <pxCurrentTCB>
     cd6:	b0 91 97 01 	lds	r27, 0x0197	; 0x800197 <pxCurrentTCB+0x1>
     cda:	0d b6       	in	r0, 0x3d	; 61
     cdc:	0d 92       	st	X+, r0
     cde:	0e b6       	in	r0, 0x3e	; 62
     ce0:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     ce2:	0e 94 69 02 	call	0x4d2	; 0x4d2 <xTaskIncrementTick>
     ce6:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     ce8:	0e 94 1e 04 	call	0x83c	; 0x83c <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     cec:	a0 91 96 01 	lds	r26, 0x0196	; 0x800196 <pxCurrentTCB>
     cf0:	b0 91 97 01 	lds	r27, 0x0197	; 0x800197 <pxCurrentTCB+0x1>
     cf4:	cd 91       	ld	r28, X+
     cf6:	cd bf       	out	0x3d, r28	; 61
     cf8:	dd 91       	ld	r29, X+
     cfa:	de bf       	out	0x3e, r29	; 62
     cfc:	ff 91       	pop	r31
     cfe:	ef 91       	pop	r30
     d00:	df 91       	pop	r29
     d02:	cf 91       	pop	r28
     d04:	bf 91       	pop	r27
     d06:	af 91       	pop	r26
     d08:	9f 91       	pop	r25
     d0a:	8f 91       	pop	r24
     d0c:	7f 91       	pop	r23
     d0e:	6f 91       	pop	r22
     d10:	5f 91       	pop	r21
     d12:	4f 91       	pop	r20
     d14:	3f 91       	pop	r19
     d16:	2f 91       	pop	r18
     d18:	1f 91       	pop	r17
     d1a:	0f 91       	pop	r16
     d1c:	ff 90       	pop	r15
     d1e:	ef 90       	pop	r14
     d20:	df 90       	pop	r13
     d22:	cf 90       	pop	r12
     d24:	bf 90       	pop	r11
     d26:	af 90       	pop	r10
     d28:	9f 90       	pop	r9
     d2a:	8f 90       	pop	r8
     d2c:	7f 90       	pop	r7
     d2e:	6f 90       	pop	r6
     d30:	5f 90       	pop	r5
     d32:	4f 90       	pop	r4
     d34:	3f 90       	pop	r3
     d36:	2f 90       	pop	r2
     d38:	1f 90       	pop	r1
     d3a:	0f 90       	pop	r0
     d3c:	0f be       	out	0x3f, r0	; 63
     d3e:	0f 90       	pop	r0

	asm volatile ( "ret" );
     d40:	08 95       	ret

00000d42 <__vector_11>:
	
	
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     d42:	0e 94 45 06 	call	0xc8a	; 0xc8a <vPortYieldFromTick>
		asm volatile ( "reti" );
     d46:	18 95       	reti

00000d48 <_ZN14HardwareSerial9availableEv>:
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
     d48:	fc 01       	movw	r30, r24
     d4a:	21 8d       	ldd	r18, Z+25	; 0x19
     d4c:	30 e0       	ldi	r19, 0x00	; 0
     d4e:	20 5c       	subi	r18, 0xC0	; 192
     d50:	3f 4f       	sbci	r19, 0xFF	; 255
     d52:	82 8d       	ldd	r24, Z+26	; 0x1a
     d54:	a9 01       	movw	r20, r18
     d56:	48 1b       	sub	r20, r24
     d58:	51 09       	sbc	r21, r1
     d5a:	ca 01       	movw	r24, r20
     d5c:	8f 73       	andi	r24, 0x3F	; 63
     d5e:	99 27       	eor	r25, r25
     d60:	08 95       	ret

00000d62 <_ZN14HardwareSerial4peekEv>:
     d62:	fc 01       	movw	r30, r24
     d64:	91 8d       	ldd	r25, Z+25	; 0x19
     d66:	82 8d       	ldd	r24, Z+26	; 0x1a
     d68:	98 17       	cp	r25, r24
     d6a:	31 f0       	breq	.+12     	; 0xd78 <_ZN14HardwareSerial4peekEv+0x16>
     d6c:	82 8d       	ldd	r24, Z+26	; 0x1a
     d6e:	e8 0f       	add	r30, r24
     d70:	f1 1d       	adc	r31, r1
     d72:	85 8d       	ldd	r24, Z+29	; 0x1d
     d74:	90 e0       	ldi	r25, 0x00	; 0
     d76:	08 95       	ret
     d78:	8f ef       	ldi	r24, 0xFF	; 255
     d7a:	9f ef       	ldi	r25, 0xFF	; 255
     d7c:	08 95       	ret

00000d7e <_ZN14HardwareSerial4readEv>:
     d7e:	fc 01       	movw	r30, r24
     d80:	91 8d       	ldd	r25, Z+25	; 0x19
     d82:	82 8d       	ldd	r24, Z+26	; 0x1a
     d84:	98 17       	cp	r25, r24
     d86:	61 f0       	breq	.+24     	; 0xda0 <_ZN14HardwareSerial4readEv+0x22>
     d88:	82 8d       	ldd	r24, Z+26	; 0x1a
     d8a:	df 01       	movw	r26, r30
     d8c:	a8 0f       	add	r26, r24
     d8e:	b1 1d       	adc	r27, r1
     d90:	5d 96       	adiw	r26, 0x1d	; 29
     d92:	8c 91       	ld	r24, X
     d94:	92 8d       	ldd	r25, Z+26	; 0x1a
     d96:	9f 5f       	subi	r25, 0xFF	; 255
     d98:	9f 73       	andi	r25, 0x3F	; 63
     d9a:	92 8f       	std	Z+26, r25	; 0x1a
     d9c:	90 e0       	ldi	r25, 0x00	; 0
     d9e:	08 95       	ret
     da0:	8f ef       	ldi	r24, 0xFF	; 255
     da2:	9f ef       	ldi	r25, 0xFF	; 255
     da4:	08 95       	ret

00000da6 <_ZN14HardwareSerial17availableForWriteEv>:
     da6:	fc 01       	movw	r30, r24
     da8:	23 8d       	ldd	r18, Z+27	; 0x1b
     daa:	34 8d       	ldd	r19, Z+28	; 0x1c
     dac:	23 17       	cp	r18, r19
     dae:	38 f0       	brcs	.+14     	; 0xdbe <_ZN14HardwareSerial17availableForWriteEv+0x18>
     db0:	8f e3       	ldi	r24, 0x3F	; 63
     db2:	90 e0       	ldi	r25, 0x00	; 0
     db4:	82 1b       	sub	r24, r18
     db6:	91 09       	sbc	r25, r1
     db8:	83 0f       	add	r24, r19
     dba:	91 1d       	adc	r25, r1
     dbc:	08 95       	ret
     dbe:	83 2f       	mov	r24, r19
     dc0:	90 e0       	ldi	r25, 0x00	; 0
     dc2:	82 1b       	sub	r24, r18
     dc4:	91 09       	sbc	r25, r1
     dc6:	01 97       	sbiw	r24, 0x01	; 1
     dc8:	08 95       	ret

00000dca <_ZN14HardwareSerial5writeEh>:
     dca:	fc 01       	movw	r30, r24
     dcc:	81 e0       	ldi	r24, 0x01	; 1
     dce:	80 8f       	std	Z+24, r24	; 0x18
     dd0:	93 8d       	ldd	r25, Z+27	; 0x1b
     dd2:	84 8d       	ldd	r24, Z+28	; 0x1c
     dd4:	98 13       	cpse	r25, r24
     dd6:	07 c0       	rjmp	.+14     	; 0xde6 <_ZN14HardwareSerial5writeEh+0x1c>
     dd8:	a0 89       	ldd	r26, Z+16	; 0x10
     dda:	b1 89       	ldd	r27, Z+17	; 0x11
     ddc:	8c 91       	ld	r24, X
     dde:	85 fd       	sbrc	r24, 5
     de0:	04 c0       	rjmp	.+8      	; 0xdea <_ZN14HardwareSerial5writeEh+0x20>
     de2:	80 e0       	ldi	r24, 0x00	; 0
     de4:	03 c0       	rjmp	.+6      	; 0xdec <_ZN14HardwareSerial5writeEh+0x22>
     de6:	80 e0       	ldi	r24, 0x00	; 0
     de8:	01 c0       	rjmp	.+2      	; 0xdec <_ZN14HardwareSerial5writeEh+0x22>
     dea:	81 e0       	ldi	r24, 0x01	; 1
     dec:	88 23       	and	r24, r24
     dee:	91 f0       	breq	.+36     	; 0xe14 <_ZN14HardwareSerial5writeEh+0x4a>
     df0:	9f b7       	in	r25, 0x3f	; 63
     df2:	f8 94       	cli
     df4:	81 e0       	ldi	r24, 0x01	; 1
     df6:	88 23       	and	r24, r24
     df8:	59 f0       	breq	.+22     	; 0xe10 <_ZN14HardwareSerial5writeEh+0x46>
     dfa:	a6 89       	ldd	r26, Z+22	; 0x16
     dfc:	b7 89       	ldd	r27, Z+23	; 0x17
     dfe:	6c 93       	st	X, r22
     e00:	a0 89       	ldd	r26, Z+16	; 0x10
     e02:	b1 89       	ldd	r27, Z+17	; 0x11
     e04:	8c 91       	ld	r24, X
     e06:	83 70       	andi	r24, 0x03	; 3
     e08:	80 64       	ori	r24, 0x40	; 64
     e0a:	8c 93       	st	X, r24
     e0c:	80 e0       	ldi	r24, 0x00	; 0
     e0e:	f3 cf       	rjmp	.-26     	; 0xdf6 <_ZN14HardwareSerial5writeEh+0x2c>
     e10:	9f bf       	out	0x3f, r25	; 63
     e12:	55 c0       	rjmp	.+170    	; 0xebe <_ZN14HardwareSerial5writeEh+0xf4>
     e14:	83 8d       	ldd	r24, Z+27	; 0x1b
     e16:	90 e0       	ldi	r25, 0x00	; 0
     e18:	01 96       	adiw	r24, 0x01	; 1
     e1a:	8f 73       	andi	r24, 0x3F	; 63
     e1c:	90 78       	andi	r25, 0x80	; 128
     e1e:	99 23       	and	r25, r25
     e20:	24 f4       	brge	.+8      	; 0xe2a <_ZN14HardwareSerial5writeEh+0x60>
     e22:	01 97       	sbiw	r24, 0x01	; 1
     e24:	80 6c       	ori	r24, 0xC0	; 192
     e26:	9f 6f       	ori	r25, 0xFF	; 255
     e28:	01 96       	adiw	r24, 0x01	; 1
     e2a:	98 2f       	mov	r25, r24
     e2c:	84 8d       	ldd	r24, Z+28	; 0x1c
     e2e:	98 13       	cpse	r25, r24
     e30:	31 c0       	rjmp	.+98     	; 0xe94 <_ZN14HardwareSerial5writeEh+0xca>
     e32:	0f b6       	in	r0, 0x3f	; 63
     e34:	07 fc       	sbrc	r0, 7
     e36:	fa cf       	rjmp	.-12     	; 0xe2c <_ZN14HardwareSerial5writeEh+0x62>
     e38:	a0 89       	ldd	r26, Z+16	; 0x10
     e3a:	b1 89       	ldd	r27, Z+17	; 0x11
     e3c:	8c 91       	ld	r24, X
     e3e:	85 ff       	sbrs	r24, 5
     e40:	f5 cf       	rjmp	.-22     	; 0xe2c <_ZN14HardwareSerial5writeEh+0x62>
     e42:	84 8d       	ldd	r24, Z+28	; 0x1c
     e44:	df 01       	movw	r26, r30
     e46:	a8 0f       	add	r26, r24
     e48:	b1 1d       	adc	r27, r1
     e4a:	a3 5a       	subi	r26, 0xA3	; 163
     e4c:	bf 4f       	sbci	r27, 0xFF	; 255
     e4e:	8c 91       	ld	r24, X
     e50:	24 8d       	ldd	r18, Z+28	; 0x1c
     e52:	30 e0       	ldi	r19, 0x00	; 0
     e54:	2f 5f       	subi	r18, 0xFF	; 255
     e56:	3f 4f       	sbci	r19, 0xFF	; 255
     e58:	2f 73       	andi	r18, 0x3F	; 63
     e5a:	30 78       	andi	r19, 0x80	; 128
     e5c:	33 23       	and	r19, r19
     e5e:	34 f4       	brge	.+12     	; 0xe6c <_ZN14HardwareSerial5writeEh+0xa2>
     e60:	21 50       	subi	r18, 0x01	; 1
     e62:	31 09       	sbc	r19, r1
     e64:	20 6c       	ori	r18, 0xC0	; 192
     e66:	3f 6f       	ori	r19, 0xFF	; 255
     e68:	2f 5f       	subi	r18, 0xFF	; 255
     e6a:	3f 4f       	sbci	r19, 0xFF	; 255
     e6c:	24 8f       	std	Z+28, r18	; 0x1c
     e6e:	a6 89       	ldd	r26, Z+22	; 0x16
     e70:	b7 89       	ldd	r27, Z+23	; 0x17
     e72:	8c 93       	st	X, r24
     e74:	a0 89       	ldd	r26, Z+16	; 0x10
     e76:	b1 89       	ldd	r27, Z+17	; 0x11
     e78:	8c 91       	ld	r24, X
     e7a:	83 70       	andi	r24, 0x03	; 3
     e7c:	80 64       	ori	r24, 0x40	; 64
     e7e:	8c 93       	st	X, r24
     e80:	23 8d       	ldd	r18, Z+27	; 0x1b
     e82:	84 8d       	ldd	r24, Z+28	; 0x1c
     e84:	28 13       	cpse	r18, r24
     e86:	d2 cf       	rjmp	.-92     	; 0xe2c <_ZN14HardwareSerial5writeEh+0x62>
     e88:	a2 89       	ldd	r26, Z+18	; 0x12
     e8a:	b3 89       	ldd	r27, Z+19	; 0x13
     e8c:	8c 91       	ld	r24, X
     e8e:	8f 7d       	andi	r24, 0xDF	; 223
     e90:	8c 93       	st	X, r24
     e92:	cc cf       	rjmp	.-104    	; 0xe2c <_ZN14HardwareSerial5writeEh+0x62>
     e94:	83 8d       	ldd	r24, Z+27	; 0x1b
     e96:	df 01       	movw	r26, r30
     e98:	a8 0f       	add	r26, r24
     e9a:	b1 1d       	adc	r27, r1
     e9c:	a3 5a       	subi	r26, 0xA3	; 163
     e9e:	bf 4f       	sbci	r27, 0xFF	; 255
     ea0:	6c 93       	st	X, r22
     ea2:	2f b7       	in	r18, 0x3f	; 63
     ea4:	f8 94       	cli
     ea6:	81 e0       	ldi	r24, 0x01	; 1
     ea8:	88 23       	and	r24, r24
     eaa:	41 f0       	breq	.+16     	; 0xebc <_ZN14HardwareSerial5writeEh+0xf2>
     eac:	93 8f       	std	Z+27, r25	; 0x1b
     eae:	a2 89       	ldd	r26, Z+18	; 0x12
     eb0:	b3 89       	ldd	r27, Z+19	; 0x13
     eb2:	8c 91       	ld	r24, X
     eb4:	80 62       	ori	r24, 0x20	; 32
     eb6:	8c 93       	st	X, r24
     eb8:	80 e0       	ldi	r24, 0x00	; 0
     eba:	f6 cf       	rjmp	.-20     	; 0xea8 <_ZN14HardwareSerial5writeEh+0xde>
     ebc:	2f bf       	out	0x3f, r18	; 63
     ebe:	81 e0       	ldi	r24, 0x01	; 1
     ec0:	90 e0       	ldi	r25, 0x00	; 0
     ec2:	08 95       	ret

00000ec4 <_ZN14HardwareSerial5flushEv>:
     ec4:	cf 93       	push	r28
     ec6:	df 93       	push	r29
     ec8:	dc 01       	movw	r26, r24
     eca:	58 96       	adiw	r26, 0x18	; 24
     ecc:	8c 91       	ld	r24, X
     ece:	58 97       	sbiw	r26, 0x18	; 24
     ed0:	88 23       	and	r24, r24
     ed2:	09 f4       	brne	.+2      	; 0xed6 <_ZN14HardwareSerial5flushEv+0x12>
     ed4:	61 c0       	rjmp	.+194    	; 0xf98 <_ZN14HardwareSerial5flushEv+0xd4>
     ed6:	52 96       	adiw	r26, 0x12	; 18
     ed8:	ed 91       	ld	r30, X+
     eda:	fc 91       	ld	r31, X
     edc:	53 97       	sbiw	r26, 0x13	; 19
     ede:	90 81       	ld	r25, Z
     ee0:	95 fd       	sbrc	r25, 5
     ee2:	09 c0       	rjmp	.+18     	; 0xef6 <_ZN14HardwareSerial5flushEv+0x32>
     ee4:	50 96       	adiw	r26, 0x10	; 16
     ee6:	cd 91       	ld	r28, X+
     ee8:	dc 91       	ld	r29, X
     eea:	51 97       	sbiw	r26, 0x11	; 17
     eec:	98 81       	ld	r25, Y
     eee:	96 fd       	sbrc	r25, 6
     ef0:	04 c0       	rjmp	.+8      	; 0xefa <_ZN14HardwareSerial5flushEv+0x36>
     ef2:	98 2f       	mov	r25, r24
     ef4:	03 c0       	rjmp	.+6      	; 0xefc <_ZN14HardwareSerial5flushEv+0x38>
     ef6:	98 2f       	mov	r25, r24
     ef8:	01 c0       	rjmp	.+2      	; 0xefc <_ZN14HardwareSerial5flushEv+0x38>
     efa:	90 e0       	ldi	r25, 0x00	; 0
     efc:	99 23       	and	r25, r25
     efe:	09 f4       	brne	.+2      	; 0xf02 <_ZN14HardwareSerial5flushEv+0x3e>
     f00:	4b c0       	rjmp	.+150    	; 0xf98 <_ZN14HardwareSerial5flushEv+0xd4>
     f02:	0f b6       	in	r0, 0x3f	; 63
     f04:	07 fc       	sbrc	r0, 7
     f06:	05 c0       	rjmp	.+10     	; 0xf12 <_ZN14HardwareSerial5flushEv+0x4e>
     f08:	20 81       	ld	r18, Z
     f0a:	25 fd       	sbrc	r18, 5
     f0c:	03 c0       	rjmp	.+6      	; 0xf14 <_ZN14HardwareSerial5flushEv+0x50>
     f0e:	90 e0       	ldi	r25, 0x00	; 0
     f10:	01 c0       	rjmp	.+2      	; 0xf14 <_ZN14HardwareSerial5flushEv+0x50>
     f12:	90 e0       	ldi	r25, 0x00	; 0
     f14:	99 23       	and	r25, r25
     f16:	f9 f2       	breq	.-66     	; 0xed6 <_ZN14HardwareSerial5flushEv+0x12>
     f18:	50 96       	adiw	r26, 0x10	; 16
     f1a:	ed 91       	ld	r30, X+
     f1c:	fc 91       	ld	r31, X
     f1e:	51 97       	sbiw	r26, 0x11	; 17
     f20:	90 81       	ld	r25, Z
     f22:	95 ff       	sbrs	r25, 5
     f24:	d8 cf       	rjmp	.-80     	; 0xed6 <_ZN14HardwareSerial5flushEv+0x12>
     f26:	5c 96       	adiw	r26, 0x1c	; 28
     f28:	9c 91       	ld	r25, X
     f2a:	5c 97       	sbiw	r26, 0x1c	; 28
     f2c:	fd 01       	movw	r30, r26
     f2e:	e9 0f       	add	r30, r25
     f30:	f1 1d       	adc	r31, r1
     f32:	e3 5a       	subi	r30, 0xA3	; 163
     f34:	ff 4f       	sbci	r31, 0xFF	; 255
     f36:	90 81       	ld	r25, Z
     f38:	5c 96       	adiw	r26, 0x1c	; 28
     f3a:	2c 91       	ld	r18, X
     f3c:	5c 97       	sbiw	r26, 0x1c	; 28
     f3e:	30 e0       	ldi	r19, 0x00	; 0
     f40:	2f 5f       	subi	r18, 0xFF	; 255
     f42:	3f 4f       	sbci	r19, 0xFF	; 255
     f44:	2f 73       	andi	r18, 0x3F	; 63
     f46:	30 78       	andi	r19, 0x80	; 128
     f48:	33 23       	and	r19, r19
     f4a:	34 f4       	brge	.+12     	; 0xf58 <_ZN14HardwareSerial5flushEv+0x94>
     f4c:	21 50       	subi	r18, 0x01	; 1
     f4e:	31 09       	sbc	r19, r1
     f50:	20 6c       	ori	r18, 0xC0	; 192
     f52:	3f 6f       	ori	r19, 0xFF	; 255
     f54:	2f 5f       	subi	r18, 0xFF	; 255
     f56:	3f 4f       	sbci	r19, 0xFF	; 255
     f58:	5c 96       	adiw	r26, 0x1c	; 28
     f5a:	2c 93       	st	X, r18
     f5c:	5c 97       	sbiw	r26, 0x1c	; 28
     f5e:	56 96       	adiw	r26, 0x16	; 22
     f60:	ed 91       	ld	r30, X+
     f62:	fc 91       	ld	r31, X
     f64:	57 97       	sbiw	r26, 0x17	; 23
     f66:	90 83       	st	Z, r25
     f68:	50 96       	adiw	r26, 0x10	; 16
     f6a:	ed 91       	ld	r30, X+
     f6c:	fc 91       	ld	r31, X
     f6e:	51 97       	sbiw	r26, 0x11	; 17
     f70:	90 81       	ld	r25, Z
     f72:	93 70       	andi	r25, 0x03	; 3
     f74:	90 64       	ori	r25, 0x40	; 64
     f76:	90 83       	st	Z, r25
     f78:	5b 96       	adiw	r26, 0x1b	; 27
     f7a:	2c 91       	ld	r18, X
     f7c:	5b 97       	sbiw	r26, 0x1b	; 27
     f7e:	5c 96       	adiw	r26, 0x1c	; 28
     f80:	9c 91       	ld	r25, X
     f82:	5c 97       	sbiw	r26, 0x1c	; 28
     f84:	29 13       	cpse	r18, r25
     f86:	a7 cf       	rjmp	.-178    	; 0xed6 <_ZN14HardwareSerial5flushEv+0x12>
     f88:	52 96       	adiw	r26, 0x12	; 18
     f8a:	ed 91       	ld	r30, X+
     f8c:	fc 91       	ld	r31, X
     f8e:	53 97       	sbiw	r26, 0x13	; 19
     f90:	90 81       	ld	r25, Z
     f92:	9f 7d       	andi	r25, 0xDF	; 223
     f94:	90 83       	st	Z, r25
     f96:	9f cf       	rjmp	.-194    	; 0xed6 <_ZN14HardwareSerial5flushEv+0x12>
     f98:	df 91       	pop	r29
     f9a:	cf 91       	pop	r28
     f9c:	08 95       	ret

00000f9e <_ZN14HardwareSerial5beginEmh>:


// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud, uint8_t config)
{
     f9e:	bf 92       	push	r11
     fa0:	cf 92       	push	r12
     fa2:	df 92       	push	r13
     fa4:	ef 92       	push	r14
     fa6:	ff 92       	push	r15
     fa8:	0f 93       	push	r16
     faa:	1f 93       	push	r17
     fac:	cf 93       	push	r28
     fae:	df 93       	push	r29
     fb0:	ec 01       	movw	r28, r24
     fb2:	6a 01       	movw	r12, r20
     fb4:	7b 01       	movw	r14, r22
     fb6:	b2 2e       	mov	r11, r18
  // Try u2x mode first
  uint16_t baud_setting = (_f_cpu / 4 / baud - 1) / 2;
     fb8:	8c 01       	movw	r16, r24
     fba:	03 56       	subi	r16, 0x63	; 99
     fbc:	1f 4f       	sbci	r17, 0xFF	; 255
     fbe:	f8 01       	movw	r30, r16
     fc0:	80 81       	ld	r24, Z
     fc2:	91 81       	ldd	r25, Z+1	; 0x01
     fc4:	a2 81       	ldd	r26, Z+2	; 0x02
     fc6:	b3 81       	ldd	r27, Z+3	; 0x03
     fc8:	bc 01       	movw	r22, r24
     fca:	cd 01       	movw	r24, r26
     fcc:	96 95       	lsr	r25
     fce:	87 95       	ror	r24
     fd0:	77 95       	ror	r23
     fd2:	67 95       	ror	r22
     fd4:	96 95       	lsr	r25
     fd6:	87 95       	ror	r24
     fd8:	77 95       	ror	r23
     fda:	67 95       	ror	r22
     fdc:	a7 01       	movw	r20, r14
     fde:	96 01       	movw	r18, r12
     fe0:	0e 94 75 09 	call	0x12ea	; 0x12ea <__udivmodsi4>
     fe4:	da 01       	movw	r26, r20
     fe6:	c9 01       	movw	r24, r18
     fe8:	01 97       	sbiw	r24, 0x01	; 1
     fea:	a1 09       	sbc	r26, r1
     fec:	b1 09       	sbc	r27, r1
     fee:	b6 95       	lsr	r27
     ff0:	a7 95       	ror	r26
     ff2:	97 95       	ror	r25
     ff4:	87 95       	ror	r24
     ff6:	9c 01       	movw	r18, r24
  *_ucsra = 1 << U2X0;
     ff8:	e8 89       	ldd	r30, Y+16	; 0x10
     ffa:	f9 89       	ldd	r31, Y+17	; 0x11
     ffc:	82 e0       	ldi	r24, 0x02	; 2
     ffe:	80 83       	st	Z, r24
  // hardcoded exception for 57600 for compatibility with the bootloader
  // shipped with the Duemilanove and previous boards and the firmware
  // on the 8U2 on the Uno and Mega 2560. Also, The baud_setting cannot
  // be > 4095, so switch back to non-u2x mode if the baud rate is too
  // low.
  if (((_f_cpu == 16000000UL) && (baud == 57600)) || (baud_setting >4095))
    1000:	f8 01       	movw	r30, r16
    1002:	80 81       	ld	r24, Z
    1004:	91 81       	ldd	r25, Z+1	; 0x01
    1006:	a2 81       	ldd	r26, Z+2	; 0x02
    1008:	b3 81       	ldd	r27, Z+3	; 0x03
    100a:	81 15       	cp	r24, r1
    100c:	94 42       	sbci	r25, 0x24	; 36
    100e:	a4 4f       	sbci	r26, 0xF4	; 244
    1010:	b1 05       	cpc	r27, r1
    1012:	31 f4       	brne	.+12     	; 0x1020 <_ZN14HardwareSerial5beginEmh+0x82>
    1014:	c1 14       	cp	r12, r1
    1016:	41 ee       	ldi	r20, 0xE1	; 225
    1018:	d4 06       	cpc	r13, r20
    101a:	e1 04       	cpc	r14, r1
    101c:	f1 04       	cpc	r15, r1
    101e:	21 f0       	breq	.+8      	; 0x1028 <_ZN14HardwareSerial5beginEmh+0x8a>
    1020:	21 15       	cp	r18, r1
    1022:	80 e1       	ldi	r24, 0x10	; 16
    1024:	38 07       	cpc	r19, r24
    1026:	10 f1       	brcs	.+68     	; 0x106c <_ZN14HardwareSerial5beginEmh+0xce>
  {
    *_ucsra = 0;
    1028:	e8 89       	ldd	r30, Y+16	; 0x10
    102a:	f9 89       	ldd	r31, Y+17	; 0x11
    102c:	10 82       	st	Z, r1
    baud_setting = (_f_cpu / 8 / baud - 1) / 2;
    102e:	fe 01       	movw	r30, r28
    1030:	e3 56       	subi	r30, 0x63	; 99
    1032:	ff 4f       	sbci	r31, 0xFF	; 255
    1034:	80 81       	ld	r24, Z
    1036:	91 81       	ldd	r25, Z+1	; 0x01
    1038:	a2 81       	ldd	r26, Z+2	; 0x02
    103a:	b3 81       	ldd	r27, Z+3	; 0x03
    103c:	bc 01       	movw	r22, r24
    103e:	cd 01       	movw	r24, r26
    1040:	68 94       	set
    1042:	12 f8       	bld	r1, 2
    1044:	96 95       	lsr	r25
    1046:	87 95       	ror	r24
    1048:	77 95       	ror	r23
    104a:	67 95       	ror	r22
    104c:	16 94       	lsr	r1
    104e:	d1 f7       	brne	.-12     	; 0x1044 <_ZN14HardwareSerial5beginEmh+0xa6>
    1050:	a7 01       	movw	r20, r14
    1052:	96 01       	movw	r18, r12
    1054:	0e 94 75 09 	call	0x12ea	; 0x12ea <__udivmodsi4>
    1058:	da 01       	movw	r26, r20
    105a:	c9 01       	movw	r24, r18
    105c:	01 97       	sbiw	r24, 0x01	; 1
    105e:	a1 09       	sbc	r26, r1
    1060:	b1 09       	sbc	r27, r1
    1062:	b6 95       	lsr	r27
    1064:	a7 95       	ror	r26
    1066:	97 95       	ror	r25
    1068:	87 95       	ror	r24
    106a:	9c 01       	movw	r18, r24
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
    106c:	ec 85       	ldd	r30, Y+12	; 0x0c
    106e:	fd 85       	ldd	r31, Y+13	; 0x0d
    1070:	30 83       	st	Z, r19
  *_ubrrl = baud_setting;
    1072:	ee 85       	ldd	r30, Y+14	; 0x0e
    1074:	ff 85       	ldd	r31, Y+15	; 0x0f
    1076:	20 83       	st	Z, r18

  _written = false;
    1078:	18 8e       	std	Y+24, r1	; 0x18

  //set the data bits, parity, and stop bits
#if defined(__AVR_ATmega8__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
    107a:	ec 89       	ldd	r30, Y+20	; 0x14
    107c:	fd 89       	ldd	r31, Y+21	; 0x15
    107e:	b0 82       	st	Z, r11
  
  sbi(*_ucsrb, RXEN0);
    1080:	ea 89       	ldd	r30, Y+18	; 0x12
    1082:	fb 89       	ldd	r31, Y+19	; 0x13
    1084:	80 81       	ld	r24, Z
    1086:	80 61       	ori	r24, 0x10	; 16
    1088:	80 83       	st	Z, r24
  sbi(*_ucsrb, TXEN0);
    108a:	ea 89       	ldd	r30, Y+18	; 0x12
    108c:	fb 89       	ldd	r31, Y+19	; 0x13
    108e:	80 81       	ld	r24, Z
    1090:	88 60       	ori	r24, 0x08	; 8
    1092:	80 83       	st	Z, r24
  sbi(*_ucsrb, RXCIE0);
    1094:	ea 89       	ldd	r30, Y+18	; 0x12
    1096:	fb 89       	ldd	r31, Y+19	; 0x13
    1098:	80 81       	ld	r24, Z
    109a:	80 68       	ori	r24, 0x80	; 128
    109c:	80 83       	st	Z, r24
  cbi(*_ucsrb, UDRIE0);
    109e:	ea 89       	ldd	r30, Y+18	; 0x12
    10a0:	fb 89       	ldd	r31, Y+19	; 0x13
    10a2:	80 81       	ld	r24, Z
    10a4:	8f 7d       	andi	r24, 0xDF	; 223
    10a6:	80 83       	st	Z, r24
}
    10a8:	df 91       	pop	r29
    10aa:	cf 91       	pop	r28
    10ac:	1f 91       	pop	r17
    10ae:	0f 91       	pop	r16
    10b0:	ff 90       	pop	r15
    10b2:	ef 90       	pop	r14
    10b4:	df 90       	pop	r13
    10b6:	cf 90       	pop	r12
    10b8:	bf 90       	pop	r11
    10ba:	08 95       	ret

000010bc <_Z41__static_initialization_and_destruction_0ii>:

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
}
    10bc:	01 97       	sbiw	r24, 0x01	; 1
    10be:	d9 f5       	brne	.+118    	; 0x1136 <_Z41__static_initialization_and_destruction_0ii+0x7a>
    10c0:	6f 3f       	cpi	r22, 0xFF	; 255
    10c2:	7f 4f       	sbci	r23, 0xFF	; 255
    10c4:	c1 f5       	brne	.+112    	; 0x1136 <_Z41__static_initialization_and_destruction_0ii+0x7a>
    10c6:	e8 e7       	ldi	r30, 0x78	; 120
    10c8:	f7 e0       	ldi	r31, 0x07	; 7
    10ca:	13 82       	std	Z+3, r1	; 0x03
    10cc:	12 82       	std	Z+2, r1	; 0x02
    10ce:	88 ee       	ldi	r24, 0xE8	; 232
    10d0:	93 e0       	ldi	r25, 0x03	; 3
    10d2:	a0 e0       	ldi	r26, 0x00	; 0
    10d4:	b0 e0       	ldi	r27, 0x00	; 0
    10d6:	84 83       	std	Z+4, r24	; 0x04
    10d8:	95 83       	std	Z+5, r25	; 0x05
    10da:	a6 83       	std	Z+6, r26	; 0x06
    10dc:	b7 83       	std	Z+7, r27	; 0x07
    10de:	84 e1       	ldi	r24, 0x14	; 20
    10e0:	91 e0       	ldi	r25, 0x01	; 1
    10e2:	91 83       	std	Z+1, r25	; 0x01
    10e4:	80 83       	st	Z, r24
    10e6:	85 ec       	ldi	r24, 0xC5	; 197
    10e8:	90 e0       	ldi	r25, 0x00	; 0
    10ea:	95 87       	std	Z+13, r25	; 0x0d
    10ec:	84 87       	std	Z+12, r24	; 0x0c
    10ee:	84 ec       	ldi	r24, 0xC4	; 196
    10f0:	90 e0       	ldi	r25, 0x00	; 0
    10f2:	97 87       	std	Z+15, r25	; 0x0f
    10f4:	86 87       	std	Z+14, r24	; 0x0e
    10f6:	80 ec       	ldi	r24, 0xC0	; 192
    10f8:	90 e0       	ldi	r25, 0x00	; 0
    10fa:	91 8b       	std	Z+17, r25	; 0x11
    10fc:	80 8b       	std	Z+16, r24	; 0x10
    10fe:	81 ec       	ldi	r24, 0xC1	; 193
    1100:	90 e0       	ldi	r25, 0x00	; 0
    1102:	93 8b       	std	Z+19, r25	; 0x13
    1104:	82 8b       	std	Z+18, r24	; 0x12
    1106:	82 ec       	ldi	r24, 0xC2	; 194
    1108:	90 e0       	ldi	r25, 0x00	; 0
    110a:	95 8b       	std	Z+21, r25	; 0x15
    110c:	84 8b       	std	Z+20, r24	; 0x14
    110e:	86 ec       	ldi	r24, 0xC6	; 198
    1110:	90 e0       	ldi	r25, 0x00	; 0
    1112:	97 8b       	std	Z+23, r25	; 0x17
    1114:	86 8b       	std	Z+22, r24	; 0x16
    1116:	11 8e       	std	Z+25, r1	; 0x19
    1118:	12 8e       	std	Z+26, r1	; 0x1a
    111a:	13 8e       	std	Z+27, r1	; 0x1b
    111c:	14 8e       	std	Z+28, r1	; 0x1c
    111e:	80 e0       	ldi	r24, 0x00	; 0
    1120:	94 e2       	ldi	r25, 0x24	; 36
    1122:	a4 ef       	ldi	r26, 0xF4	; 244
    1124:	b0 e0       	ldi	r27, 0x00	; 0
    1126:	80 93 15 08 	sts	0x0815, r24	; 0x800815 <Serial+0x9d>
    112a:	90 93 16 08 	sts	0x0816, r25	; 0x800816 <Serial+0x9e>
    112e:	a0 93 17 08 	sts	0x0817, r26	; 0x800817 <Serial+0x9f>
    1132:	b0 93 18 08 	sts	0x0818, r27	; 0x800818 <Serial+0xa0>
    1136:	08 95       	ret

00001138 <__vector_18>:
    1138:	1f 92       	push	r1
    113a:	0f 92       	push	r0
    113c:	0f b6       	in	r0, 0x3f	; 63
    113e:	0f 92       	push	r0
    1140:	11 24       	eor	r1, r1
    1142:	2f 93       	push	r18
    1144:	8f 93       	push	r24
    1146:	9f 93       	push	r25
    1148:	af 93       	push	r26
    114a:	bf 93       	push	r27
    114c:	ef 93       	push	r30
    114e:	ff 93       	push	r31
    1150:	e0 91 88 07 	lds	r30, 0x0788	; 0x800788 <Serial+0x10>
    1154:	f0 91 89 07 	lds	r31, 0x0789	; 0x800789 <Serial+0x11>
    1158:	80 81       	ld	r24, Z
    115a:	82 fd       	sbrc	r24, 2
    115c:	14 c0       	rjmp	.+40     	; 0x1186 <__vector_18+0x4e>
    115e:	e8 e7       	ldi	r30, 0x78	; 120
    1160:	f7 e0       	ldi	r31, 0x07	; 7
    1162:	a6 89       	ldd	r26, Z+22	; 0x16
    1164:	b7 89       	ldd	r27, Z+23	; 0x17
    1166:	2c 91       	ld	r18, X
    1168:	81 8d       	ldd	r24, Z+25	; 0x19
    116a:	8f 5f       	subi	r24, 0xFF	; 255
    116c:	8f 73       	andi	r24, 0x3F	; 63
    116e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1170:	89 17       	cp	r24, r25
    1172:	71 f0       	breq	.+28     	; 0x1190 <__vector_18+0x58>
    1174:	df 01       	movw	r26, r30
    1176:	e1 8d       	ldd	r30, Z+25	; 0x19
    1178:	f0 e0       	ldi	r31, 0x00	; 0
    117a:	e8 58       	subi	r30, 0x88	; 136
    117c:	f8 4f       	sbci	r31, 0xF8	; 248
    117e:	25 8f       	std	Z+29, r18	; 0x1d
    1180:	59 96       	adiw	r26, 0x19	; 25
    1182:	8c 93       	st	X, r24
    1184:	05 c0       	rjmp	.+10     	; 0x1190 <__vector_18+0x58>
    1186:	e0 91 8e 07 	lds	r30, 0x078E	; 0x80078e <Serial+0x16>
    118a:	f0 91 8f 07 	lds	r31, 0x078F	; 0x80078f <Serial+0x17>
    118e:	80 81       	ld	r24, Z
    1190:	ff 91       	pop	r31
    1192:	ef 91       	pop	r30
    1194:	bf 91       	pop	r27
    1196:	af 91       	pop	r26
    1198:	9f 91       	pop	r25
    119a:	8f 91       	pop	r24
    119c:	2f 91       	pop	r18
    119e:	0f 90       	pop	r0
    11a0:	0f be       	out	0x3f, r0	; 63
    11a2:	0f 90       	pop	r0
    11a4:	1f 90       	pop	r1
    11a6:	18 95       	reti

000011a8 <__vector_19>:
    11a8:	1f 92       	push	r1
    11aa:	0f 92       	push	r0
    11ac:	0f b6       	in	r0, 0x3f	; 63
    11ae:	0f 92       	push	r0
    11b0:	11 24       	eor	r1, r1
    11b2:	2f 93       	push	r18
    11b4:	8f 93       	push	r24
    11b6:	9f 93       	push	r25
    11b8:	af 93       	push	r26
    11ba:	bf 93       	push	r27
    11bc:	ef 93       	push	r30
    11be:	ff 93       	push	r31
    11c0:	a8 e7       	ldi	r26, 0x78	; 120
    11c2:	b7 e0       	ldi	r27, 0x07	; 7
    11c4:	5c 96       	adiw	r26, 0x1c	; 28
    11c6:	ec 91       	ld	r30, X
    11c8:	5c 97       	sbiw	r26, 0x1c	; 28
    11ca:	f0 e0       	ldi	r31, 0x00	; 0
    11cc:	eb 52       	subi	r30, 0x2B	; 43
    11ce:	f8 4f       	sbci	r31, 0xF8	; 248
    11d0:	20 81       	ld	r18, Z
    11d2:	5c 96       	adiw	r26, 0x1c	; 28
    11d4:	8c 91       	ld	r24, X
    11d6:	90 e0       	ldi	r25, 0x00	; 0
    11d8:	01 96       	adiw	r24, 0x01	; 1
    11da:	8f 73       	andi	r24, 0x3F	; 63
    11dc:	90 78       	andi	r25, 0x80	; 128
    11de:	99 23       	and	r25, r25
    11e0:	24 f4       	brge	.+8      	; 0x11ea <__vector_19+0x42>
    11e2:	01 97       	sbiw	r24, 0x01	; 1
    11e4:	80 6c       	ori	r24, 0xC0	; 192
    11e6:	9f 6f       	ori	r25, 0xFF	; 255
    11e8:	01 96       	adiw	r24, 0x01	; 1
    11ea:	e8 e7       	ldi	r30, 0x78	; 120
    11ec:	f7 e0       	ldi	r31, 0x07	; 7
    11ee:	84 8f       	std	Z+28, r24	; 0x1c
    11f0:	a6 89       	ldd	r26, Z+22	; 0x16
    11f2:	b7 89       	ldd	r27, Z+23	; 0x17
    11f4:	2c 93       	st	X, r18
    11f6:	a0 89       	ldd	r26, Z+16	; 0x10
    11f8:	b1 89       	ldd	r27, Z+17	; 0x11
    11fa:	8c 91       	ld	r24, X
    11fc:	83 70       	andi	r24, 0x03	; 3
    11fe:	80 64       	ori	r24, 0x40	; 64
    1200:	8c 93       	st	X, r24
    1202:	93 8d       	ldd	r25, Z+27	; 0x1b
    1204:	84 8d       	ldd	r24, Z+28	; 0x1c
    1206:	98 13       	cpse	r25, r24
    1208:	07 c0       	rjmp	.+14     	; 0x1218 <__vector_19+0x70>
    120a:	e0 91 8a 07 	lds	r30, 0x078A	; 0x80078a <Serial+0x12>
    120e:	f0 91 8b 07 	lds	r31, 0x078B	; 0x80078b <Serial+0x13>
    1212:	80 81       	ld	r24, Z
    1214:	8f 7d       	andi	r24, 0xDF	; 223
    1216:	80 83       	st	Z, r24
    1218:	ff 91       	pop	r31
    121a:	ef 91       	pop	r30
    121c:	bf 91       	pop	r27
    121e:	af 91       	pop	r26
    1220:	9f 91       	pop	r25
    1222:	8f 91       	pop	r24
    1224:	2f 91       	pop	r18
    1226:	0f 90       	pop	r0
    1228:	0f be       	out	0x3f, r0	; 63
    122a:	0f 90       	pop	r0
    122c:	1f 90       	pop	r1
    122e:	18 95       	reti

00001230 <_GLOBAL__sub_I___vector_18>:
    1230:	6f ef       	ldi	r22, 0xFF	; 255
    1232:	7f ef       	ldi	r23, 0xFF	; 255
    1234:	81 e0       	ldi	r24, 0x01	; 1
    1236:	90 e0       	ldi	r25, 0x00	; 0
    1238:	0e 94 5e 08 	call	0x10bc	; 0x10bc <_Z41__static_initialization_and_destruction_0ii>
    123c:	08 95       	ret

0000123e <_ZN5Print5writeEPKhj>:
size_t Print::println(const char c[])
{
  size_t n = print(c);
  n += println();
  return n;
}
    123e:	cf 92       	push	r12
    1240:	df 92       	push	r13
    1242:	ef 92       	push	r14
    1244:	ff 92       	push	r15
    1246:	0f 93       	push	r16
    1248:	1f 93       	push	r17
    124a:	cf 93       	push	r28
    124c:	df 93       	push	r29
    124e:	8c 01       	movw	r16, r24
    1250:	db 01       	movw	r26, r22
    1252:	c0 e0       	ldi	r28, 0x00	; 0
    1254:	d0 e0       	ldi	r29, 0x00	; 0
    1256:	7a 01       	movw	r14, r20
    1258:	81 e0       	ldi	r24, 0x01	; 1
    125a:	e8 1a       	sub	r14, r24
    125c:	f1 08       	sbc	r15, r1
    125e:	45 2b       	or	r20, r21
    1260:	a1 f0       	breq	.+40     	; 0x128a <_ZN5Print5writeEPKhj+0x4c>
    1262:	f8 01       	movw	r30, r16
    1264:	80 81       	ld	r24, Z
    1266:	91 81       	ldd	r25, Z+1	; 0x01
    1268:	fc 01       	movw	r30, r24
    126a:	20 81       	ld	r18, Z
    126c:	31 81       	ldd	r19, Z+1	; 0x01
    126e:	6d 01       	movw	r12, r26
    1270:	ff ef       	ldi	r31, 0xFF	; 255
    1272:	cf 1a       	sub	r12, r31
    1274:	df 0a       	sbc	r13, r31
    1276:	6c 91       	ld	r22, X
    1278:	c8 01       	movw	r24, r16
    127a:	f9 01       	movw	r30, r18
    127c:	09 95       	icall
    127e:	89 2b       	or	r24, r25
    1280:	21 f0       	breq	.+8      	; 0x128a <_ZN5Print5writeEPKhj+0x4c>
    1282:	21 96       	adiw	r28, 0x01	; 1
    1284:	a7 01       	movw	r20, r14
    1286:	d6 01       	movw	r26, r12
    1288:	e6 cf       	rjmp	.-52     	; 0x1256 <_ZN5Print5writeEPKhj+0x18>
    128a:	ce 01       	movw	r24, r28
    128c:	df 91       	pop	r29
    128e:	cf 91       	pop	r28
    1290:	1f 91       	pop	r17
    1292:	0f 91       	pop	r16
    1294:	ff 90       	pop	r15
    1296:	ef 90       	pop	r14
    1298:	df 90       	pop	r13
    129a:	cf 90       	pop	r12
    129c:	08 95       	ret

0000129e <_ZN5Print5printEc>:
    129e:	dc 01       	movw	r26, r24
    12a0:	ed 91       	ld	r30, X+
    12a2:	fc 91       	ld	r31, X
    12a4:	01 90       	ld	r0, Z+
    12a6:	f0 81       	ld	r31, Z
    12a8:	e0 2d       	mov	r30, r0
    12aa:	09 95       	icall
    12ac:	08 95       	ret

000012ae <_ZN5Print7printlnEv>:
    12ae:	dc 01       	movw	r26, r24
    12b0:	ed 91       	ld	r30, X+
    12b2:	fc 91       	ld	r31, X
    12b4:	02 80       	ldd	r0, Z+2	; 0x02
    12b6:	f3 81       	ldd	r31, Z+3	; 0x03
    12b8:	e0 2d       	mov	r30, r0
    12ba:	42 e0       	ldi	r20, 0x02	; 2
    12bc:	50 e0       	ldi	r21, 0x00	; 0
    12be:	62 e2       	ldi	r22, 0x22	; 34
    12c0:	71 e0       	ldi	r23, 0x01	; 1
    12c2:	09 95       	icall
    12c4:	08 95       	ret

000012c6 <_ZN5Print7printlnEc>:

size_t Print::println(char c)
{
    12c6:	0f 93       	push	r16
    12c8:	1f 93       	push	r17
    12ca:	cf 93       	push	r28
    12cc:	df 93       	push	r29
    12ce:	ec 01       	movw	r28, r24
  size_t n = print(c);
    12d0:	0e 94 4f 09 	call	0x129e	; 0x129e <_ZN5Print5printEc>
    12d4:	8c 01       	movw	r16, r24
  n += println();
    12d6:	ce 01       	movw	r24, r28
    12d8:	0e 94 57 09 	call	0x12ae	; 0x12ae <_ZN5Print7printlnEv>
  return n;
}
    12dc:	80 0f       	add	r24, r16
    12de:	91 1f       	adc	r25, r17
    12e0:	df 91       	pop	r29
    12e2:	cf 91       	pop	r28
    12e4:	1f 91       	pop	r17
    12e6:	0f 91       	pop	r16
    12e8:	08 95       	ret

000012ea <__udivmodsi4>:
    12ea:	a1 e2       	ldi	r26, 0x21	; 33
    12ec:	1a 2e       	mov	r1, r26
    12ee:	aa 1b       	sub	r26, r26
    12f0:	bb 1b       	sub	r27, r27
    12f2:	fd 01       	movw	r30, r26
    12f4:	0d c0       	rjmp	.+26     	; 0x1310 <__udivmodsi4_ep>

000012f6 <__udivmodsi4_loop>:
    12f6:	aa 1f       	adc	r26, r26
    12f8:	bb 1f       	adc	r27, r27
    12fa:	ee 1f       	adc	r30, r30
    12fc:	ff 1f       	adc	r31, r31
    12fe:	a2 17       	cp	r26, r18
    1300:	b3 07       	cpc	r27, r19
    1302:	e4 07       	cpc	r30, r20
    1304:	f5 07       	cpc	r31, r21
    1306:	20 f0       	brcs	.+8      	; 0x1310 <__udivmodsi4_ep>
    1308:	a2 1b       	sub	r26, r18
    130a:	b3 0b       	sbc	r27, r19
    130c:	e4 0b       	sbc	r30, r20
    130e:	f5 0b       	sbc	r31, r21

00001310 <__udivmodsi4_ep>:
    1310:	66 1f       	adc	r22, r22
    1312:	77 1f       	adc	r23, r23
    1314:	88 1f       	adc	r24, r24
    1316:	99 1f       	adc	r25, r25
    1318:	1a 94       	dec	r1
    131a:	69 f7       	brne	.-38     	; 0x12f6 <__udivmodsi4_loop>
    131c:	60 95       	com	r22
    131e:	70 95       	com	r23
    1320:	80 95       	com	r24
    1322:	90 95       	com	r25
    1324:	9b 01       	movw	r18, r22
    1326:	ac 01       	movw	r20, r24
    1328:	bd 01       	movw	r22, r26
    132a:	cf 01       	movw	r24, r30
    132c:	08 95       	ret

0000132e <__tablejump2__>:
    132e:	ee 0f       	add	r30, r30
    1330:	ff 1f       	adc	r31, r31
    1332:	05 90       	lpm	r0, Z+
    1334:	f4 91       	lpm	r31, Z
    1336:	e0 2d       	mov	r30, r0
    1338:	09 94       	ijmp

0000133a <_exit>:
    133a:	f8 94       	cli

0000133c <__stop_program>:
    133c:	ff cf       	rjmp	.-2      	; 0x133c <__stop_program>
